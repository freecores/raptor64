                  	           		; ============================================================================
                  	           		 ;        __
                  	           		 ;   \\__/ o\    (C) 2012-2013  Robert Finch, Stratford
                  	           		 ;    \  __ /    All rights reserved.
                  	           		 ;     \/_//     robfinch<remove>@opencores.org
                  	           		 ;       ||
                  	           		 ;  
                  	           		 ;
                  	           		 ; This source file is free software: you can redistribute it and/or modify 
                  	           		 ; it under the terms of the GNU Lesser General Public License as published 
                  	           		 ; by the Free Software Foundation, either version 3 of the License, or     
                  	           		 ; (at your option) any later version.                                      
                  	           		 ;                                                                          
                  	           		 ; This source file is distributed in the hope that it will be useful,      
                  	           		 ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                  	           		 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                  	           		 ; GNU General Public License for more details.                             
                  	           		 ;                                                                          
                  	           		 ; You should have received a copy of the GNU General Public License        
                  	           		 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                  	           		 ;                                                                          
                  	           		 ; ============================================================================
                  	           		 ;
                  	           		 CR	EQU	0x0D		;ASCII equates
                  	           		 LF	EQU	0x0A
                  	           		 TAB	EQU	0x09
                  	           		 CTRLC	EQU	0x03
                  	           		 CTRLH	EQU	0x08
                  	           		 CTRLI	EQU	0x09
                  	           		 CTRLJ	EQU	0x0A
                  	           		 CTRLK	EQU	0x0B
                  	           		 CTRLM   EQU 0x0D
                  	           		 CTRLS	EQU	0x13
                  	           		 CTRLX	EQU	0x18
                  	           		 XON		EQU	0x11
                  	           		 XOFF	EQU	0x13
                  	           		 
                  	           		 EX_IRQ	EQU	449
                  	           		 
                  	           		 DATA_PRESENT	EQU	0x01		; there is data preset at the serial port bc_uart3
                  	           		 XMIT_NOT_FULL	EQU	0x20
                  	           		 
                  	           		 BUFLEN	EQU	80	;	length of keyboard input buffer
                  	           		 
                  	           		 ; Initial stack tops for contexts
                  	           		 ; Each context gets 1k from the special 16k startup stack memory
                  	           		 ;
                  	           		 STACKTOP0	EQU		0xFFFF_FFFF_FFFE_FFF8
                  	           		 STACKTOP1	EQU		0xFFFF_FFFF_FFFE_FBF8
                  	           		 STACKTOP2	EQU		0xFFFF_FFFF_FFFE_F7F8
                  	           		 STACKTOP3	EQU		0xFFFF_FFFF_FFFE_F3F8
                  	           		 STACKTOP4	EQU		0xFFFF_FFFF_FFFE_EFF8
                  	           		 STACKTOP5	EQU		0xFFFF_FFFF_FFFE_EBF8
                  	           		 STACKTOP6	EQU		0xFFFF_FFFF_FFFE_E7F8
                  	           		 STACKTOP7	EQU		0xFFFF_FFFF_FFFE_E3F8
                  	           		 STACKTOP8	EQU		0xFFFF_FFFF_FFFE_DFF8
                  	           		 STACKTOP9	EQU		0xFFFF_FFFF_FFFE_DBF8
                  	           		 STACKTOP10	EQU		0xFFFF_FFFF_FFFE_D7F8
                  	           		 STACKTOP11	EQU		0xFFFF_FFFF_FFFE_D3F8
                  	           		 STACKTOP12	EQU		0xFFFF_FFFF_FFFE_CFF8
                  	           		 STACKTOP13	EQU		0xFFFF_FFFF_FFFE_CBF8
                  	           		 STACKTOP14	EQU		0xFFFF_FFFF_FFFE_C7F8
                  	           		 STACKTOP15	EQU		0xFFFF_FFFF_FFFE_C3F8
                  	           		 
                  	           		 
                  	           		 ; BOOT ROM routines
                  	           		 
                  	           		 TCBSize		EQU		0x200			; 512 bytes per TCB
                  	           		 TCBBase		EQU		0x00000001_00000000			; TCB pages
                  	           		 TCBr1		EQU		0x00
                  	           		 TCBr2		EQU		0x08
                  	           		 TCBr3		EQU		0x10
                  	           		 TCBr4		EQU		0x18
                  	           		 TCBr5		EQU		0x20
                  	           		 TCBr6		EQU		0x28
                  	           		 TCBr7		EQU		0x30
                  	           		 TCBr8		EQU		0x38
                  	           		 TCBr9		EQU		0x40
                  	           		 TCBr10		EQU		0x48
                  	           		 TCBr11		EQU		0x50
                  	           		 TCBr12		EQU		0x58
                  	           		 TCBr13		EQU		0x60
                  	           		 TCBr14		EQU		0x68
                  	           		 TCBr15		EQU		0x70
                  	           		 TCBr16		EQU		0x78
                  	           		 TCBr17		EQU		0x80
                  	           		 TCBr18		EQU		0x88
                  	           		 TCBr19		EQU		0x90
                  	           		 TCBr20		EQU		0x98
                  	           		 TCBr21		EQU		0xA0
                  	           		 TCBr22		EQU		0xA8
                  	           		 TCBr23		EQU		0xB0
                  	           		 TCBr24		EQU		0xB8
                  	           		 TCBr25		EQU		0xC0
                  	           		 TCBr26		EQU		0xC8
                  	           		 TCBr27		EQU		0xD0
                  	           		 TCBr28		EQU		0xD8
                  	           		 TCBr29		EQU		0xE0
                  	           		 TCBr30		EQU		0xE8
                  	           		 TCBr31		EQU		0xF0
                  	           		 
                  	           		 SCREENGATE	EQU		0x00
                  	           		 KEYBDGATE	EQU		0x01
                  	           		 VIDEOGATE	EQU		0x02
                  	           		 CARDGATE	EQU		0x03
                  	           		 warmStart   EQU     0x1020
                  	           		 usrJmp      EQU     0x1028
                  	           		 TickIRQAddr		EQU		0x1030
                  	           		 TaskBlock		EQU		0x1038
                  	           		 Milliseconds	EQU		0x1400
                  	           		 Lastloc			EQU		0x1408
                  	           		 CharColor	EQU		0x1410
                  	           		 ScreenColor	EQU		0x1414
                  	           		 CursorRow	EQU		0x1417
                  	           		 CursorCol	EQU		0x1418
                  	           		 CursorFlash	EQU		0x141A
                  	           		 KeybdEcho	EQU		0x141C
                  	           		 KeybdBuffer	EQU		0x1440
                  	           		 KeybdHead	EQU		0x1450
                  	           		 KeybdTail	EQU		0x1451
                  	           		 sp_save		EQU		0x1460
                  	           		 lr_save		EQU		0x1468
                  	           		 r1_save		EQU		0x1470
                  	           		 r2_save		EQU		0x1478
                  	           		 r26_save	EQU		0x1480
                  	           		 Score		EQU		0x1500
                  	           		 Manpos		EQU		0x1508
                  	           		 MissileActive	EQU		0x1510
                  	           		 MissileX	EQU		0x1512
                  	           		 MissileY	EQU		0x1514
                  	           		 InvadersRow1	EQU		0x1520
                  	           		 InvadersRow2	EQU		0x1530
                  	           		 InvadersRow3	EQU		0x1540
                  	           		 InvadersRow4	EQU		0x1550
                  	           		 InvadersRow5	EQU		0x1560
                  	           		 InvadersColpos	EQU		0x1570
                  	           		 InvadersRowpos	EQU		0x1571
                  	           		 Uart_rxfifo		EQU		0x1600
                  	           		 Uart_rxhead		EQU		0x1800
                  	           		 Uart_rxtail		EQU		0x1802
                  	           		 Uart_ms			EQU		0x1808
                  	           		 Uart_rxrts		EQU		0x1809
                  	           		 Uart_rxdtr		EQU		0x180A
                  	           		 Uart_rxxon		EQU		0x180B
                  	           		 Uart_rxflow		EQU		0x180C
                  	           		 Uart_fon		EQU		0x180E
                  	           		 Uart_foff		EQU		0x1810
                  	           		 Uart_txrts		EQU		0x1812
                  	           		 Uart_txdtr		EQU		0x1813
                  	           		 Uart_txxon		EQU		0x1814
                  	           		 Uart_txxonoff	EQU		0x1815
                  	           		 TaskList		EQU		0x2000
                  	           		 ReadyList1		EQU		0x2000
                  	           		 ReadyList2		EQU		0x2020
                  	           		 ReadyList3		EQU		0x2040
                  	           		 ReadyList4		EQU		0x2060
                  	           		 ReadyList5		EQU		0x2080
                  	           		 ReadyNdx1		EQU		0x20A0
                  	           		 ReadyNdx2		EQU		0x20A1
                  	           		 ReadyNdx3		EQU		0x20A2
                  	           		 ReadyNdx4		EQU		0x20A3
                  	           		 ReadyNdx5		EQU		0x20A4
                  	           		 RunningTCB		EQU		0x20A6
                  	           		 NextToRunTCB	EQU		0x20A8
                  	           		 r1save			EQU		0x20B0
                  	           		 r2save			EQU		0x20B8
                  	           		 AXCstart		EQU		0x20C0
                  	           		 
                  	           		 ; Context startup address table
                  	           		 ;
                  	           		 ctx0start		EQU		0x20D0
                  	           		 ctx1start		EQU		0x20D8
                  	           		 ctx2start		EQU		0x20E0
                  	           		 ctx3start		EQU		0x20E8
                  	           		 ctx4start		EQU		0x20F0
                  	           		 ctx5start		EQU		0x20F8
                  	           		 ctx6start		EQU		0x2100
                  	           		 ctx7start		EQU		0x2108
                  	           		 ctx8start		EQU		0x2110
                  	           		 ctx9start		EQU		0x2118
                  	           		 ctx10start		EQU		0x2120
                  	           		 ctx11start		EQU		0x2128
                  	           		 ctx12start		EQU		0x2130
                  	           		 ctx13start		EQU		0x2138
                  	           		 ctx14start		EQU		0x2140
                  	           		 ctx15start		EQU		0x2148
                  	           		 sp_saves		EQU		0x2200
                  	           		 sp_saves_end	EQU		0x2280
                  	           		 p100IRQvec		EQU		0x3000
                  	           		 keybdIRQvec		EQU		0x3008
                  	           		 serialIRQvec	EQU		0x3010
                  	           		 rasterIRQvec	EQU		0x3018
                  	           		 
                  	           		 startSector	EQU		0x30F8
                  	           		 BPB			EQU		0x3100
                  	           		 
                  	           		 TEXTSCR		EQU		0xD0_0000
                  	           		 COLORSCR	EQU		0xD1_0000
                  	           		 TEXTREG		EQU		0xDA_0000
                  	           		 TEXT_COLS	EQU		0x0
                  	           		 TEXT_ROWS	EQU		0x2
                  	           		 TEXT_CURPOS	EQU		0x16
                  	           		 KEYBD		EQU		0xDC_0000
                  	           		 KEYBDCLR	EQU		0xDC_0002
                  	           		 
                  	           		 UART		EQU		0xDC_0A00
                  	           		 UART_LS		EQU		0xDC_0A01
                  	           		 UART_MS		EQU		0xDC_0A02
                  	           		 UART_IS		EQU		0xDC_0A03
                  	           		 UART_IE		EQU		0xDC_0A04
                  	           		 UART_MC		EQU		0xDC_0A06
                  	           		 DATETIME	EQU		0xDC_0400
                  	           		 
                  	           		 SPIMASTER	EQU		0xDC_0500
                  	           		 SPI_MASTER_VERSION_REG	EQU	0x00
                  	           		 SPI_MASTER_CONTROL_REG	EQU	0x01
                  	           		 SPI_TRANS_TYPE_REG	EQU		0x02
                  	           		 SPI_TRANS_CTRL_REG	EQU		0x03
                  	           		 SPI_TRANS_STATUS_REG	EQU	0x04
                  	           		 SPI_TRANS_ERROR_REG		EQU	0x05
                  	           		 SPI_DIRECT_ACCESS_DATA_REG		EQU	0x06
                  	           		 SPI_SD_ADDR_7_0_REG		EQU	0x07
                  	           		 SPI_SD_ADDR_15_8_REG	EQU	0x08
                  	           		 SPI_SD_ADDR_23_16_REG	EQU	0x09
                  	           		 SPI_SD_ADDR_31_24_REG	EQU	0x0a
                  	           		 SPI_RX_FIFO_DATA_REG	EQU	0x10
                  	           		 SPI_RX_FIFO_DATA_COUNT_MSB	EQU	0x12
                  	           		 SPI_RX_FIFO_DATA_COUNT_LSB  EQU 0x13
                  	           		 SPI_RX_FIFO_CTRL_REG		EQU	0x14
                  	           		 SPI_TX_FIFO_DATA_REG	EQU	0x20
                  	           		 SPI_TX_FIFO_CTRL_REG	EQU	0x24
                  	           		 SPI_INIT_SD			EQU		0x01
                  	           		 SPI_TRANS_START		EQU		0x01
                  	           		 SPI_TRANS_BUSY		EQU		0x01
                  	           		 SPI_INIT_NO_ERROR	EQU		0x00
                  	           		 SPI_READ_NO_ERROR	EQU		0x00
                  	           		 RW_READ_SD_BLOCK	EQU		0x02
                  	           		 RW_WRITE_SD_BLOCK	EQU		0x03
                  	           		 
                  	           		 
                  	           		 PIC			EQU		0xDC_0FF0
                  	           		 PIC_IE		EQU		0xDC_0FF2
                  	           		 
                  	           		 PSG			EQU		0xD5_0000
                  	           		 PSGFREQ0	EQU		0xD5_0000
                  	           		 PSGPW0		EQU		0xD5_0002
                  	           		 PSGCTRL0	EQU		0xD5_0004
                  	           		 PSGADSR0	EQU		0xD5_0006
                  	           		 
                  	           		 SPRRAM		EQU		0xD8_0000
                  	           		 AC97		EQU		0xDC_1000
                  	           		 TMP			EQU		0xDC_0300
                  	           		 LED			EQU		0xDC_0600
                  	           		 ETHMAC		EQU		0xDC_2000
                  	           		 CONFIGREC	EQU		0xDC_FFFF
                  	           		 MIIMODER	EQU		0x28
                  	           		 MIIADDRESS	EQU		0x30
                  	           		 GACCEL		EQU		0xDA_E000
                  	           		 RASTERIRQ	EQU		0xDA_0100
                  	           		 BOOT_STACK	EQU		0xFFFF_FFFF_FFFE_FFF8
                  	           		 SPRITEREGS	EQU		0xDA_D000
                  	           		 BITMAPSCR	EQU		0x00000001_00200000
                  	           		 
                  	           		 BOOTJMP		EQU		0x100800204
                  	           		 
                  	           		 txempty	EQU		0x40
                  	           		 rxfull	EQU		0x01
                  	           		 
                  	           		 ;
                  	           		 ; Internal variables follow:
                  	           		 ;
0000000100600000	           		 		bss
0000000000001048	           		 		org		0x1048
0000000000000000	           		 pos		dh		0		; text screen position
                  	           		 
1050 0000000000000000	 lineLinkTbl		fill.b	47,0	; screen line link table
1058 0000000000000000
1060 0000000000000000
1068 0000000000000000
1070 0000000000000000
1078 0000000000000000
0000000000001088	           		         align   8
0000000000001088 0000000000000001	 OSSP	dw	1	; OS value of sp
0000000000001090 0000000000000001	 CURRNT	dw	1	;	Current line pointer
0000000000001098 0000000000000001	 STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
00000000000010A0 0000000000000001	 STKINP	dw	1	;	Saves stack pointer during 'INPUT'
00000000000010A8 0000000000000001	 LOPVAR	dw	1	;	'FOR' loop save area
00000000000010B0 0000000000000001	 LOPINC	dw	1	;	increment
00000000000010B8 0000000000000001	 LOPLMT	dw	1	;	limit
00000000000010C0 0000000000000001	 LOPLN	dw	1	;	line number
00000000000010C8 0000000000000001	 LOPPT	dw	1	;	text pointer
00000000000010D0 0000000000000001	 TXTUNF	dw	1	;	points to unfilled text area
00000000000010D8 0000000000000001	 VARBGN	dw	1	;	points to variable area
00000000000010E0 0000000000000001	 IVARBGN dw  1   ;   points to integer variable area
00000000000010E8 0000000000000001	 SVARBGN dw  1   ;   points to string variable area
00000000000010F0 0000000000000001	 FVARBGN dw  1   ;   points to float variable area
00000000000010F8 0000000000000001	 STKBOT	dw	1	;	holds lower limit for stack growth
1100 0000000000000000	 NUMWKA	fill.b	24,0			; numeric work area
1108 0000000000000000
1110 0000000000000000
1118 0000000000000000	 BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
1120 0000000000000000
1128 0000000000000000
1130 0000000000000000
1138 0000000000000000
1140 0000000000000000
1148 0000000000000000
1150 0000000000000000
1158 0000000000000000
1160 0000000000000000
                  	           		 
000000000000116E	           		         bss
0000000100600000	           		         org     0x1_00600000
                  	           		 TXT		equ		0x1_00600000	; Beginning of program area
                  	           		 
                  	           		 ;	org 0x070
                  	           		 ;	iret
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;
0000000000000000	           		 	code
FFFFFFFFFFFFB000	           		 	org 0xFFFF_FFFF_FFFF_B000
                  	           		 
                  	           		 ; jump table
                  	           		 ;
FFFFFFFFFFFFB000	33FFEDA4		 	jmp		SerialGetChar
FFFFFFFFFFFFB004	33FFED5C		 	jmp		SerialPutChar
FFFFFFFFFFFFB008	33FFEF05		 	jmp		SetKeyboardEcho
FFFFFFFFFFFFB00C	33FFEF1C		 	jmp		KeybdCheckForKey
FFFFFFFFFFFFB010	33FFEF07		 	jmp		KeybdGetChar
FFFFFFFFFFFFB014	33FFF07F		 	jmp		DisplayChar
FFFFFFFFFFFFB018	33FFF122		 	jmp		DisplayString
FFFFFFFFFFFFB01C	33FFF13F		 	jmp		DisplayNum
FFFFFFFFFFFFB020	33FFF06F		 	jmp		CalcScreenLoc
FFFFFFFFFFFFB024	33FFF011		 	jmp		ClearScreen
FFFFFFFFFFFFB028	33FFF169		 	jmp		DisplayWord
                  	           		 
FFFFFFFFFFFFB02C	           		 start:
                  	           		 ;	lea		MSGRAM,a1
                  	           		 ;	jsr		DisplayString
                  	           		 
FFFFFFFFFFFFB02C	           		 ColdStart:
FFFFFFFFFFFFB02C	0000000B		 	icache_off				; turn on the ICache
FFFFFFFFFFFFB030	0000000D		 	dcache_off				; turn on the DCache
                  	           		 
                  	           		 ; Make sure semaphores are available by closing the gates.
                  	           		 ; We don't know what power up state is.
                  	           		 
FFFFFFFFFFFFB034	02000075		 	cmgi	#KEYBDGATE
FFFFFFFFFFFFB038	020000B5		 	cmgi	#VIDEOGATE
                  	           		 
                  	           		 ; Initialize the context startup address table with NULL
                  	           		 
FFFFFFFFFFFFB03C	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFB040	6600A0D0		 	sw		r1,ctx0start
FFFFFFFFFFFFB044	6600A0D8		 	sw		r1,ctx1start
FFFFFFFFFFFFB048	6600A0E0		 	sw		r1,ctx2start
FFFFFFFFFFFFB04C	6600A0E8		 	sw		r1,ctx3start
FFFFFFFFFFFFB050	6600A0F0		 	sw		r1,ctx4start
FFFFFFFFFFFFB054	6600A0F8		 	sw		r1,ctx5start
FFFFFFFFFFFFB058	6600A100		 	sw		r1,ctx6start
FFFFFFFFFFFFB05C	6600A108		 	sw		r1,ctx7start
FFFFFFFFFFFFB060	6600A110		 	sw		r1,ctx8start
FFFFFFFFFFFFB064	6600A118		 	sw		r1,ctx9start
FFFFFFFFFFFFB068	6600A120		 	sw		r1,ctx10start
FFFFFFFFFFFFB06C	6600A128		 	sw		r1,ctx11start
FFFFFFFFFFFFB070	6600A130		 	sw		r1,ctx12start
FFFFFFFFFFFFB074	6600A138		 	sw		r1,ctx13start
FFFFFFFFFFFFB078	6600A140		 	sw		r1,ctx14start
FFFFFFFFFFFFB07C	6600A148		 	sw		r1,ctx15start
                  	           		 
                  	           		 ; Initialize the context schedule with all contexts treated equally
                  	           		 ; There are only 16 contexts, but 256 schedule slots. Each context is
                  	           		 ; given 16 slots distributed evenly throughout the execution pattern
                  	           		 ; table.
                  	           		 ;
FFFFFFFFFFFFB080	0410840A		 	xor		r1,r1,r1	; r1 = 0
FFFFFFFFFFFFB084	           		 ict1:
FFFFFFFFFFFFB084	0410803A		 	mtep	r1,r1		; only the low order four bits of r1 will move to the pattern table
FFFFFFFFFFFFB088	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFB08C	101100FF		 	cmpi	r2,r1,#255
FFFFFFFFFFFFB090	BE207FA9		 	bne		r2,r0,ict1
                  	           		 
                  	           		 ; Point the interrupt return address register of the context to the 
                  	           		 ; context startup code. The context will start up when an interrupt return
                  	           		 ; occurs.
                  	           		 ;
                  	           		 ; We cannot use a loop for this. Fortunately there's only 16 contexts.
                  	           		 ;
FFFFFFFFFFFFB094	E6BFB228		; SETLO
FFFFFFFFFFFFB098	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB09C	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB0A0	E6BEFFF8		; SETLO
FFFFFFFFFFFFB0A4	6A0D782D		 	lea		r30,STACKTOP0
FFFFFFFFFFFFB0A8	0000000F		 	iepp
FFFFFFFFFFFFB0AC	E6BFB228		; SETLO
FFFFFFFFFFFFB0B0	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB0B4	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB0B8	E6BEFBF8		; SETLO
FFFFFFFFFFFFB0BC	6A0D782D		 	lea		r30,STACKTOP1
FFFFFFFFFFFFB0C0	0000000F		 	iepp		
FFFFFFFFFFFFB0C4	E6BFB228		; SETLO
FFFFFFFFFFFFB0C8	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB0CC	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB0D0	E6BEF7F8		; SETLO
FFFFFFFFFFFFB0D4	6A0D782D		 	lea		r30,STACKTOP2
FFFFFFFFFFFFB0D8	0000000F		 	iepp		
FFFFFFFFFFFFB0DC	E6BFB228		; SETLO
FFFFFFFFFFFFB0E0	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB0E4	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB0E8	E6BEF3F8		; SETLO
FFFFFFFFFFFFB0EC	6A0D782D		 	lea		r30,STACKTOP3
FFFFFFFFFFFFB0F0	0000000F		 	iepp		
                  	           		 
FFFFFFFFFFFFB0F4	E6BFB228		; SETLO
FFFFFFFFFFFFB0F8	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB0FC	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB100	E6BEEFF8		; SETLO
FFFFFFFFFFFFB104	6A0D782D		 	lea		r30,STACKTOP4
FFFFFFFFFFFFB108	0000000F		 	iepp
FFFFFFFFFFFFB10C	E6BFB228		; SETLO
FFFFFFFFFFFFB110	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB114	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB118	E6BEEBF8		; SETLO
FFFFFFFFFFFFB11C	6A0D782D		 	lea		r30,STACKTOP5
FFFFFFFFFFFFB120	0000000F		 	iepp		
FFFFFFFFFFFFB124	E6BFB228		; SETLO
FFFFFFFFFFFFB128	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB12C	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB130	E6BEE7F8		; SETLO
FFFFFFFFFFFFB134	6A0D782D		 	lea		r30,STACKTOP6
FFFFFFFFFFFFB138	0000000F		 	iepp		
FFFFFFFFFFFFB13C	E6BFB228		; SETLO
FFFFFFFFFFFFB140	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB144	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB148	E6BEE3F8		; SETLO
FFFFFFFFFFFFB14C	6A0D782D		 	lea		r30,STACKTOP7
FFFFFFFFFFFFB150	0000000F		 	iepp		
                  	           		 	
FFFFFFFFFFFFB154	E6BFB228		; SETLO
FFFFFFFFFFFFB158	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB15C	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB160	E6BEDFF8		; SETLO
FFFFFFFFFFFFB164	6A0D782D		 	lea		r30,STACKTOP8
FFFFFFFFFFFFB168	0000000F		 	iepp
FFFFFFFFFFFFB16C	E6BFB228		; SETLO
FFFFFFFFFFFFB170	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB174	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB178	E6BEDBF8		; SETLO
FFFFFFFFFFFFB17C	6A0D782D		 	lea		r30,STACKTOP9
FFFFFFFFFFFFB180	0000000F		 	iepp		
FFFFFFFFFFFFB184	E6BFB228		; SETLO
FFFFFFFFFFFFB188	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB18C	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB190	E6BED7F8		; SETLO
FFFFFFFFFFFFB194	6A0D782D		 	lea		r30,STACKTOP10
FFFFFFFFFFFFB198	0000000F		 	iepp		
FFFFFFFFFFFFB19C	E6BFB228		; SETLO
FFFFFFFFFFFFB1A0	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB1A4	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB1A8	E6BED3F8		; SETLO
FFFFFFFFFFFFB1AC	6A0D782D		 	lea		r30,STACKTOP11
FFFFFFFFFFFFB1B0	0000000F		 	iepp		
                  	           		 	
FFFFFFFFFFFFB1B4	E6BFB228		; SETLO
FFFFFFFFFFFFB1B8	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB1BC	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB1C0	E6BECFF8		; SETLO
FFFFFFFFFFFFB1C4	6A0D782D		 	lea		r30,STACKTOP12
FFFFFFFFFFFFB1C8	0000000F		 	iepp
FFFFFFFFFFFFB1CC	E6BFB228		; SETLO
FFFFFFFFFFFFB1D0	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB1D4	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB1D8	E6BECBF8		; SETLO
FFFFFFFFFFFFB1DC	6A0D782D		 	lea		r30,STACKTOP13
FFFFFFFFFFFFB1E0	0000000F		 	iepp		
FFFFFFFFFFFFB1E4	E6BFB228		; SETLO
FFFFFFFFFFFFB1E8	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB1EC	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB1F0	E6BEC7F8		; SETLO
FFFFFFFFFFFFB1F4	6A0D782D		 	lea		r30,STACKTOP14
FFFFFFFFFFFFB1F8	0000000F		 	iepp		
FFFFFFFFFFFFB1FC	E6BFB228		; SETLO
FFFFFFFFFFFFB200	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB204	03900869		 	mtspr	IPC,r25
FFFFFFFFFFFFB208	E6BEC3F8		; SETLO
FFFFFFFFFFFFB20C	6A0D782D		 	lea		r30,STACKTOP15
FFFFFFFFFFFFB210	0000000F		 	iepp		
                  	           		 
                  	           		 ; Ensure that context zero is the active context
                  	           		 ;
FFFFFFFFFFFFB214	           		 ctxstart3:
FFFFFFFFFFFFB214	02008568		 	mfspr	r1,AXC			
FFFFFFFFFFFFB218	BE100068		 	beq		r1,r0,ctxstart2
FFFFFFFFFFFFB21C	0000000F		 	iepp
FFFFFFFFFFFFB220	BE007FAA		 	bra		ctxstart3
FFFFFFFFFFFFB224	           		 ctxstart2:	
FFFFFFFFFFFFB224	6000A0C0		 	sb		r1,AXCstart		; save off the startup context which should be context zero
                  	           		 
                  	           		 ; Entry point for context startup
                  	           		 ;
                  	           		 ; Avoid repeating all the system initialization when a context starts up by testing whether
                  	           		 ; or not the context is the starting context.
                  	           		 ;
FFFFFFFFFFFFB228	           		 ctxstart:
FFFFFFFFFFFFB228	02008568		 	mfspr	r1,AXC
FFFFFFFFFFFFB22C	4A0120C0		 	lbu		r2,AXCstart
FFFFFFFFFFFFB230	BE110E69		 	bne		r1,r2,ctxstart1
                  	           		 	
                  	           		 ;
                  	           		 ; set system vectors
                  	           		 ; TBA defaults to zero on reset
                  	           		 ;
FFFFFFFFFFFFB234	E0C00000		 	setlo	r3,#0
FFFFFFFFFFFFB238	E08001FF		 	setlo	r2,#511
FFFFFFFFFFFFB23C	9A00FB38		 	lea		r1,nmirout
FFFFFFFFFFFFB240	           		 csj5:
FFFFFFFFFFFFB240	66308000		 	sw		r1,[r3]
FFFFFFFFFFFFB244	0A318008		 	addui	r3,r3,#8
FFFFFFFFFFFFB248	BE017FCF		 	loop	r2,csj5
FFFFFFFFFFFFB24C	E6BFB8A8		; SETLO
FFFFFFFFFFFFB250	6A0D042D		 	lea		r1,VideoSC		; Video BIOS vector
FFFFFFFFFFFFB254	66008CD0		 	sw		r1,0xCD0
FFFFFFFFFFFFB258	9A008000		 	lea		r1,SCCARDSC		; SD Card BIOS vector
FFFFFFFFFFFFB25C	66008CE8		 	sw		r1,0xCE8
FFFFFFFFFFFFB260	E6BFBAA8		; SETLO
FFFFFFFFFFFFB264	6A0D042D		 	lea		r1,RTCSC		; Real time clock vector
FFFFFFFFFFFFB268	66008D00		 	sw		r1,0xD00
FFFFFFFFFFFFB26C	E6BFBB14		; SETLO
FFFFFFFFFFFFB270	6A0D042D		 	lea		r1,KeybdSC		; keyboard BIOS vector
FFFFFFFFFFFFB274	66008D08		 	sw		r1,0xD08
FFFFFFFFFFFFB278	9A00FA5C		 	lea		r1,irqrout
FFFFFFFFFFFFB27C	66008E08		 	sw		r1,0xE08		; set IRQ vector
FFFFFFFFFFFFB280	9A00FB94		 	lea		r1,ui_irout
FFFFFFFFFFFFB284	66008F78		 	sw		r1,0xF78		; set unimplemented instruction vector
FFFFFFFFFFFFB288	9A00F9BC		 	lea		r1,dberr_rout
FFFFFFFFFFFFB28C	66008FE0		 	sw		r1,0xFE0		; set Bus error vector
FFFFFFFFFFFFB290	9A00F9A4		 	lea		r1,iberr_rout
FFFFFFFFFFFFB294	66008FE8		 	sw		r1,0xFE8		; set Bus error vector
FFFFFFFFFFFFB298	9A00FB38		 	lea		r1,nmirout
FFFFFFFFFFFFB29C	66008FF0		 	sw		r1,0xFF0		; set NMI vector
                  	           		 
                  	           		 ; set system interrupt hook vectors
                  	           		 
FFFFFFFFFFFFB2A0	E6BFBBC0		; SETLO
FFFFFFFFFFFFB2A4	6A0D042D		 	lea		r1,KeybdIRQ
FFFFFFFFFFFFB2A8	6600B008		 	sw		r1,keybdIRQvec
FFFFFFFFFFFFB2AC	E6BFBDCC		; SETLO
FFFFFFFFFFFFB2B0	6A0D042D		 	lea		r1,Pulse100
FFFFFFFFFFFFB2B4	6600B000		 	sw		r1,p100IRQvec
FFFFFFFFFFFFB2B8	E6BFB768		; SETLO
FFFFFFFFFFFFB2BC	6A0D042D		 	lea		r1,SerialIRQ
FFFFFFFFFFFFB2C0	6600B010		 	sw		r1,serialIRQvec
FFFFFFFFFFFFB2C4	9A00D1AC		 	lea		r1,RasterIRQfn
FFFFFFFFFFFFB2C8	6600B018		 	sw		r1,rasterIRQvec
                  	           		 
                  	           		 	;-------------------------------
                  	           		 	; Initialize I/O devices
                  	           		 	;-------------------------------
FFFFFFFFFFFFB2CC	E69CFFFF		; SETLO
FFFFFFFFFFFFB2D0	EE800003		; SETMID
FFFFFFFFFFFFB2D4	6A0D0424		 	inbu	r1,CONFIGREC
FFFFFFFFFFFFB2D8	2A108824		 	bfext	r1,r1,#4,#4
FFFFFFFFFFFFB2DC	BE100048		 	beq		r1,r0,skip5
FFFFFFFFFFFFB2E0	31FFEF3A		 	call	tmp_init
FFFFFFFFFFFFB2E4	           		 skip5:
FFFFFFFFFFFFB2E4	E69CFFFF		; SETLO
FFFFFFFFFFFFB2E8	EE800003		; SETMID
FFFFFFFFFFFFB2EC	6A0D0424		 	inbu	r1,CONFIGREC
FFFFFFFFFFFFB2F0	2A108A2C		 	bfext	r1,r1,#5,#5
FFFFFFFFFFFFB2F4	BE100048		 	beq		r1,r0,skip4
FFFFFFFFFFFFB2F8	31FFED3C		 	call	SerialInit
FFFFFFFFFFFFB2FC	           		 skip4:
FFFFFFFFFFFFB2FC	31FFEEEB		 	call	KeybdInit
FFFFFFFFFFFFB300	31FFED34		 	call	PICInit
FFFFFFFFFFFFB304	31FFF453		 	call	SetupRasterIRQ
FFFFFFFFFFFFB308	00000040		 	cli						; enable interrupts
                  	           		 ;	call	HelloWorld
FFFFFFFFFFFFB30C	E0C000CE		 	setlo	r3,#0xCE		; blue on blue
FFFFFFFFFFFFB310	62019414		 	sc		r3,ScreenColor
FFFFFFFFFFFFB314	62019410		 	sc		r3,CharColor
FFFFFFFFFFFFB318	42019414		 	lc		r3,0x1414
FFFFFFFFFFFFB31C	E0C00020		 	setlo	r3,#32
FFFFFFFFFFFFB320	62019416		 	sc		r3,0x1416		; we do a store, then a load through the dcache
FFFFFFFFFFFFB324	42011416		 	lc		r2,0x1416		;
FFFFFFFFFFFFB328	BE218048		 	beq		r2,r3,dcokay
FFFFFFFFFFFFB32C	0000000D		 	dcache_off				; data cache failed
FFFFFFFFFFFFB330	           		 dcokay:
FFFFFFFFFFFFB330	620020A8		 	sc		r0,NextToRunTCB
FFFFFFFFFFFFB334	620020A6		 	sc		r0,RunningTCB
FFFFFFFFFFFFB338	16008002		 	lw		r1,#2			; get rid of startup keyboard glitchs by trying to get a character
FFFFFFFFFFFFB33C	0181D097		 	syscall	#417
FFFFFFFFFFFFB340	16008002		 	lw		r1,#2			; get rid of startup keyboard glitchs by trying to get a character
FFFFFFFFFFFFB344	0181D097		 	syscall	#417
                  	           		 
                  	           		 	; wait for screen to be available
FFFFFFFFFFFFB348	31FFF011		 	call	ClearScreen
FFFFFFFFFFFFB34C	31FFEFFC		 	call	ClearBmpScreen
                  	           		 
                  	           		 ; Test whether or not the sprite controller is present. Skip
                  	           		 ; Initialization if it isn't.
                  	           		 
FFFFFFFFFFFFB350	E69CFFFF		; SETLO
FFFFFFFFFFFFB354	EE800003		; SETMID
FFFFFFFFFFFFB358	6A0D0420		 	inb		r1,CONFIGREC
FFFFFFFFFFFFB35C	2A108004		 	bfext	r1,r1,#0,#0
FFFFFFFFFFFFB360	BE100048		 	beq		r1,r0,skip1
FFFFFFFFFFFFB364	31FFF3A7		 	call	RandomizeSprram
FFFFFFFFFFFFB368	           		 skip1:
                  	           		 
FFFFFFFFFFFFB368	60001417		 	sb		r0,CursorRow
FFFFFFFFFFFFB36C	60001418		 	sb		r0,CursorCol
FFFFFFFFFFFFB370	16008001		 	lw		r1,#1
FFFFFFFFFFFFB374	6000941A		 	sb		r1,CursorFlash
FFFFFFFFFFFFB378	E6BFB4AD		; SETLO
FFFFFFFFFFFFB37C	6A0D042D		 	lea		r1,MSGSTART
FFFFFFFFFFFFB380	31FFF130		 	call	DisplayStringCRLF
                  	           		 
                  	           		 ; Test whether or not sound generator is present
                  	           		 ; skip initialization and beep if not present
                  	           		 
FFFFFFFFFFFFB384	E69CFFFF		; SETLO
FFFFFFFFFFFFB388	EE800003		; SETMID
FFFFFFFFFFFFB38C	6A0D0420		 	inb		r1,CONFIGREC
FFFFFFFFFFFFB390	2A108414		 	bfext	r1,r1,#2,#2
FFFFFFFFFFFFB394	BE1000E8		 	beq		r1,r0,skip2
FFFFFFFFFFFFB398	31FFF3B1		 	call	SetupAC97		; and Beep
FFFFFFFFFFFFB39C	16008004		 	lw		r1,#4
FFFFFFFFFFFFB3A0	E69C0600		; SETLO
FFFFFFFFFFFFB3A4	EE800003		; SETMID
FFFFFFFFFFFFB3A8	6A0D0428		 	outb	r1,LED
FFFFFFFFFFFFB3AC	31FFF3DB		 	call	Beep
FFFFFFFFFFFFB3B0	           		 skip2:
                  	           		 
FFFFFFFFFFFFB3B0	E6BFB428		; SETLO
FFFFFFFFFFFFB3B4	6A0D042D		 	lea		r1,context1disp	; start a display
FFFFFFFFFFFFB3B8	6600A0D8		 	sw		r1,ctx1start
                  	           		 
                  	           		 ; Startup Ethernet access ?
                  	           		 ;
FFFFFFFFFFFFB3BC	E69CFFFF		; SETLO
FFFFFFFFFFFFB3C0	EE800003		; SETMID
FFFFFFFFFFFFB3C4	6A0D0420		 	inb		r1,CONFIGREC
FFFFFFFFFFFFB3C8	2A10820C		 	bfext	r1,r1,#1,#1
FFFFFFFFFFFFB3CC	BE100068		 	beq		r1,r0,skip3
FFFFFFFFFFFFB3D0	9A00DD3C		 	lea		r1,eth_main
FFFFFFFFFFFFB3D4	6600A0E0		 	sw		r1,ctx2start
FFFFFFFFFFFFB3D8	           		 skip3:
                  	           		 
FFFFFFFFFFFFB3D8	9A00CDD0		 	lea		r1,RandomLines
FFFFFFFFFFFFB3DC	6600A0E8		 	sw		r1,ctx3start
FFFFFFFFFFFFB3E0	31FFF54E		 	call	spi_init
FFFFFFFFFFFFB3E4	BE100069		 	bne		r1,r0,skip_spi_read
FFFFFFFFFFFFB3E8	31FFF59D		 	call	spi_read_boot
FFFFFFFFFFFFB3EC	31FFF605		 	call	loadBootFile
FFFFFFFFFFFFB3F0	           		 skip_spi_read:
FFFFFFFFFFFFB3F0	33FFF20A		 	jmp		Monitor
                  	           		 
FFFFFFFFFFFFB3F4	           		 j4:
FFFFFFFFFFFFB3F4	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFB3F8	BE007FEA		 	bra		j4
                  	           		 
                  	           		 ; The contexts wait for a context startup address to be placed in the
                  	           		 ; startup table. Once an address is in the table, a call to the context
                  	           		 ; code will be made. The default is a NULL pointer, which
                  	           		 ; causes the context to loop around back to here while waiting for a
                  	           		 ; code to run.
                  	           		 ;
FFFFFFFFFFFFB3FC	           		 ctxstart1:
FFFFFFFFFFFFB3FC	9A00A0D0		 	lea		r1,ctx0start	; r1 = context start table base
FFFFFFFFFFFFB400	02010568		 	mfspr	r2,AXC			; r2 = index into start table
FFFFFFFFFFFFB404	6A110703		 	lw		r1,[r1+r2*8]	; r1 = context start address
FFFFFFFFFFFFB408	BE100048		 	beq		r1,r0,ctx12
FFFFFFFFFFFFB40C	341F8000		 	jal		lr,[r1]			; perform a call to the context code
                  	           		 
                  	           		 ; We might as well move to the next context, since there's nothing
                  	           		 ; to do. This can be accomplished by tirggering a IRQ interrupt.
                  	           		 ; We can't just increment the excution pattern pointer, because that
                  	           		 ; would only switch the register set and not the program counter.
                  	           		 ; An interrupt saves the program counter, and restores it from the
                  	           		 ; IPC context register.
                  	           		 ;
FFFFFFFFFFFFB410	           		 ctx12:
FFFFFFFFFFFFB410	00000040		 	sei					; causes a priv violation. don't allow interrupts during syscall
FFFFFFFFFFFFB414	DE000000		 	nop					; wait for sei to take effect
FFFFFFFFFFFFB418	DE000000		 	nop
FFFFFFFFFFFFB41C	DE000000		 	nop
FFFFFFFFFFFFB420	0181E097		 	syscall	#EX_IRQ	
FFFFFFFFFFFFB424	BE007ECA		 	bra		ctxstart1
                  	           		 
                  	           		 ;	call	ramtest
                  	           		 
FFFFFFFFFFFFB428	           		 context1disp:
                  	           		 
                  	           		 ; once we've started, clear the start vector so that the context
                  	           		 ; isn't continuously restarted.
                  	           		 ;
FFFFFFFFFFFFB428	660020D8		 	sw		r0,ctx1start
FFFFFFFFFFFFB42C	E6900000		; SETLO
FFFFFFFFFFFFB430	EE800003		; SETMID
FFFFFFFFFFFFB434	6A0D0C2D		 	lea		r3,TEXTSCR
FFFFFFFFFFFFB438	16008056		 	lw		r1,#'V'
FFFFFFFFFFFFB43C	1601014A		 	lw		r2,#330
FFFFFFFFFFFFB440	1602002F		 	lw		r4,#47
FFFFFFFFFFFFB444	31FFF063		 	call	AsciiToScreen
FFFFFFFFFFFFB448	           		 ctx11:
FFFFFFFFFFFFB448	6A310421		 	inch	r1,[r3+r2]
FFFFFFFFFFFFB44C	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFB450	6A310429		 	outc	r1,[r3+r2]
FFFFFFFFFFFFB454	0A2100A8		 	addui	r2,r2,#168
FFFFFFFFFFFFB458	BE027F8F		 	loop	r4,ctx11
FFFFFFFFFFFFB45C	BE007E6A		 	bra		context1disp
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Hello World!
                  	           		 ;-----------------------------------------
FFFFFFFFFFFFB460	           		 HelloWorld:
FFFFFFFFFFFFB460	0FEF0018		 	subui	r30,r30,#24
FFFFFFFFFFFFB464	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFB468	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFB46C	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFB470	E6BFB4A0		; SETLO
FFFFFFFFFFFFB474	6A0D082D		 	lea		r2,MSG
FFFFFFFFFFFFB478	           		 j3:
FFFFFFFFFFFFB478	40208000		 	lb		r1,[r2]
FFFFFFFFFFFFB47C	BE100088		 	beq		r1,r0,j2
FFFFFFFFFFFFB480	31FFED5C		 	call	SerialPutChar
FFFFFFFFFFFFB484	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFB488	BE007F8A		 	bra		j3
FFFFFFFFFFFFB48C	           		 j2:
FFFFFFFFFFFFB48C	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFB490	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFB494	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFB498	37EF8018		 	ret		#24
                  	           		 
                  	           		 
FFFFFFFFFFFFB498 0000000037EF8018	 	align	16
FFFFFFFFFFFFB4A0	           		 	align	16
FFFFFFFFFFFFB4A0	           		 MSG:	
FFFFFFFFFFFFB4A0 6F57206F6C6C6548	 	db	"Hello World!",0
FFFFFFFFFFFFB4AD	           		 MSGSTART:
FFFFFFFFFFFFB4A8 7061520021646C72	 	db	"Raptor64 system starting....",0
FFFFFFFFFFFFB4B0 7973203436726F74
FFFFFFFFFFFFB4B8 617473206D657473
FFFFFFFFFFFFB4C0 2E2E2E676E697472
                  	           		 
FFFFFFFFFFFFB4C8 000000000000002E	 	align 16
FFFFFFFFFFFFB4D0	           		 	align 16
                  	           		 
                  	           		 ;----------------------------------------------------------
                  	           		 ; Initialize programmable interrupt controller (PIC)
                  	           		 ;  0 = nmi (parity error)
                  	           		 ;  1 = keyboard reset
                  	           		 ;  2 = 1000Hz pulse (context switcher)
                  	           		 ;  3 = 100Hz pulse (cursor flash)
                  	           		 ;  4 = ethmac
                  	           		 ;  8 = uart
                  	           		 ; 13 = raster interrupt
                  	           		 ; 15 = keyboard char
                  	           		 ;----------------------------------------------------------
FFFFFFFFFFFFB4D0	           		 PICInit:
FFFFFFFFFFFFB4D0	E6BFB4EC		; SETLO
FFFFFFFFFFFFB4D4	6A0D042D		 	lea		r1,PICret
FFFFFFFFFFFFB4D8	66009030		 	sw		r1,TickIRQAddr
                  	           		 	; enable: raster irq,
FFFFFFFFFFFFB4DC	E07F800F		 	setlo	r1,#0x800F	; enable nmi,kbd_rst,and kbd_irq
                  	           		 	; A10F enable serial IRQ
FFFFFFFFFFFFB4E0	E69C0FF2		; SETLO
FFFFFFFFFFFFB4E4	EE800003		; SETMID
FFFFFFFFFFFFB4E8	6A0D0429		 	outc	r1,PIC_IE
FFFFFFFFFFFFB4EC	           		 PICret:
FFFFFFFFFFFFB4EC	37EF8000		 	ret
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Serial port
                  	           		 ;==============================================================================
                  	           		 ;-----------------------------------------
                  	           		 ; Initialize the serial port
                  	           		 ;-----------------------------------------
                  	           		 ;
FFFFFFFFFFFFB4F0	           		 SerialInit:
FFFFFFFFFFFFB4F0	62001800		 	sc		r0,Uart_rxhead		; reset buffer indexes
FFFFFFFFFFFFB4F4	62001802		 	sc		r0,Uart_rxtail
FFFFFFFFFFFFB4F8	E04001F0		 	setlo	r1,#0x1f0
FFFFFFFFFFFFB4FC	62009810		 	sc		r1,Uart_foff		; set threshold for XOFF
FFFFFFFFFFFFB500	E0400010		 	setlo	r1,#0x010
FFFFFFFFFFFFB504	6200980E		 	sc		r1,Uart_fon			; set threshold for XON
FFFFFFFFFFFFB508	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB50C	E69C0A04		; SETLO
FFFFFFFFFFFFB510	EE800003		; SETMID
FFFFFFFFFFFFB514	6A0D0428		 	outb	r1,UART_IE			; enable receive interrupt only
FFFFFFFFFFFFB518	60001809		 	sb		r0,Uart_rxrts		; no RTS/CTS signals available
FFFFFFFFFFFFB51C	60001812		 	sb		r0,Uart_txrts		; no RTS/CTS signals available
FFFFFFFFFFFFB520	60001813		 	sb		r0,Uart_txdtr		; no DTR signals available
FFFFFFFFFFFFB524	6000180A		 	sb		r0,Uart_rxdtr		; no DTR signals available
FFFFFFFFFFFFB528	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB52C	60009814		 	sb		r1,Uart_txxon		; for now
FFFFFFFFFFFFB530	37EF8000		 	ret
                  	           		 
                  	           		 ;---------------------------------------------------------------------------------
                  	           		 ; Get character directly from serial port. Blocks until a character is available.
                  	           		 ;---------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB534	           		 SerialGetCharDirect:
FFFFFFFFFFFFB534	           		 sgc1:
FFFFFFFFFFFFB534	E69C0A01		; SETLO
FFFFFFFFFFFFB538	EE800003		; SETMID
FFFFFFFFFFFFB53C	6A0D0420		 	inb		r1,UART_LS		; uart status
FFFFFFFFFFFFB540	14108001		 	andi	r1,r1,#rxfull	; is there a char available ?
FFFFFFFFFFFFB544	BE107F88		 	beq		r1,r0,sgc1
FFFFFFFFFFFFB548	E69C0A00		; SETLO
FFFFFFFFFFFFB54C	EE800003		; SETMID
FFFFFFFFFFFFB550	6A0D0420		 	inb		r1,UART
FFFFFFFFFFFFB554	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------
                  	           		 ; Check for a character at the serial port
                  	           		 ; returns r1 = 1 if char available, 0 otherwise
                  	           		 ;------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB558	           		 SerialCheckForCharDirect:
FFFFFFFFFFFFB558	E69C0A01		; SETLO
FFFFFFFFFFFFB55C	EE800003		; SETMID
FFFFFFFFFFFFB560	6A0D0420		 	inb		r1,UART_LS		; uart status
FFFFFFFFFFFFB564	14108001		 	andi	r1,r1,#rxfull	; is there a char available ?
FFFFFFFFFFFFB568	04100439		 	sne		r1,r1,r0
FFFFFFFFFFFFB56C	37EF8000		 	ret
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Put character to serial port
                  	           		 ; r1 = char to put
                  	           		 ;-----------------------------------------
                  	           		 ;
FFFFFFFFFFFFB570	           		 SerialPutChar:
FFFFFFFFFFFFB570	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFB574	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFB578	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFB57C	67E20010		 	sw		r4,16[sp]
FFFFFFFFFFFFB580	67E28018		 	sw		r5,24[sp]
FFFFFFFFFFFFB584	E69C0A06		; SETLO
FFFFFFFFFFFFB588	EE800003		; SETMID
FFFFFFFFFFFFB58C	6A0D0820		 	inb		r2,UART_MC
FFFFFFFFFFFFB590	16210003		 	ori		r2,r2,#3		; assert DTR / RTS
FFFFFFFFFFFFB594	E69C0A06		; SETLO
FFFFFFFFFFFFB598	EE800003		; SETMID
FFFFFFFFFFFFB59C	6A0D0828		 	outb	r2,UART_MC
FFFFFFFFFFFFB5A0	40011812		 	lb		r2,Uart_txrts
FFFFFFFFFFFFB5A4	BE200168		 	beq		r2,r0,spcb1
FFFFFFFFFFFFB5A8	46021400		 	lw		r4,Milliseconds
FFFFFFFFFFFFB5AC	E0C00064		 	setlo	r3,#100			; delay count (1 s)
FFFFFFFFFFFFB5B0	           		 spcb3:
FFFFFFFFFFFFB5B0	80011808		 	inb		r2,UART_MS
FFFFFFFFFFFFB5B4	1421000A		 	andi	r2,r2,#10		; is CTS asserted ?
FFFFFFFFFFFFB5B8	BE2000C9		 	bne		r2,r0,spcb1
FFFFFFFFFFFFB5BC	46029400		 	lw		r5,Milliseconds
FFFFFFFFFFFFB5C0	BE42FF88		 	beq		r4,r5,spcb3
FFFFFFFFFFFFB5C4	02520009		 	mov		r4,r5
FFFFFFFFFFFFB5C8	BE01FF4F		 	loop	r3,spcb3
FFFFFFFFFFFFB5CC	BE00046A		 	bra		spcabort
FFFFFFFFFFFFB5D0	           		 spcb1:
FFFFFFFFFFFFB5D0	40011813		 	lb		r2,Uart_txdtr
FFFFFFFFFFFFB5D4	BE200168		 	beq		r2,r0,spcb2
FFFFFFFFFFFFB5D8	46021400		 	lw		r4,Milliseconds
FFFFFFFFFFFFB5DC	E0C00064		 	setlo	r3,#100			; delay count
FFFFFFFFFFFFB5E0	           		 spcb4:
FFFFFFFFFFFFB5E0	80011808		 	inb		r2,UART_MS
FFFFFFFFFFFFB5E4	14210014		 	andi	r2,r2,#20		; is DSR asserted ?
FFFFFFFFFFFFB5E8	BE2000C9		 	bne		r2,r0,spcb2
FFFFFFFFFFFFB5EC	46029400		 	lw		r5,Milliseconds
FFFFFFFFFFFFB5F0	BE42FF88		 	beq		r4,r5,spcb4
FFFFFFFFFFFFB5F4	02520009		 	mov		r4,r5
FFFFFFFFFFFFB5F8	BE01FF4F		 	loop	r3,spcb4
FFFFFFFFFFFFB5FC	BE0002EA		 	bra		spcabort
FFFFFFFFFFFFB600	           		 spcb2:	
FFFFFFFFFFFFB600	40011814		 	lb		r2,Uart_txxon
FFFFFFFFFFFFB604	BE2000C8		 	beq		r2,r0,spcb5
FFFFFFFFFFFFB608	           		 spcb6:
FFFFFFFFFFFFB608	40011815		 	lb		r2,Uart_txxonoff
FFFFFFFFFFFFB60C	BE200088		 	beq		r2,r0,spcb5
FFFFFFFFFFFFB610	80021808		 	inb		r4,UART_MS
FFFFFFFFFFFFB614	14420080		 	andi	r4,r4,#0x80			; DCD ?
FFFFFFFFFFFFB618	BE407F89		 	bne		r4,r0,spcb6
FFFFFFFFFFFFB61C	           		 spcb5:
FFFFFFFFFFFFB61C	46021400		 	lw		r4,Milliseconds
FFFFFFFFFFFFB620	E0C00064		 	setlo	r3,#100				; wait up to 1s
FFFFFFFFFFFFB624	           		 spcb8:
FFFFFFFFFFFFB624	E69C0A01		; SETLO
FFFFFFFFFFFFB628	EE800003		; SETMID
FFFFFFFFFFFFB62C	6A0D0820		 	inb		r2,UART_LS
FFFFFFFFFFFFB630	14210020		 	andi	r2,r2,#0x20			; tx not full ?
FFFFFFFFFFFFB634	BE2000C9		 	bne		r2,r0,spcb7
FFFFFFFFFFFFB638	46029400		 	lw		r5,Milliseconds
FFFFFFFFFFFFB63C	BE42FF48		 	beq		r4,r5,spcb8
FFFFFFFFFFFFB640	02520009		 	mov		r4,r5
FFFFFFFFFFFFB644	BE01FF0F		 	loop	r3,spcb8
FFFFFFFFFFFFB648	BE00008A		 	bra		spcabort
FFFFFFFFFFFFB64C	           		 spcb7:
FFFFFFFFFFFFB64C	E69C0A00		; SETLO
FFFFFFFFFFFFB650	EE800003		; SETMID
FFFFFFFFFFFFB654	6A0D0428		 	outb	r1,UART
FFFFFFFFFFFFB658	           		 spcabort:
FFFFFFFFFFFFB658	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB65C	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFB660	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFB664	47E28018		 	lw		r5,24[sp]
FFFFFFFFFFFFB668	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;-------------------------------------------------
                  	           		 ; Compute number of characters in recieve buffer.
                  	           		 ; r4 = number of chars
                  	           		 ;-------------------------------------------------
FFFFFFFFFFFFB66C	           		 CharsInRxBuf:
FFFFFFFFFFFFB66C	42021800		 	lc		r4,Uart_rxhead
FFFFFFFFFFFFB670	42011802		 	lc		r2,Uart_rxtail
FFFFFFFFFFFFB674	04411005		 	subu	r4,r4,r2
FFFFFFFFFFFFB678	BE4000A3		 	bgt		r4,r0,cirxb1
FFFFFFFFFFFFB67C	E1000200		 	setlo	r4,#0x200
FFFFFFFFFFFFB680	04411003		 	addu	r4,r4,r2
FFFFFFFFFFFFB684	42011800		 	lc		r2,Uart_rxhead
FFFFFFFFFFFFB688	04411005		 	subu	r4,r4,r2
FFFFFFFFFFFFB68C	           		 cirxb1:
FFFFFFFFFFFFB68C	37EF8000		 	ret
                  	           		 
                  	           		 ;----------------------------------------------
                  	           		 ; Get character from rx fifo
                  	           		 ; If the fifo is empty enough then send an XON
                  	           		 ;----------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB690	           		 SerialGetChar:
FFFFFFFFFFFFB690	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFB694	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFB698	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFB69C	67E20010		 	sw		r4,16[sp]
FFFFFFFFFFFFB6A0	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFB6A4	42019800		 	lc		r3,Uart_rxhead
FFFFFFFFFFFFB6A8	42011802		 	lc		r2,Uart_rxtail
FFFFFFFFFFFFB6AC	BE218528		 	beq		r2,r3,sgcfifo1	; is there a char available ?
FFFFFFFFFFFFB6B0	9A019600		 	lea		r3,Uart_rxfifo
FFFFFFFFFFFFB6B4	6A218400		 	lb		r1,[r2+r3]		; get the char from the fifo into r1
FFFFFFFFFFFFB6B8	0A210001		 	addui	r2,r2,#1		; increment the fifo pointer
FFFFFFFFFFFFB6BC	142101FF		 	andi	r2,r2,#0x1ff
FFFFFFFFFFFFB6C0	62011802		 	sc		r2,Uart_rxtail
FFFFFFFFFFFFB6C4	4001180C		 	lb		r2,Uart_rxflow	; using flow control ?
FFFFFFFFFFFFB6C8	BE2003A8		 	beq		r2,r0,sgcfifo2
FFFFFFFFFFFFB6CC	4201980E		 	lc		r3,Uart_fon		; enough space in Rx buffer ?
FFFFFFFFFFFFB6D0	31FFED9B		 	call	CharsInRxBuf
FFFFFFFFFFFFB6D4	BE418343		 	bgt		r4,r3,sgcfifo2
FFFFFFFFFFFFB6D8	6000180C		 	sb		r0,Uart_rxflow	; flow off
FFFFFFFFFFFFB6DC	40021809		 	lb		r4,Uart_rxrts
FFFFFFFFFFFFB6E0	BE400108		 	beq		r4,r0,sgcfifo3
FFFFFFFFFFFFB6E4	E69C0A06		; SETLO
FFFFFFFFFFFFB6E8	EE800003		; SETMID
FFFFFFFFFFFFB6EC	6A0D1020		 	inb		r4,UART_MC		; set rts bit in MC
FFFFFFFFFFFFB6F0	16420002		 	ori		r4,r4,#2
FFFFFFFFFFFFB6F4	E69C0A06		; SETLO
FFFFFFFFFFFFB6F8	EE800003		; SETMID
FFFFFFFFFFFFB6FC	6A0D1028		 	outb	r4,UART_MC
FFFFFFFFFFFFB700	           		 sgcfifo3:
FFFFFFFFFFFFB700	4002180A		 	lb		r4,Uart_rxdtr
FFFFFFFFFFFFB704	BE400108		 	beq		r4,r0,sgcfifo4
FFFFFFFFFFFFB708	E69C0A06		; SETLO
FFFFFFFFFFFFB70C	EE800003		; SETMID
FFFFFFFFFFFFB710	6A0D1020		 	inb		r4,UART_MC		; set DTR
FFFFFFFFFFFFB714	16420001		 	ori		r4,r4,#1
FFFFFFFFFFFFB718	E69C0A06		; SETLO
FFFFFFFFFFFFB71C	EE800003		; SETMID
FFFFFFFFFFFFB720	6A0D1028		 	outb	r4,UART_MC
FFFFFFFFFFFFB724	           		 sgcfifo4:
FFFFFFFFFFFFB724	4002180B		 	lb		r4,Uart_rxxon
FFFFFFFFFFFFB728	BE4000A8		 	beq		r4,r0,sgcfifo5
FFFFFFFFFFFFB72C	E1000011		 	setlo	r4,#XON
FFFFFFFFFFFFB730	E69C0A00		; SETLO
FFFFFFFFFFFFB734	EE800003		; SETMID
FFFFFFFFFFFFB738	6A0D1028		 	outb	r4,UART
FFFFFFFFFFFFB73C	           		 sgcfifo5:
FFFFFFFFFFFFB73C	           		 sgcfifo2:					; return with char in r1
FFFFFFFFFFFFB73C	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB740	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFB744	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFB748	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFB74C	37EF8020		 	ret		#32
FFFFFFFFFFFFB750	           		 sgcfifo1:
FFFFFFFFFFFFB750	E07FFFFF		 	setlo	r1,#-1			; no char available
FFFFFFFFFFFFB754	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB758	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFB75C	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFB760	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFB764	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Serial port IRQ
                  	           		 ;-----------------------------------------
                  	           		 ;
FFFFFFFFFFFFB768	           		 SerialIRQ:
FFFFFFFFFFFFB768	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFB76C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFB770	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFB774	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFB778	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFB77C	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFB780	E69C0A03		; SETLO
FFFFFFFFFFFFB784	EE800003		; SETMID
FFFFFFFFFFFFB788	6A0D0420		 	inb		r1,UART_IS		; get interrupt status
FFFFFFFFFFFFB78C	BE1000A1		 	bge		r1,r0,sirq1
FFFFFFFFFFFFB790	1410807F		 	andi	r1,r1,#0x7f		; switch on interrupt type
FFFFFFFFFFFFB794	B0100D04		 	beqi	r1,#4,srxirq
FFFFFFFFFFFFB798	B0100B0C		 	beqi	r1,#0xC,stxirq
FFFFFFFFFFFFB79C	B0100710		 	beqi	r1,#0x10,smsirq
FFFFFFFFFFFFB7A0	           		 sirq1:
FFFFFFFFFFFFB7A0	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFB7A4	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFB7A8	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFB7AC	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFB7B0	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFB7B4	37EF8028		 	ret		#40
                  	           		 
                  	           		 ; Get the modem status and record it
FFFFFFFFFFFFB7B8	           		 smsirq:
FFFFFFFFFFFFB7B8	80009808		 	inb		r1,UART_MS
FFFFFFFFFFFFB7BC	60009808		 	sb		r1,Uart_ms
FFFFFFFFFFFFB7C0	BE007F0A		 	bra		sirq1
                  	           		 
FFFFFFFFFFFFB7C4	           		 stxirq:
FFFFFFFFFFFFB7C4	BE007EEA		 	bra		sirq1
                  	           		 
                  	           		 ; Get a character from the uart and store it in the rx fifo
FFFFFFFFFFFFB7C8	           		 srxirq:
FFFFFFFFFFFFB7C8	           		 srxirq1:
FFFFFFFFFFFFB7C8	E69C0A00		; SETLO
FFFFFFFFFFFFB7CC	EE800003		; SETMID
FFFFFFFFFFFFB7D0	6A0D0420		 	inb		r1,UART				; get the char (clears interrupt)
FFFFFFFFFFFFB7D4	40011814		 	lb		r2,Uart_txxon
FFFFFFFFFFFFB7D8	BE200108		 	beq		r2,r0,srxirq3
FFFFFFFFFFFFB7DC	B2100413		 	bnei	r1,#XOFF,srxirq2
FFFFFFFFFFFFB7E0	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB7E4	60009815		 	sb		r1,Uart_txxonoff
FFFFFFFFFFFFB7E8	BE00016A		 	bra		srxirq5
FFFFFFFFFFFFB7EC	           		 srxirq2:
FFFFFFFFFFFFB7EC	B2100311		 	bnei	r1,#XON,srxirq3
FFFFFFFFFFFFB7F0	60001815		 	sb		r0,Uart_txxonoff
FFFFFFFFFFFFB7F4	BE00010A		 	bra		srxirq5
FFFFFFFFFFFFB7F8	           		 srxirq3:
FFFFFFFFFFFFB7F8	60001815		 	sb		r0,Uart_txxonoff
FFFFFFFFFFFFB7FC	42011800		 	lc		r2,Uart_rxhead
FFFFFFFFFFFFB800	9A019600		 	lea		r3,Uart_rxfifo
FFFFFFFFFFFFB804	6A310410		 	sb		r1,[r3+r2]			; store in buffer
FFFFFFFFFFFFB808	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFB80C	142101FF		 	andi	r2,r2,#0x1ff
FFFFFFFFFFFFB810	62011800		 	sc		r2,Uart_rxhead
FFFFFFFFFFFFB814	           		 srxirq5:
FFFFFFFFFFFFB814	E69C0A01		; SETLO
FFFFFFFFFFFFB818	EE800003		; SETMID
FFFFFFFFFFFFB81C	6A0D0420		 	inb		r1,UART_LS			; check for another ready character
FFFFFFFFFFFFB820	14108001		 	andi	r1,r1,#rxfull
FFFFFFFFFFFFB824	BE107D29		 	bne		r1,r0,srxirq1
FFFFFFFFFFFFB828	4000980C		 	lb		r1,Uart_rxflow		; are we using flow controls?
FFFFFFFFFFFFB82C	BE1003C9		 	bne		r1,r0,srxirq8
FFFFFFFFFFFFB830	31FFED9B		 	call	CharsInRxBuf
FFFFFFFFFFFFB834	42009810		 	lc		r1,Uart_foff
FFFFFFFFFFFFB838	BE408360		 	blt		r4,r1,srxirq8
FFFFFFFFFFFFB83C	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB840	6000980C		 	sb		r1,Uart_rxflow
FFFFFFFFFFFFB844	40009809		 	lb		r1,Uart_rxrts
FFFFFFFFFFFFB848	BE100108		 	beq		r1,r0,srxirq6
FFFFFFFFFFFFB84C	E69C0A06		; SETLO
FFFFFFFFFFFFB850	EE800003		; SETMID
FFFFFFFFFFFFB854	6A0D0420		 	inb		r1,UART_MC
FFFFFFFFFFFFB858	141080FD		 	andi	r1,r1,#0xFD		; turn off RTS
FFFFFFFFFFFFB85C	E69C0A06		; SETLO
FFFFFFFFFFFFB860	EE800003		; SETMID
FFFFFFFFFFFFB864	6A0D0428		 	outb	r1,UART_MC
FFFFFFFFFFFFB868	           		 srxirq6:
FFFFFFFFFFFFB868	4000980A		 	lb		r1,Uart_rxdtr
FFFFFFFFFFFFB86C	BE100108		 	beq		r1,r0,srxirq7
FFFFFFFFFFFFB870	E69C0A06		; SETLO
FFFFFFFFFFFFB874	EE800003		; SETMID
FFFFFFFFFFFFB878	6A0D0420		 	inb		r1,UART_MC
FFFFFFFFFFFFB87C	141080FE		 	andi	r1,r1,#0xFE		; turn off DTR
FFFFFFFFFFFFB880	E69C0A06		; SETLO
FFFFFFFFFFFFB884	EE800003		; SETMID
FFFFFFFFFFFFB888	6A0D0428		 	outb	r1,UART_MC
FFFFFFFFFFFFB88C	           		 srxirq7:
FFFFFFFFFFFFB88C	4000980B		 	lb		r1,Uart_rxxon
FFFFFFFFFFFFB890	BE1000A8		 	beq		r1,r0,srxirq8
FFFFFFFFFFFFB894	E0400013		 	setlo	r1,#XOFF
FFFFFFFFFFFFB898	E69C0A00		; SETLO
FFFFFFFFFFFFB89C	EE800003		; SETMID
FFFFFFFFFFFFB8A0	6A0D0428		 	outb	r1,UART
FFFFFFFFFFFFB8A4	           		 srxirq8:
FFFFFFFFFFFFB8A4	BE0077EA		 	bra		sirq1
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Video BIOS
                  	           		 ; Video interrupt #410
                  	           		 ;
                  	           		 ; Function in R1
                  	           		 ; 0x02 = Set Cursor Position	r2 = row, r3 = col 
                  	           		 ; 0x03 = Get Cursor position	returns r1 = row, r2 = col
                  	           		 ; 0x06 = Scroll screen up
                  	           		 ; 0x09 = Display character+attribute, r2=char, r3=attrib, r4=#times
                  	           		 ; 0x0A = Display character, r2 = char, r3 = # times
                  	           		 ; 0x0C = Display Pixel r2 = x, r3 = y, r4 = color
                  	           		 ; 0x0D = Get pixel  r2 = x, r3 = y
                  	           		 ; 0x14 = Display String	r2 = pointer to string
                  	           		 ; 0x15 = Display number r2 = number, r3 = # digits
                  	           		 ; 0x16 = Display String + CRLF   r2 = pointer to string
                  	           		 ; 0x17 = Display Word r2 as hex = word
                  	           		 ; 0x18 = Display Half word as hex r2 = half word
                  	           		 ; 0x19 = Display Charr char in hex r2 = char
                  	           		 ; 0x1A = Display Byte in hex r2 = byte
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFB8A8	           		 VideoSC:
FFFFFFFFFFFFB8A8	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFB8AC	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFB8B0	67AF2200		 	sw		sp,sp_saves[r26]	; save sp in save area
FFFFFFFFFFFFB8B4	07AD1006		 	shlui	r26,r26,#8			; 2k for stack
FFFFFFFFFFFFB8B8	03AF0009		 	mov		sp,r26
FFFFFFFFFFFFB8BC	E6808000		; SETLO
FFFFFFFFFFFFB8C0	EE800400		; SETMID
FFFFFFFFFFFFB8C4	05ED7803		 	addui	sp,sp,#0x100008000	; base stacks address
FFFFFFFFFFFFB8C8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFB8CC	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFB8D0	           		 Video1:
FFFFFFFFFFFFB8D0	020F80B4		 	omgi	lr,#VIDEOGATE
FFFFFFFFFFFFB8D4	BFF07FE9		 	bne		lr,r0,Video1
FFFFFFFFFFFFB8D8	B0100D02		 	beqi	r1,#0x02,Video_x02
FFFFFFFFFFFFB8DC	B0101003		 	beqi	r1,#0x03,Video_x03
FFFFFFFFFFFFB8E0	B0101206		 	beqi	r1,#0x06,Video_x06
FFFFFFFFFFFFB8E4	B0101309		 	beqi	r1,#0x09,Video_x09
FFFFFFFFFFFFB8E8	B010170A		 	beqi	r1,#0x0A,Video_x0A
FFFFFFFFFFFFB8EC	B0101A0C		 	beqi	r1,#0x0C,Video_x0C
FFFFFFFFFFFFB8F0	B010270C		 	beqi	r1,#0x0C,Video_x0D
FFFFFFFFFFFFB8F4	B0103B14		 	beqi	r1,#0x14,Video_x14
FFFFFFFFFFFFB8F8	B0103D15		 	beqi	r1,#0x15,Video_x15
FFFFFFFFFFFFB8FC	B0104016		 	beqi	r1,#0x16,Video_x16
FFFFFFFFFFFFB900	B0104217		 	beqi	r1,#0x17,Video_x17
FFFFFFFFFFFFB904	B010441A		 	beqi	r1,#0x1A,Video_x1A
FFFFFFFFFFFFB908	BE0008CA		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB90C	           		 Video_x02:
FFFFFFFFFFFFB90C	60011417		 	sb		r2,CursorRow
FFFFFFFFFFFFB910	60019418		 	sb		r3,CursorCol
FFFFFFFFFFFFB914	31FFF06F		 	call	CalcScreenLoc
FFFFFFFFFFFFB918	BE00084A		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB91C	           		 Video_x03:
FFFFFFFFFFFFB91C	4A009417		 	lbu		r1,CursorRow
FFFFFFFFFFFFB920	4A011418		 	lbu		r2,CursorCol
FFFFFFFFFFFFB924	BE0007EA		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB928	           		 Video_x06:
FFFFFFFFFFFFB928	31FFF02E		 	call	ScrollUp
FFFFFFFFFFFFB92C	BE0007AA		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB930	           		 Video_x09:
FFFFFFFFFFFFB930	62019410		 	sc		r3,CharColor
FFFFFFFFFFFFB934	02208009		 	mov		r1,r2
FFFFFFFFFFFFB938	           		 Video_x09a:
FFFFFFFFFFFFB938	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFB93C	BE027FEF		 	loop	r4,Video_x09a
FFFFFFFFFFFFB940	BE00070A		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB944	           		 Video_x0A:
FFFFFFFFFFFFB944	02208009		 	mov		r1,r2
FFFFFFFFFFFFB948	           		 Video_x0Aa:
FFFFFFFFFFFFB948	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFB94C	BE01FFEF		 	loop	r3,Video_x0Aa
FFFFFFFFFFFFB950	BE00068A		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB954	           		 Video_x0C:
FFFFFFFFFFFFB954	E69AE008		; SETLO
FFFFFFFFFFFFB958	EE800003		; SETMID
FFFFFFFFFFFFB95C	6A0D0812		 	sh		r2,GACCEL+8		; x0
FFFFFFFFFFFFB960	E69AE00C		; SETLO
FFFFFFFFFFFFB964	EE800003		; SETMID
FFFFFFFFFFFFB968	6A0D0C12		 	sh		r3,GACCEL+12	; y0
FFFFFFFFFFFFB96C	E69AE000		; SETLO
FFFFFFFFFFFFB970	EE800003		; SETMID
FFFFFFFFFFFFB974	6A0D1012		 	sh		r4,GACCEL+0		; color
FFFFFFFFFFFFB978	16008001		 	lw		r1,#1
FFFFFFFFFFFFB97C	E69AE03C		; SETLO
FFFFFFFFFFFFB980	EE800003		; SETMID
FFFFFFFFFFFFB984	6A0D0412		 	sh		r1,GACCEL+60	; DRAW PIXEL command
FFFFFFFFFFFFB988	BE0004CA		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB98C	           		 Video_x0D:
FFFFFFFFFFFFB98C	E69AE008		; SETLO
FFFFFFFFFFFFB990	EE800003		; SETMID
FFFFFFFFFFFFB994	6A0D0812		 	sh		r2,GACCEL+8		; x0
FFFFFFFFFFFFB998	E69AE00C		; SETLO
FFFFFFFFFFFFB99C	EE800003		; SETMID
FFFFFFFFFFFFB9A0	6A0D0C12		 	sh		r3,GACCEL+12	; y0
FFFFFFFFFFFFB9A4	16008008		 	lw		r1,#8
FFFFFFFFFFFFB9A8	E69AE03C		; SETLO
FFFFFFFFFFFFB9AC	EE800003		; SETMID
FFFFFFFFFFFFB9B0	6A0D0412		 	sh		r1,GACCEL+60	; GET PIXEL command
FFFFFFFFFFFFB9B4	DE000000		 	nop						; let command start
FFFFFFFFFFFFB9B8	DE000000		 	nop
FFFFFFFFFFFFB9BC	DE000000		 	nop
FFFFFFFFFFFFB9C0	           		 vxd1:
FFFFFFFFFFFFB9C0	E69AE038		; SETLO
FFFFFFFFFFFFB9C4	EE800003		; SETMID
FFFFFFFFFFFFB9C8	6A0D0407		 	lhu		r1,GACCEL+56	; wait for state = IDLE
FFFFFFFFFFFFB9CC	BE107FA9		 	bne		r1,r0,vxd1
FFFFFFFFFFFFB9D0	E69AE034		; SETLO
FFFFFFFFFFFFB9D4	EE800003		; SETMID
FFFFFFFFFFFFB9D8	6A0D0407		 	lhu		r1,GACCEL+52
FFFFFFFFFFFFB9DC	BE00022A		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB9E0	           		 Video_x14:
FFFFFFFFFFFFB9E0	02208009		 	mov		r1,r2
FFFFFFFFFFFFB9E4	31FFF122		 	call	DisplayString
FFFFFFFFFFFFB9E8	BE0001CA		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB9EC	           		 Video_x15:
FFFFFFFFFFFFB9EC	02208009		 	mov		r1,r2
FFFFFFFFFFFFB9F0	02310009		 	mov		r2,r3
FFFFFFFFFFFFB9F4	31FFF13F		 	call	DisplayNum
FFFFFFFFFFFFB9F8	BE00014A		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFB9FC	           		 Video_x16:
FFFFFFFFFFFFB9FC	02208009		 	mov		r1,r2
FFFFFFFFFFFFBA00	31FFF130		 	call	DisplayStringCRLF
FFFFFFFFFFFFBA04	BE0000EA		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFBA08	           		 Video_x17:
FFFFFFFFFFFFBA08	02208009		 	mov		r1,r2
FFFFFFFFFFFFBA0C	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFBA10	BE00008A		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFBA14	           		 Video_x1A:
FFFFFFFFFFFFBA14	02208009		 	mov		r1,r2
FFFFFFFFFFFFBA18	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFBA1C	BE00002A		 	bra		VideoRet
                  	           		 
FFFFFFFFFFFFBA20	           		 VideoRet:
FFFFFFFFFFFFBA20	020000B5		 	cmgi	#VIDEOGATE
FFFFFFFFFFFFBA24	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFBA28	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFBA2C	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFBA30	47AF2200		 	lw		sp,sp_saves[r26]	; get back the stack
FFFFFFFFFFFFBA34	01800021		 	eret
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; BIOS interrupt #413
                  	           		 ; 0x00  initialize
                  	           		 ; 0x01	read sector		r2 = sector #, r3 = pointer to buffer
                  	           		 ; 0x02	write sector
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFBA38	           		 SDCARDSC:
FFFFFFFFFFFFBA38	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFBA3C	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFBA40	67AF2200		 	sw		sp,sp_saves[r26]	; save sp in save area
FFFFFFFFFFFFBA44	07AD1006		 	shlui	r26,r26,#8			; 2k for stack
FFFFFFFFFFFFBA48	03AF0009		 	mov		sp,r26
FFFFFFFFFFFFBA4C	E6808000		; SETLO
FFFFFFFFFFFFBA50	EE800400		; SETMID
FFFFFFFFFFFFBA54	05ED7803		 	addui	sp,sp,#0x100008000	; base stacks address
FFFFFFFFFFFFBA58	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFBA5C	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFBA60	           		 SDC_1:
FFFFFFFFFFFFBA60	020F80F4		 	omgi	lr,#CARDGATE
FFFFFFFFFFFFBA64	BFF07FE9		 	bne		lr,r0,SDC_1
FFFFFFFFFFFFBA68	B0100400		 	beqi	r1,#0,SDC_x00
FFFFFFFFFFFFBA6C	B0100501		 	beqi	r1,#1,SDC_x01
FFFFFFFFFFFFBA70	B0100802		 	beqi	r1,#2,SDC_x02
FFFFFFFFFFFFBA74	BE0000EA		 	bra		SDCRet
FFFFFFFFFFFFBA78	           		 SDC_x00:
FFFFFFFFFFFFBA78	31FFF54E		 	call	spi_init
FFFFFFFFFFFFBA7C	BE0000AA		 	bra		SDCRet
FFFFFFFFFFFFBA80	           		 SDC_x01:
FFFFFFFFFFFFBA80	02208009		 	mov		r1,r2
FFFFFFFFFFFFBA84	02310009		 	mov		r2,r3
FFFFFFFFFFFFBA88	31FFF56D		 	call	spi_read_sector
FFFFFFFFFFFFBA8C	BE00002A		 	bra		SDCRet
FFFFFFFFFFFFBA90	           		 SDC_x02:
FFFFFFFFFFFFBA90	           		 SDCRet:
FFFFFFFFFFFFBA90	020000F5		 	cmgi	#CARDGATE
FFFFFFFFFFFFBA94	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFBA98	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFBA9C	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFBAA0	47AF2200		 	lw		sp,sp_saves[r26]	; get back the stack
FFFFFFFFFFFFBAA4	01800021		 	eret
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Real time clock BIOS
                  	           		 ; BIOS interrupt #416
                  	           		 ;
                  	           		 ; Function
                  	           		 ; 0x00 = get system tick
                  	           		 ; 0x01 = get date/time
                  	           		 ; 0x02 = set date/time
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFBAA8	           		 RTCSC:
FFFFFFFFFFFFBAA8	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFBAAC	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFBAB0	67AF2200		 	sw		sp,sp_saves[r26]	; save sp in save area
FFFFFFFFFFFFBAB4	07AD1006		 	shlui	r26,r26,#8			; 2k for stack
FFFFFFFFFFFFBAB8	03AF0009		 	mov		sp,r26
FFFFFFFFFFFFBABC	E6808000		; SETLO
FFFFFFFFFFFFBAC0	EE800400		; SETMID
FFFFFFFFFFFFBAC4	05ED7803		 	addui	sp,sp,#0x100008000	; base stacks address
FFFFFFFFFFFFBAC8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFBACC	67EF8000		 	sw		lr,[sp]
                  	           		 	;
FFFFFFFFFFFFBAD0	B0100200		 	beqi	r1,#0x00,RTC_x00
FFFFFFFFFFFFBAD4	B0100301		 	beqi	r1,#0x01,RTC_x01
FFFFFFFFFFFFBAD8	           		 RTC_x00:
FFFFFFFFFFFFBAD8	020085A8		 	mfspr	r1,TICK
FFFFFFFFFFFFBADC	BE00012A		 	bra		RTCRet
FFFFFFFFFFFFBAE0	           		 RTC_x01:
FFFFFFFFFFFFBAE0	E69C0418		; SETLO
FFFFFFFFFFFFBAE4	EE800003		; SETMID
FFFFFFFFFFFFBAE8	6A0D002B		 	outw	r0,DATETIME+24		; trigger a snapshot
FFFFFFFFFFFFBAEC	DE000000		 	nop
FFFFFFFFFFFFBAF0	E69C0400		; SETLO
FFFFFFFFFFFFBAF4	EE800003		; SETMID
FFFFFFFFFFFFBAF8	6A0D0423		 	inw		r1,DATETIME			; get the snapshotted date and time
FFFFFFFFFFFFBAFC	BE00002A		 	bra		RTCRet
FFFFFFFFFFFFBB00	           		 RTCRet:
FFFFFFFFFFFFBB00	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFBB04	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFBB08	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFBB0C	47AF2200		 	lw		sp,sp_saves[r26]	; get back the stack
FFFFFFFFFFFFBB10	01800021		 	eret
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Keyboard BIOS
                  	           		 ; BIOS interrupt #417
                  	           		 ;
                  	           		 ; Function in R1
                  	           		 ; 0x00 = initialize keyboard
                  	           		 ; 0x01 = set keyboard echo
                  	           		 ; 0x02 = get keyboard character from buffer
                  	           		 ; 0x03 = check for key available in buffer
                  	           		 ; 0x04 = check for key directly at keyboard port
                  	           		 ; 0x05 = get keyboard character directly from keyboard port (blocks)
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFBB14	           		 KeybdSC:
FFFFFFFFFFFFBB14	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFBB18	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFBB1C	67AF2200		 	sw		sp,sp_saves[r26]	; save sp in save area
FFFFFFFFFFFFBB20	07AD1006		 	shlui	r26,r26,#8			; 2k for stack
FFFFFFFFFFFFBB24	03AF0009		 	mov		sp,r26
FFFFFFFFFFFFBB28	E6808000		; SETLO
FFFFFFFFFFFFBB2C	EE800400		; SETMID
FFFFFFFFFFFFBB30	05ED7803		 	addui	sp,sp,#0x100008000	; base stacks address
FFFFFFFFFFFFBB34	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFBB38	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFBB3C	           		 kbdsc5:
FFFFFFFFFFFFBB3C	020F8074		 	omgi	lr,#KEYBDGATE
FFFFFFFFFFFFBB40	BFF07FE9		 	bne		lr,r0,kbdsc5
FFFFFFFFFFFFBB44	B0100700		 	beqi	r1,#0,kbd_x00
FFFFFFFFFFFFBB48	B0100801		 	beqi	r1,#1,kbd_x01
FFFFFFFFFFFFBB4C	B0100A02		 	beqi	r1,#2,kbd_x02
FFFFFFFFFFFFBB50	B0100B03		 	beqi	r1,#3,kbd_x03
FFFFFFFFFFFFBB54	B0100C04		 	beqi	r1,#4,kbd_x04
FFFFFFFFFFFFBB58	B0100D05		 	beqi	r1,#5,kbd_x05
FFFFFFFFFFFFBB5C	BE0001CA		 	bra		kbdscRet
FFFFFFFFFFFFBB60	           		 kbd_x00:
FFFFFFFFFFFFBB60	31FFEEEB		 	call	KeybdInit
FFFFFFFFFFFFBB64	BE00018A		 	bra		kbdscRet
FFFFFFFFFFFFBB68	           		 kbd_x01:
FFFFFFFFFFFFBB68	02208009		 	mov		r1,r2
FFFFFFFFFFFFBB6C	31FFEF05		 	call	SetKeyboardEcho
FFFFFFFFFFFFBB70	BE00012A		 	bra		kbdscRet
FFFFFFFFFFFFBB74	           		 kbd_x02:
FFFFFFFFFFFFBB74	31FFEF07		 	call	KeybdGetChar
FFFFFFFFFFFFBB78	BE0000EA		 	bra		kbdscRet
FFFFFFFFFFFFBB7C	           		 kbd_x03:
FFFFFFFFFFFFBB7C	31FFEF1C		 	call	KeybdCheckForKey
FFFFFFFFFFFFBB80	BE0000AA		 	bra		kbdscRet
FFFFFFFFFFFFBB84	           		 kbd_x04:
FFFFFFFFFFFFBB84	31FFEF20		 	call	KeybdCheckForKeyDirect
FFFFFFFFFFFFBB88	BE00006A		 	bra		kbdscRet
FFFFFFFFFFFFBB8C	           		 kbd_x05:
FFFFFFFFFFFFBB8C	31FFEF25		 	call	KeybdGetCharDirect
FFFFFFFFFFFFBB90	BE00002A		 	bra		kbdscRet
FFFFFFFFFFFFBB94	           		 kbdscRet:
FFFFFFFFFFFFBB94	02000075		 	cmgi	#KEYBDGATE
FFFFFFFFFFFFBB98	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFBB9C	020D0568		 	mfspr	r26,AXC				; get context
FFFFFFFFFFFFBBA0	07AD0606		 	shlui	r26,r26,#3			; *8
FFFFFFFFFFFFBBA4	47AF2200		 	lw		sp,sp_saves[r26]	; get back the stack
FFFFFFFFFFFFBBA8	01800021		 	eret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Initialize keyboard
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFBBAC	           		 KeybdInit:
FFFFFFFFFFFFBBAC	60001450		 	sb		r0,KeybdHead
FFFFFFFFFFFFBBB0	60001451		 	sb		r0,KeybdTail
FFFFFFFFFFFFBBB4	E0400001		 	setlo	r1,#1			; turn on keyboard echo
FFFFFFFFFFFFBBB8	6000941C		 	sb		r1,KeybdEcho
FFFFFFFFFFFFBBBC	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Normal keyboard interrupt, the lowest priority interrupt in the system.
                  	           		 ; Grab the character from the keyboard device and store it in a buffer.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBBC0	           		 KeybdIRQ:
FFFFFFFFFFFFBBC0	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFBBC4	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFBBC8	4A009450		 	lbu		r1,KeybdHead
FFFFFFFFFFFFBBCC	1410800F		 	andi	r1,r1,#0x0f				; r1 = index into buffer
FFFFFFFFFFFFBBD0	           		 KeybdIRQa:
FFFFFFFFFFFFBBD0	E69C0000		; SETLO
FFFFFFFFFFFFBBD4	EE800003		; SETMID
FFFFFFFFFFFFBBD8	6A0D0821		 	inch	r2,KEYBD				; get keyboard character
FFFFFFFFFFFFBBDC	E69C0002		; SETLO
FFFFFFFFFFFFBBE0	EE800003		; SETMID
FFFFFFFFFFFFBBE4	6A0D0029		 	outc	r0,KEYBD+2				; clear keyboard strobe (turns off the IRQ)
FFFFFFFFFFFFBBE8	60111440		 	sb		r2,KeybdBuffer[r1]		; store character in buffer
FFFFFFFFFFFFBBEC	0A108001		 	addui	r1,r1,#1				; increment head index
FFFFFFFFFFFFBBF0	1410800F		 	andi	r1,r1,#0x0f
FFFFFFFFFFFFBBF4	60009450		 	sb		r1,KeybdHead
FFFFFFFFFFFFBBF8	           		 KeybdIRQb:
FFFFFFFFFFFFBBF8	4A011451		 	lbu		r2,KeybdTail			; check to see if we've collided
FFFFFFFFFFFFBBFC	BE110089		 	bne		r1,r2,KeybdIRQc			; with the tail
FFFFFFFFFFFFBC00	0A210001		 	addui	r2,r2,#1				; if so, increment the tail index
FFFFFFFFFFFFBC04	1421000F		 	andi	r2,r2,#0x0f				; the oldest character will be lost
FFFFFFFFFFFFBC08	60011451		 	sb		r2,KeybdTail
FFFFFFFFFFFFBC0C	           		 KeybdIRQc:
FFFFFFFFFFFFBC0C	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFBC10	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; r1 0=echo off, non-zero = echo on
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFBC14	           		 SetKeyboardEcho:
FFFFFFFFFFFFBC14	6000941C		 	sb		r1,KeybdEcho
FFFFFFFFFFFFBC18	37EF8000		 	ret
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Get character from keyboard buffer
                  	           		 ;-----------------------------------------
FFFFFFFFFFFFBC1C	           		 KeybdGetChar:
FFFFFFFFFFFFBC1C	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFBC20	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFBC24	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFBC28	4A011451		 	lbu		r2,KeybdTail
FFFFFFFFFFFFBC2C	4A009450		 	lbu		r1,KeybdHead
FFFFFFFFFFFFBC30	BE110188		 	beq		r1,r2,nochar
FFFFFFFFFFFFBC34	4A209440		 	lbu		r1,KeybdBuffer[r2]
FFFFFFFFFFFFBC38	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFBC3C	1421000F		 	andi	r2,r2,#0x0f
FFFFFFFFFFFFBC40	60011451		 	sb		r2,KeybdTail
FFFFFFFFFFFFBC44	4001141C		 	lb		r2,KeybdEcho
FFFFFFFFFFFFBC48	BE2000E8		 	beq		r2,r0,kgc3
FFFFFFFFFFFFBC4C	B210030D		 	bnei	r1,#CR,kgc2
FFFFFFFFFFFFBC50	31FFFD80		 	call	CRLF			; convert CR keystroke into CRLF
FFFFFFFFFFFFBC54	BE00008A		 	bra		kgc3
FFFFFFFFFFFFBC58	           		 kgc2:
FFFFFFFFFFFFBC58	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFBC5C	BE00004A		 	bra		kgc3
FFFFFFFFFFFFBC60	           		 nochar:
FFFFFFFFFFFFBC60	E07FFFFF		 	setlo	r1,#-1
FFFFFFFFFFFFBC64	           		 kgc3:
FFFFFFFFFFFFBC64	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFBC68	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFBC6C	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Check if there is a keyboard character available in the keyboard buffer.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBC70	           		 KeybdCheckForKey:
FFFFFFFFFFFFBC70	4A009451		 	lbu		r1,KeybdTail
FFFFFFFFFFFFBC74	4A011450		 	lbu		r2,KeybdHead
FFFFFFFFFFFFBC78	04110439		 	sne		r1,r1,r2
FFFFFFFFFFFFBC7C	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Check if there is a keyboard character available. If so return true (1)
                  	           		 ; otherwise return false (0) in r1.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBC80	           		 KeybdCheckForKeyDirect:
FFFFFFFFFFFFBC80	E69C0000		; SETLO
FFFFFFFFFFFFBC84	EE800003		; SETMID
FFFFFFFFFFFFBC88	6A0D0421		 	inch	r1,KEYBD
FFFFFFFFFFFFBC8C	04100430		 	slt		r1,r1,r0
FFFFFFFFFFFFBC90	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Get character directly from keyboard. This routine blocks until a key is
                  	           		 ; available.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBC94	           		 KeybdGetCharDirect:
FFFFFFFFFFFFBC94	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFBC98	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFBC9C	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFBCA0	E09C0000		 	setlo	r2,KEYBD
FFFFFFFFFFFFBCA4	           		 kgc1:
FFFFFFFFFFFFBCA4	E69C0000		; SETLO
FFFFFFFFFFFFBCA8	EE800003		; SETMID
FFFFFFFFFFFFBCAC	6A0D0421		 	inch	r1,KEYBD
FFFFFFFFFFFFBCB0	BE107FA1		 	bge		r1,r0,kgc1
FFFFFFFFFFFFBCB4	E69C0002		; SETLO
FFFFFFFFFFFFBCB8	EE800003		; SETMID
FFFFFFFFFFFFBCBC	6A0D0029		 	outc	r0,KEYBD+2		; clear keyboard strobe
FFFFFFFFFFFFBCC0	141080FF		 	andi	r1,r1,#0xff		; remove strobe bit
FFFFFFFFFFFFBCC4	4001141C		 	lb		r2,KeybdEcho	; is keyboard echo on ?
FFFFFFFFFFFFBCC8	BE2000A8		 	beq		r2,r0,gk1
FFFFFFFFFFFFBCCC	B210030D		 	bnei	r1,#'\r',gk2	; convert CR keystroke into CRLF
FFFFFFFFFFFFBCD0	31FFFD80		 	call	CRLF
FFFFFFFFFFFFBCD4	BE00004A		 	bra		gk1
FFFFFFFFFFFFBCD8	           		 gk2:
FFFFFFFFFFFFBCD8	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFBCDC	           		 gk1:
FFFFFFFFFFFFBCDC	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFBCE0	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFBCE4	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
FFFFFFFFFFFFBCE8	           		 tmp_init:
                  	           		 	; wait for the rst1626 to go low
FFFFFFFFFFFFBCE8	E6989680		; SETLO
FFFFFFFFFFFFBCEC	EE800002		; SETMID
FFFFFFFFFFFFBCF0	040D0809		 	lw		r2,#10000000	; retry for up to several seconds
FFFFFFFFFFFFBCF4	           		 tmp_init4:
FFFFFFFFFFFFBCF4	BE2000C8		 	beq		r2,r0,tmp_init5
FFFFFFFFFFFFBCF8	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFBCFC	E69C0302		; SETLO
FFFFFFFFFFFFBD00	EE800003		; SETMID
FFFFFFFFFFFFBD04	6A0D0421		 	inch	r1,TMP+2	; read the status reg
FFFFFFFFFFFFBD08	BE107F60		 	blt		r1,r0,tmp_init4
FFFFFFFFFFFFBD0C	           		 tmp_init5:
                  	           		 
FFFFFFFFFFFFBD0C	16008051		 	lw		r1,#0x51	; Start temperature conversion
FFFFFFFFFFFFBD10	E69C0300		; SETLO
FFFFFFFFFFFFBD14	EE800003		; SETMID
FFFFFFFFFFFFBD18	6A0D0429		 	outc	r1,TMP
                  	           		 
                  	           		 	; wait a bit for the trigger to take effect
FFFFFFFFFFFFBD1C	160089C4		 	lw		r1,#2500
FFFFFFFFFFFFBD20	           		 tmp_init1:
FFFFFFFFFFFFBD20	BE00800F		 	loop	r1,tmp_init1
                  	           		 
                  	           		 	; wait for the rst1626 to go low
FFFFFFFFFFFFBD24	E6989680		; SETLO
FFFFFFFFFFFFBD28	EE800002		; SETMID
FFFFFFFFFFFFBD2C	040D0809		 	lw		r2,#10000000	; retry for up to several seconds
FFFFFFFFFFFFBD30	           		 tmp_init2:
FFFFFFFFFFFFBD30	BE2000C8		 	beq		r2,r0,tmp_init3
FFFFFFFFFFFFBD34	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFBD38	E69C0302		; SETLO
FFFFFFFFFFFFBD3C	EE800003		; SETMID
FFFFFFFFFFFFBD40	6A0D0421		 	inch	r1,TMP+2	; read the status reg
FFFFFFFFFFFFBD44	BE107F60		 	blt		r1,r0,tmp_init2
FFFFFFFFFFFFBD48	           		 tmp_init3:
FFFFFFFFFFFFBD48	37EF8000		 	ret
                  	           		 
FFFFFFFFFFFFBD4C	           		 tmp_read:
FFFFFFFFFFFFBD4C	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFBD50	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFBD54	67E08008		 	sw		r1,8[sp]
FFFFFFFFFFFFBD58	67E10010		 	sw		r2,16[sp]
                  	           		 
FFFFFFFFFFFFBD5C	E6BD7840		; SETLO
FFFFFFFFFFFFBD60	EE800005		; SETMID
FFFFFFFFFFFFBD64	040D0409		 	lw		r1,#25000000	; wait about 1 second or so
FFFFFFFFFFFFBD68	           		 tmp_read1:
FFFFFFFFFFFFBD68	BE00800F		 	loop	r1,tmp_read1
FFFFFFFFFFFFBD6C	160080AC		 	lw		r1,#0xAC	; issue read temperature conversion
FFFFFFFFFFFFBD70	E69C0300		; SETLO
FFFFFFFFFFFFBD74	EE800003		; SETMID
FFFFFFFFFFFFBD78	6A0D0429		 	outc	r1,TMP
                  	           		 
                  	           		 	; wait a bit for the trigger to take effect
FFFFFFFFFFFFBD7C	160089C4		 	lw		r1,#2500
FFFFFFFFFFFFBD80	           		 tmp_read3:
FFFFFFFFFFFFBD80	BE00800F		 	loop	r1,tmp_read3
                  	           		 
                  	           		 	; wait for the rst1626 to go low
FFFFFFFFFFFFBD84	E6989680		; SETLO
FFFFFFFFFFFFBD88	EE800002		; SETMID
FFFFFFFFFFFFBD8C	040D0809		 	lw		r2,#10000000
FFFFFFFFFFFFBD90	           		 tmp_read2:
FFFFFFFFFFFFBD90	E69C0302		; SETLO
FFFFFFFFFFFFBD94	EE800003		; SETMID
FFFFFFFFFFFFBD98	6A0D0421		 	inch	r1,TMP+2	; read the status reg
FFFFFFFFFFFFBD9C	BE200068		 	beq		r2,r0,tmp_read4
FFFFFFFFFFFFBDA0	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFBDA4	BE107F60		 	blt		r1,r0,tmp_read2
FFFFFFFFFFFFBDA8	           		 tmp_read4:
FFFFFFFFFFFFBDA8	E69C0302		; SETLO
FFFFFFFFFFFFBDAC	EE800003		; SETMID
FFFFFFFFFFFFBDB0	6A0D0421		 	inch	r1,TMP+2		; read the temperature
FFFFFFFFFFFFBDB4	16010005		 	lw		r2,#5			; five digits
FFFFFFFFFFFFBDB8	31FFF13F		 	call	DisplayNum
FFFFFFFFFFFFBDBC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFBDC0	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFBDC4	47E10010		 	lw		r2,16[sp]
FFFFFFFFFFFFBDC8	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; 100 Hz interrupt
                  	           		 ; - takes care of "flashing" the cursor
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBDCC	           		 Pulse100:
FFFFFFFFFFFFBDCC	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFBDD0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFBDD4	E6900000		; SETLO
FFFFFFFFFFFFBDD8	EE800003		; SETMID
FFFFFFFFFFFFBDDC	6A0D082D		 	lea		r2,TEXTSCR
FFFFFFFFFFFFBDE0	8220814E		 	inch	r1,334[r2]
FFFFFFFFFFFFBDE4	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFBDE8	9220814E		 	outc	r1,334[r2]
                  	           		 ;	call	DisplayDatetime
FFFFFFFFFFFFBDEC	31FFEF82		 	call	SelectNextToRunTCB
FFFFFFFFFFFFBDF0	31FFEF84		 	call	SwitchTask
FFFFFFFFFFFFBDF4	E69CFFFC		; SETLO
FFFFFFFFFFFFBDF8	EE800003		; SETMID
FFFFFFFFFFFFBDFC	6A0D0028		 	outb	r0,0xDCFFFC		; clear interrupt
                  	           		 ;	lw		r1,TickIRQAddr
                  	           		 ;	jal		r31,[r1]
                  	           		 ;	lw		r1,Milliseconds
                  	           		 ;	andi	r1,r1,#0x0f
                  	           		 ;	bnei	r1,#5,p1001
                  	           		 ;	call	FlashCursor
FFFFFFFFFFFFBE00	           		 p1001:
FFFFFFFFFFFFBE00	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFBE04	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFBE08	           		 SelectNextToRunTCB:
FFFFFFFFFFFFBE08	620020A8		 	sc		r0,NextToRunTCB
FFFFFFFFFFFFBE0C	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Switch from the RunningTCB to the NextToRunTCB
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFBE10	           		 SwitchTask:
FFFFFFFFFFFFBE10	6600A0B0		 	sw		r1,r1save
FFFFFFFFFFFFBE14	660120B8		 	sw		r2,r2save
FFFFFFFFFFFFBE18	4C00A0A8		 	lcu		r1,NextToRunTCB
FFFFFFFFFFFFBE1C	4C0120A6		 	lcu		r2,RunningTCB
FFFFFFFFFFFFBE20	BE110089		 	bne		r1,r2,swtsk1		; are we already running this TCB ?
FFFFFFFFFFFFBE24	4600A0B0		 	lw		r1,r1save
FFFFFFFFFFFFBE28	460120B8		 	lw		r2,r2save
FFFFFFFFFFFFBE2C	37EF8000		 	ret
FFFFFFFFFFFFBE30	           		 swtsk1:
FFFFFFFFFFFFBE30	142101FF		 	andi	r2,r2,#0x1ff		; max 512 TCB's
FFFFFFFFFFFFBE34	1A210200		 	mului	r2,r2,#TCBSize
FFFFFFFFFFFFBE38	E6800000		; SETLO
FFFFFFFFFFFFBE3C	EE800400		; SETMID
FFFFFFFFFFFFBE40	042D0803		 	addui	r2,r2,#TCBBase
FFFFFFFFFFFFBE44	4600A0B0		 	lw		r1,r1save			; get back r1
FFFFFFFFFFFFBE48	66208000		 	sw		r1,TCBr1[r2]
FFFFFFFFFFFFBE4C	4600A0B8		 	lw		r1,r2save			; get back r2
FFFFFFFFFFFFBE50	66208008		 	sw		r1,TCBr2[r2]
FFFFFFFFFFFFBE54	66218010		 	sw		r3,TCBr3[r2]
FFFFFFFFFFFFBE58	66220018		 	sw		r4,TCBr4[r2]
FFFFFFFFFFFFBE5C	66228020		 	sw		r5,TCBr5[r2]
FFFFFFFFFFFFBE60	66230028		 	sw		r6,TCBr6[r2]
FFFFFFFFFFFFBE64	66238030		 	sw		r7,TCBr7[r2]
FFFFFFFFFFFFBE68	66240038		 	sw		r8,TCBr8[r2]
FFFFFFFFFFFFBE6C	66248040		 	sw		r9,TCBr9[r2]
FFFFFFFFFFFFBE70	66250048		 	sw		r10,TCBr10[r2]
FFFFFFFFFFFFBE74	66258050		 	sw		r11,TCBr11[r2]
FFFFFFFFFFFFBE78	66260058		 	sw		r12,TCBr12[r2]
FFFFFFFFFFFFBE7C	66268060		 	sw		r13,TCBr13[r2]
FFFFFFFFFFFFBE80	66270068		 	sw		r14,TCBr14[r2]
FFFFFFFFFFFFBE84	66278070		 	sw		r15,TCBr15[r2]
FFFFFFFFFFFFBE88	66280078		 	sw		r16,TCBr16[r2]
FFFFFFFFFFFFBE8C	66288080		 	sw		r17,TCBr17[r2]
FFFFFFFFFFFFBE90	66290088		 	sw		r18,TCBr18[r2]
FFFFFFFFFFFFBE94	66298090		 	sw		r19,TCBr19[r2]
FFFFFFFFFFFFBE98	662A0098		 	sw		r20,TCBr20[r2]
FFFFFFFFFFFFBE9C	662A80A0		 	sw		r21,TCBr21[r2]
FFFFFFFFFFFFBEA0	662B00A8		 	sw		r22,TCBr22[r2]
FFFFFFFFFFFFBEA4	662B80B0		 	sw		r23,TCBr23[r2]
FFFFFFFFFFFFBEA8	662C00B8		 	sw		r24,TCBr24[r2]
FFFFFFFFFFFFBEAC	662C80C0		 	sw		r25,TCBr25[r2]
FFFFFFFFFFFFBEB0	662D00C8		 	sw		r26,TCBr26[r2]
FFFFFFFFFFFFBEB4	662D80D0		 	sw		r27,TCBr27[r2]
FFFFFFFFFFFFBEB8	662E00D8		 	sw		r28,TCBr28[r2]
FFFFFFFFFFFFBEBC	662E80E0		 	sw		r29,TCBr29[r2]
FFFFFFFFFFFFBEC0	662F00E8		 	sw		r30,TCBr30[r2]
FFFFFFFFFFFFBEC4	662F80F0		 	sw		r31,TCBr31[r2]
                  	           		 
FFFFFFFFFFFFBEC8	4C0120A8		 	lcu		r2,NextToRunTCB
FFFFFFFFFFFFBECC	620120A6		 	sc		r2,RunningTCB
FFFFFFFFFFFFBED0	1A210200		 	mului	r2,r2,#TCBSize
FFFFFFFFFFFFBED4	E6800000		; SETLO
FFFFFFFFFFFFBED8	EE800400		; SETMID
FFFFFFFFFFFFBEDC	042D0803		 	addui	r2,r2,#TCBBase
                  	           		 
FFFFFFFFFFFFBEE0	46208000		 	lw		r1,TCBr1[r2]
FFFFFFFFFFFFBEE4	46218010		 	lw		r3,TCBr3[r2]
FFFFFFFFFFFFBEE8	46220018		 	lw		r4,TCBr4[r2]
FFFFFFFFFFFFBEEC	46228020		 	lw		r5,TCBr5[r2]
FFFFFFFFFFFFBEF0	46230028		 	lw		r6,TCBr6[r2]
FFFFFFFFFFFFBEF4	46238030		 	lw		r7,TCBr7[r2]
FFFFFFFFFFFFBEF8	46240038		 	lw		r8,TCBr8[r2]
FFFFFFFFFFFFBEFC	46248040		 	lw		r9,TCBr9[r2]
FFFFFFFFFFFFBF00	46250048		 	lw		r10,TCBr10[r2]
FFFFFFFFFFFFBF04	46258050		 	lw		r11,TCBr11[r2]
FFFFFFFFFFFFBF08	46260058		 	lw		r12,TCBr12[r2]
FFFFFFFFFFFFBF0C	46268060		 	lw		r13,TCBr13[r2]
FFFFFFFFFFFFBF10	46270068		 	lw		r14,TCBr14[r2]
FFFFFFFFFFFFBF14	46278070		 	lw		r15,TCBr15[r2]
FFFFFFFFFFFFBF18	46280078		 	lw		r16,TCBr16[r2]
FFFFFFFFFFFFBF1C	46288080		 	lw		r17,TCBr17[r2]
FFFFFFFFFFFFBF20	46290088		 	lw		r18,TCBr18[r2]
FFFFFFFFFFFFBF24	46298090		 	lw		r19,TCBr19[r2]
FFFFFFFFFFFFBF28	462A0098		 	lw		r20,TCBr20[r2]
FFFFFFFFFFFFBF2C	462A80A0		 	lw		r21,TCBr21[r2]
FFFFFFFFFFFFBF30	462B00A8		 	lw		r22,TCBr22[r2]
FFFFFFFFFFFFBF34	462B80B0		 	lw		r23,TCBr23[r2]
FFFFFFFFFFFFBF38	462C00B8		 	lw		r24,TCBr24[r2]
FFFFFFFFFFFFBF3C	462C80C0		 	lw		r25,TCBr25[r2]
FFFFFFFFFFFFBF40	462D00C8		 	lw		r26,TCBr26[r2]
FFFFFFFFFFFFBF44	462D80D0		 	lw		r27,TCBr27[r2]
FFFFFFFFFFFFBF48	462E00D8		 	lw		r28,TCBr28[r2]
FFFFFFFFFFFFBF4C	462E80E0		 	lw		r29,TCBr29[r2]
FFFFFFFFFFFFBF50	462F00E8		 	lw		r30,TCBr30[r2]
FFFFFFFFFFFFBF54	462F80F0		 	lw		r31,TCBr31[r2]
FFFFFFFFFFFFBF58	46210008		 	lw		r2,TCBr2[r2]
FFFFFFFFFFFFBF5C	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Flash Cursor
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBF60	           		 FlashCursor:
FFFFFFFFFFFFBF60	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBF64	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBF68	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBF6C	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBF70	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBF74	31FFF06F		 	call	CalcScreenLoc
FFFFFFFFFFFFBF78	E6810000		; SETLO
FFFFFFFFFFFFBF7C	041D0403		 	addui	r1,r1,#0x10000
FFFFFFFFFFFFBF80	4001141A		 	lb		r2,CursorFlash
FFFFFFFFFFFFBF84	BE2001C8		 	beq		r2,r0,flshcrsr2
                  	           		 	; causes screen colors to flip around
FFFFFFFFFFFFBF88	82110000		 	inch	r2,[r1]
FFFFFFFFFFFFBF8C	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFBF90	92110000		 	outc	r2,[r1]
FFFFFFFFFFFFBF94	           		 flshcrsr3:
FFFFFFFFFFFFBF94	46011408		 	lw		r2,Lastloc
FFFFFFFFFFFFBF98	BE110088		 	beq		r1,r2,flshcrsr1
                  	           		 	; restore the screen colors of the previous cursor location
FFFFFFFFFFFFBF9C	42019414		 	lc		r3,ScreenColor
FFFFFFFFFFFFBFA0	92218000		 	outc	r3,[r2]
FFFFFFFFFFFFBFA4	66009408		 	sw		r1,Lastloc
FFFFFFFFFFFFBFA8	           		 flshcrsr1:
FFFFFFFFFFFFBFA8	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBFAC	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBFB0	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBFB4	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFBFB8	37EF8020		 	ret		#32
FFFFFFFFFFFFBFBC	           		 flshcrsr2:
FFFFFFFFFFFFBFBC	42019414		 	lc		r3,ScreenColor
FFFFFFFFFFFFBFC0	92118000		 	outc	r3,[r1]
FFFFFFFFFFFFBFC4	BE007E8A		 	bra		flshcrsr3
                  	           		 
FFFFFFFFFFFFBFC8	           		 CursorOff:
FFFFFFFFFFFFBFC8	160080A0		 	lw		r1,#0xA0
FFFFFFFFFFFFBFCC	E69A0010		; SETLO
FFFFFFFFFFFFBFD0	EE800003		; SETMID
FFFFFFFFFFFFBFD4	6A0D0429		 	outc	r1,TEXTREG+16		; turn off cursor
FFFFFFFFFFFFBFD8	37EF8000		 	ret
FFFFFFFFFFFFBFDC	           		 CursorOn:
FFFFFFFFFFFFBFDC	160080E0		 	lw		r1,#0xE0
FFFFFFFFFFFFBFE0	E69A0010		; SETLO
FFFFFFFFFFFFBFE4	EE800003		; SETMID
FFFFFFFFFFFFBFE8	6A0D0429		 	outc	r1,TEXTREG+16		; turn on cursor
FFFFFFFFFFFFBFEC	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFBFF0	           		 ClearBmpScreen:
FFFFFFFFFFFFBFF0	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFBFF4	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBFF8	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBFFC	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC000	E68FFC00		; SETLO
FFFFFFFFFFFFC004	040D0809		 	lw		r2,#1364*768
FFFFFFFFFFFFC008	06210601		 	shrui	r2,r2,#3			; r2 = # words to clear
FFFFFFFFFFFFC00C	E6A92929		; SETLO
FFFFFFFFFFFFC010	EEA4A4A4		; SETMID
FFFFFFFFFFFFC014	F6829292		; SETHI
FFFFFFFFFFFFC018	6A0D042D		 	lea		r1,0x2929292929292929	; r1 = color for eight pixels
FFFFFFFFFFFFC01C	E6A00000		; SETLO
FFFFFFFFFFFFC020	EE800400		; SETMID
FFFFFFFFFFFFC024	6A0D0C2D		 	lea		r3,BITMAPSCR		; r3 = screen address
FFFFFFFFFFFFC028	           		 csj4:
FFFFFFFFFFFFC028	66308000		 	sw		r1,[r3]				; store pixel data
FFFFFFFFFFFFC02C	0A318008		 	addui	r3,r3,#8			; advance screen address by eight
FFFFFFFFFFFFC030	BE017FCF		 	loop	r2,csj4				; decrement pixel count and loop back
FFFFFFFFFFFFC034	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC038	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC03C	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFC040	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Clear the screen and the screen color memory
                  	           		 ; We clear the screen to give a visual indication that the system
                  	           		 ; is working at all.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC044	           		 ClearScreen:
FFFFFFFFFFFFC044	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFC048	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC04C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC050	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC054	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFC058	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFC05C	E69A0000		; SETLO
FFFFFFFFFFFFC060	EE800003		; SETMID
FFFFFFFFFFFFC064	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFC068	82308000		 	inch	r1,TEXT_COLS[r3]	; calc number to clear
FFFFFFFFFFFFC06C	82310002		 	inch	r2,TEXT_ROWS[r3]
FFFFFFFFFFFFC070	04110818		 	mulu	r2,r1,r2			; r2 = # chars to clear
FFFFFFFFFFFFC074	E0400020		 	setlo	r1,#32			; space char
FFFFFFFFFFFFC078	42021414		 	lc		r4,ScreenColor
FFFFFFFFFFFFC07C	31FFF063		 	call	AsciiToScreen
FFFFFFFFFFFFC080	E6900000		; SETLO
FFFFFFFFFFFFC084	EE800003		; SETMID
FFFFFFFFFFFFC088	6A0D0C2D		 	lea		r3,TEXTSCR		; text screen address
FFFFFFFFFFFFC08C	           		 csj4:
FFFFFFFFFFFFC08C	92308000		 	outc	r1,[r3]
FFFFFFFFFFFFC090	E6810000		; SETLO
FFFFFFFFFFFFC094	6A3D1029		 	outc	r4,0x10000[r3]	; color screen is 0x10000 higher
FFFFFFFFFFFFC098	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC09C	BE017F8F		 	loop	r2,csj4
FFFFFFFFFFFFC0A0	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFC0A4	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFC0A8	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFC0AC	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC0B0	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC0B4	37EF8028		 	ret		#40
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Scroll text on the screen upwards
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC0B8	           		 ScrollUp:
FFFFFFFFFFFFC0B8	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFC0BC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC0C0	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC0C4	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC0C8	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFC0CC	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFC0D0	E69A0000		; SETLO
FFFFFFFFFFFFC0D4	EE800003		; SETMID
FFFFFFFFFFFFC0D8	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFC0DC	82308000		 	inch	r1,TEXT_COLS[r3]	; r1 = # text columns
FFFFFFFFFFFFC0E0	82310002		 	inch	r2,TEXT_ROWS[r3]
FFFFFFFFFFFFC0E4	04110818		 	mulu	r2,r1,r2			; calc number of chars to scroll
FFFFFFFFFFFFC0E8	04208805		 	subu	r2,r2,r1			; one less row
FFFFFFFFFFFFC0EC	E6900000		; SETLO
FFFFFFFFFFFFC0F0	EE800003		; SETMID
FFFFFFFFFFFFC0F4	6A0D0C2D		 	lea		r3,TEXTSCR
FFFFFFFFFFFFC0F8	           		 scrup1:
FFFFFFFFFFFFC0F8	6A309121		 	inch	r4,[r3+r1*2]		; indexed addressing example
FFFFFFFFFFFFC0FC	92320000		 	outc	r4,[r3]
FFFFFFFFFFFFC100	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC104	BE017FAF		 	loop	r2,scrup1
                  	           		 
FFFFFFFFFFFFC108	E69A0000		; SETLO
FFFFFFFFFFFFC10C	EE800003		; SETMID
FFFFFFFFFFFFC110	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFC114	82308002		 	inch	r1,TEXT_ROWS[r3]
FFFFFFFFFFFFC118	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFC11C	31FFF04E		 	call	BlankLine
FFFFFFFFFFFFC120	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC124	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC128	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFC12C	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFC130	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFC134	37EF8028		 	ret		#40
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Blank out a line on the display
                  	           		 ; line number to blank is in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC138	           		 BlankLine:
FFFFFFFFFFFFC138	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC13C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC140	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC144	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC148	E69A0000		; SETLO
FFFFFFFFFFFFC14C	EE800003		; SETMID
FFFFFFFFFFFFC150	6A0D0C2D		 	lea		r3,TEXTREG			; r3 = text register address
FFFFFFFFFFFFC154	82310000		 	inch	r2,TEXT_COLS[r3]	; r2 = # chars to blank out
FFFFFFFFFFFFC158	04208C18		 	mulu	r3,r2,r1
FFFFFFFFFFFFC15C	06318200		 	shli	r3,r3,#1
FFFFFFFFFFFFC160	E6900000		; SETLO
FFFFFFFFFFFFC164	EE800003		; SETMID
FFFFFFFFFFFFC168	043D0C03		 	addui	r3,r3,#TEXTSCR		; r3 = screen address
FFFFFFFFFFFFC16C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFC170	           		 blnkln1:
FFFFFFFFFFFFC170	92308000		 	outc	r1,[r3]
FFFFFFFFFFFFC174	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC178	BE017FCF		 	loop	r2,blnkln1
FFFFFFFFFFFFC17C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC180	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC184	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFC188	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert ASCII character to screen display character.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC18C	           		 AsciiToScreen:
FFFFFFFFFFFFC18C	141080FF		 	andi	r1,r1,#0x00ff
FFFFFFFFFFFFC190	A8100541		 	bltui	r1,#'A',atoscr1
FFFFFFFFFFFFC194	AC10045A		 	bleui	r1,#'Z',atoscr1
FFFFFFFFFFFFC198	AE10037A		 	bgtui   r1,#'z',atoscr1
FFFFFFFFFFFFC19C	A8100261		 	bltui	r1,#'a',atoscr1
FFFFFFFFFFFFC1A0	0E108060		 	subui	r1,r1,#0x60
FFFFFFFFFFFFC1A4	           		 atoscr1:
FFFFFFFFFFFFC1A4	16108100		 	ori		r1,r1,#0x100
FFFFFFFFFFFFC1A8	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert screen character to ascii character
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC1AC	           		 ScreenToAscii:
FFFFFFFFFFFFC1AC	141080FF		 	andi	r1,r1,#0xff
FFFFFFFFFFFFC1B0	AE10021A		 	bgtui	r1,#26,stasc1
FFFFFFFFFFFFC1B4	0A10803C		 	addui	r1,r1,#60
FFFFFFFFFFFFC1B8	           		 stasc1:
FFFFFFFFFFFFC1B8	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Calculate screen memory location from CursorRow,CursorCol.
                  	           		 ; Also refreshes the cursor location.
                  	           		 ; Destroys r1,r2,r3
                  	           		 ; r1 = screen location
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC1BC	           		 CalcScreenLoc:
FFFFFFFFFFFFC1BC	4A009417		 	lbu		r1,CursorRow
FFFFFFFFFFFFC1C0	1410807F		 	andi	r1,r1,#0x7f
FFFFFFFFFFFFC1C4	E69A0000		; SETLO
FFFFFFFFFFFFC1C8	EE800003		; SETMID
FFFFFFFFFFFFC1CC	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFC1D0	82310000		 	inch	r2,TEXT_COLS[r3]
FFFFFFFFFFFFC1D4	04208818		 	mulu	r2,r2,r1
FFFFFFFFFFFFC1D8	4A009418		 	lbu		r1,CursorCol
FFFFFFFFFFFFC1DC	1410807F		 	andi	r1,r1,#0x7f
FFFFFFFFFFFFC1E0	04208803		 	addu	r2,r2,r1
FFFFFFFFFFFFC1E4	92310016		 	outc	r2,TEXT_CURPOS[r3]
FFFFFFFFFFFFC1E8	06210206		 	shlui	r2,r2,#1
FFFFFFFFFFFFC1EC	E6900000		; SETLO
FFFFFFFFFFFFC1F0	EE800003		; SETMID
FFFFFFFFFFFFC1F4	042D0403		 	addui	r1,r2,#TEXTSCR			; r1 = screen location
FFFFFFFFFFFFC1F8	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display a character on the screen
                  	           		 ; d1.b = char to display
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC1FC	           		 DisplayChar:
FFFFFFFFFFFFC1FC	B210080D		 	bnei	r1,#'\r',dccr		; carriage return ?
FFFFFFFFFFFFC200	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC204	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC208	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC20C	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC210	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC214	60001418		 	sb		r0,CursorCol		; just set cursor column to zero on a CR
FFFFFFFFFFFFC218	BE00018A		 	bra		dcx7
FFFFFFFFFFFFC21C	           		 dccr:
                  	           		 ;	beqi	r1,#CTRLK,dccr1
FFFFFFFFFFFFC21C	E6800091		; SETLO
FFFFFFFFFFFFC220	BE1D0209		 	bnei	r1,#0x91,dcx6		; cursor right ?
FFFFFFFFFFFFC224	           		 dccr1:
FFFFFFFFFFFFC224	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC228	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC22C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC230	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC234	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC238	4A011418		 	lbu		r2,CursorCol
FFFFFFFFFFFFC23C	B0200338		 	beqi	r2,#56,dcx7
FFFFFFFFFFFFC240	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFC244	60011418		 	sb		r2,CursorCol
FFFFFFFFFFFFC248	           		 dcx7:
FFFFFFFFFFFFC248	31FFF06F		 	call	CalcScreenLoc
FFFFFFFFFFFFC24C	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFC250	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFC254	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC258	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC25C	37EF8020		 	ret		#32
FFFFFFFFFFFFC260	           		 dcx6:
                  	           		 ;	beqi	r1,#CTRLI,dccu1
FFFFFFFFFFFFC260	E6800090		; SETLO
FFFFFFFFFFFFC264	BE1D0169		 	bnei	r1,#0x90,dcx8		; cursor up ?
FFFFFFFFFFFFC268	           		 dccu1:
FFFFFFFFFFFFC268	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC26C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC270	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC274	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC278	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC27C	4A011417		 	lbu		r2,CursorRow
FFFFFFFFFFFFC280	B02FF200		 	beqi	r2,#0,dcx7
FFFFFFFFFFFFC284	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFC288	60011417		 	sb		r2,CursorRow
FFFFFFFFFFFFC28C	BE007DEA		 	bra		dcx7
FFFFFFFFFFFFC290	           		 dcx8:
                  	           		 ;	beqi	r1,#CTRLJ,dccl1
FFFFFFFFFFFFC290	E6800093		; SETLO
FFFFFFFFFFFFC294	BE1D0169		 	bnei	r1,#0x93,dcx9		; cursor left ?
FFFFFFFFFFFFC298	           		 dccl1:
FFFFFFFFFFFFC298	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC29C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC2A0	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC2A4	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC2A8	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC2AC	4A011418		 	lbu		r2,CursorCol
FFFFFFFFFFFFC2B0	B02FE600		 	beqi	r2,#0,dcx7
FFFFFFFFFFFFC2B4	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFC2B8	60011418		 	sb		r2,CursorCol
FFFFFFFFFFFFC2BC	BE007C6A		 	bra		dcx7
FFFFFFFFFFFFC2C0	           		 dcx9:
                  	           		 ;	beqi	r1,#CTRLM,dccd1
FFFFFFFFFFFFC2C0	E6800092		; SETLO
FFFFFFFFFFFFC2C4	BE1D0169		 	bnei	r1,#0x92,dcx10		; cursor down ?
FFFFFFFFFFFFC2C8	           		 dccd1:
FFFFFFFFFFFFC2C8	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC2CC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC2D0	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC2D4	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC2D8	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC2DC	4A011417		 	lbu		r2,CursorRow
FFFFFFFFFFFFC2E0	B02FDA1E		 	beqi	r2,#30,dcx7
FFFFFFFFFFFFC2E4	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFC2E8	60011417		 	sb		r2,CursorRow
FFFFFFFFFFFFC2EC	BE007AEA		 	bra		dcx7
FFFFFFFFFFFFC2F0	           		 dcx10:
FFFFFFFFFFFFC2F0	E6800094		; SETLO
FFFFFFFFFFFFC2F4	BE1D0189		 	bnei	r1,#0x94,dcx11			; cursor home ?
FFFFFFFFFFFFC2F8	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC2FC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC300	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC304	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC308	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC30C	4A011418		 	lbu		r2,CursorCol
FFFFFFFFFFFFC310	BE200068		 	beq		r2,r0,dcx12
FFFFFFFFFFFFC314	60001418		 	sb		r0,CursorCol
FFFFFFFFFFFFC318	BE00798A		 	bra		dcx7
FFFFFFFFFFFFC31C	           		 dcx12:
FFFFFFFFFFFFC31C	60001417		 	sb		r0,CursorRow
FFFFFFFFFFFFC320	BE00794A		 	bra		dcx7
FFFFFFFFFFFFC324	           		 dcx11:
FFFFFFFFFFFFC324	0FEF0030		 	subui	sp,sp,#48
FFFFFFFFFFFFC328	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC32C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC330	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC334	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFC338	67E28020		 	sw		r5,32[sp]
FFFFFFFFFFFFC33C	67EF8028		 	sw		lr,40[sp]
FFFFFFFFFFFFC340	E6800099		; SETLO
FFFFFFFFFFFFC344	BE1D00A9		 	bnei	r1,#0x99,dcx13		; delete ?
FFFFFFFFFFFFC348	31FFF06F		 	call	CalcScreenLoc
FFFFFFFFFFFFC34C	02118009		 	mov		r3,r1				; r3 = screen location
FFFFFFFFFFFFC350	4A009418		 	lbu		r1,CursorCol		; r1 = cursor column
FFFFFFFFFFFFC354	BE00012A		 	bra		dcx5
FFFFFFFFFFFFC358	           		 dcx13:
FFFFFFFFFFFFC358	B2101508		 	bnei	r1,#CTRLH,dcx3		; backspace ?
FFFFFFFFFFFFC35C	4A011418		 	lbu		r2,CursorCol
FFFFFFFFFFFFC360	BE200408		 	beq		r2,r0,dcx4
FFFFFFFFFFFFC364	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFC368	60011418		 	sb		r2,CursorCol
FFFFFFFFFFFFC36C	31FFF06F		 	call	CalcScreenLoc		; a0 = screen location
FFFFFFFFFFFFC370	02118009		 	mov		r3,r1				; r3 = screen location
FFFFFFFFFFFFC374	4A009418		 	lbu		r1,CursorCol
FFFFFFFFFFFFC378	           		 dcx5:
FFFFFFFFFFFFC378	82310002		 	inch	r2,2[r3]
FFFFFFFFFFFFC37C	92310000		 	outc	r2,[r3]
FFFFFFFFFFFFC380	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC384	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFC388	E69A0000		; SETLO
FFFFFFFFFFFFC38C	EE800003		; SETMID
FFFFFFFFFFFFC390	6A0D102D		 	lea		r4,TEXTREG
FFFFFFFFFFFFC394	82428000		 	inch	r5,TEXT_COLS[r4]
FFFFFFFFFFFFC398	BE12FF04		 	bltu	r1,r5,dcx5
FFFFFFFFFFFFC39C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFC3A0	31FFF063		 	call	AsciiToScreen
FFFFFFFFFFFFC3A4	9230FFFE		 	outc	r1,-2[r3]
FFFFFFFFFFFFC3A8	BE0001CA		 	bra		dcx4
FFFFFFFFFFFFC3AC	           		 dcx3:
FFFFFFFFFFFFC3AC	B0100C0A		 	beqi	r1,#'\n',dclf	; linefeed ?
FFFFFFFFFFFFC3B0	02120009		 	mov		r4,r1			; save r1 in r4
FFFFFFFFFFFFC3B4	31FFF06F		 	call	CalcScreenLoc	; r1 = screen location
FFFFFFFFFFFFC3B8	02118009		 	mov		r3,r1			; r3 = screen location
FFFFFFFFFFFFC3BC	02408009		 	mov		r1,r4			; restore r1
FFFFFFFFFFFFC3C0	31FFF063		 	call	AsciiToScreen	; convert ascii char to screen char
FFFFFFFFFFFFC3C4	92308000		 	outc	r1,[r3]
FFFFFFFFFFFFC3C8	42009410		 	lc		r1,CharColor
FFFFFFFFFFFFC3CC	E6810000		; SETLO
FFFFFFFFFFFFC3D0	6A3D0429		 	outc	r1,0x10000[r3]
FFFFFFFFFFFFC3D4	31FFF0FF		 	call	IncCursorPos
FFFFFFFFFFFFC3D8	BE00004A		 	bra		dcx4
FFFFFFFFFFFFC3DC	           		 dclf:
FFFFFFFFFFFFC3DC	31FFF10D		 	call	IncCursorRow
FFFFFFFFFFFFC3E0	           		 dcx4:
FFFFFFFFFFFFC3E0	47EF8028		 	lw		lr,40[sp]
FFFFFFFFFFFFC3E4	47E28020		 	lw		r5,32[sp]
FFFFFFFFFFFFC3E8	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFC3EC	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFC3F0	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC3F4	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC3F8	37EF8030		 	ret		#48
                  	           		 
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Increment the cursor position, scroll the screen if needed.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC3FC	           		 IncCursorPos:
FFFFFFFFFFFFC3FC	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC400	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC404	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC408	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC40C	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC410	4A009418		 	lbu		r1,CursorCol
FFFFFFFFFFFFC414	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFC418	60009418		 	sb		r1,CursorCol
FFFFFFFFFFFFC41C	E69A0000		; SETLO
FFFFFFFFFFFFC420	EE800003		; SETMID
FFFFFFFFFFFFC424	6A0D0821		 	inch	r2,TEXTREG+TEXT_COLS
FFFFFFFFFFFFC428	BE110246		 	bleu	r1,r2,icc1
FFFFFFFFFFFFC42C	60001418		 	sb		r0,CursorCol		; column = 0
FFFFFFFFFFFFC430	BE0000CA		 	bra		icr1
FFFFFFFFFFFFC434	           		 IncCursorRow:
FFFFFFFFFFFFC434	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC438	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC43C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC440	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFC444	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFC448	           		 icr1:
FFFFFFFFFFFFC448	4A009417		 	lbu		r1,CursorRow
FFFFFFFFFFFFC44C	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFC450	60009417		 	sb		r1,CursorRow
FFFFFFFFFFFFC454	E69A0002		; SETLO
FFFFFFFFFFFFC458	EE800003		; SETMID
FFFFFFFFFFFFC45C	6A0D0821		 	inch	r2,TEXTREG+TEXT_ROWS
FFFFFFFFFFFFC460	BE110086		 	bleu	r1,r2,icc1
FFFFFFFFFFFFC464	0E210001		 	subui	r2,r2,#1			; backup the cursor row, we are scrolling up
FFFFFFFFFFFFC468	60011417		 	sb		r2,CursorRow
FFFFFFFFFFFFC46C	31FFF02E		 	call	ScrollUp
FFFFFFFFFFFFC470	           		 icc1:
FFFFFFFFFFFFC470	31FFF06F		 	call	CalcScreenLoc
FFFFFFFFFFFFC474	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFC478	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFC47C	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC480	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC484	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display a string on the screen.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC488	           		 DisplayString:
FFFFFFFFFFFFC488	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC48C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC490	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFC494	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC498	02110009		 	mov		r2,r1			; r2 = pointer to string
FFFFFFFFFFFFC49C	           		 dspj1:
FFFFFFFFFFFFC49C	4A208000		 	lbu		r1,[r2]			; move string char into r1
FFFFFFFFFFFFC4A0	0A210001		 	addui	r2,r2,#1		; increment pointer
FFFFFFFFFFFFC4A4	BE100068		 	beq		r1,r0,dsret		; is it end of string ?
FFFFFFFFFFFFC4A8	31FFF07F		 	call	DisplayChar		; display character
FFFFFFFFFFFFC4AC	BE007F8A		 	bra		dspj1			; go back for next character
FFFFFFFFFFFFC4B0	           		 dsret:
FFFFFFFFFFFFC4B0	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC4B4	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFC4B8	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC4BC	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFC4C0	           		 DisplayStringCRLF:
FFFFFFFFFFFFC4C0	0FEF0008		 	subui	r30,r30,#8
FFFFFFFFFFFFC4C4	67EF8000		 	sw		r31,[r30]
FFFFFFFFFFFFC4C8	31FFF122		 	call	DisplayString
FFFFFFFFFFFFC4CC	47EF8000		 	lw		r31,[r30]
FFFFFFFFFFFFC4D0	0BEF0008		 	addui	r30,r30,#8
                  	           		 
FFFFFFFFFFFFC4D4	           		 CRLF:
FFFFFFFFFFFFC4D4	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC4D8	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC4DC	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC4E0	E040000D		 	setlo	r1,#'\r'
FFFFFFFFFFFFC4E4	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC4E8	E040000A		 	setlo	r1,#'\n'
FFFFFFFFFFFFC4EC	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC4F0	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC4F4	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC4F8	37EF8010		 	ret		#16
                  	           		 
                  	           		 ; Call the Tiny BASIC routine to display a number
                  	           		 ;
FFFFFFFFFFFFC4FC	           		 DisplayNum:
FFFFFFFFFFFFC4FC	33FFFCCC		 	jmp		PRTNUM
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display nybble in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC500	           		 DisplayNybble:
FFFFFFFFFFFFC500	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC504	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC508	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC50C	1410800F		 	andi	r1,r1,#0x0F
FFFFFFFFFFFFC510	0A108030		 	addui	r1,r1,#'0'
FFFFFFFFFFFFC514	AC100239		 	bleui	r1,#'9',dispnyb1
FFFFFFFFFFFFC518	0A108007		 	addui	r1,r1,#7
FFFFFFFFFFFFC51C	           		 dispnyb1:
FFFFFFFFFFFFC51C	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC520	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC524	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC528	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display the byte in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC52C	           		 DisplayByte:
FFFFFFFFFFFFC52C	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC530	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC534	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC538	06108804		 	rori	r1,r1,#4	
FFFFFFFFFFFFC53C	31FFF140		 	call	DisplayNybble
FFFFFFFFFFFFC540	06108802		 	roli	r1,r1,#4
FFFFFFFFFFFFC544	31FFF140		 	call	DisplayNybble
FFFFFFFFFFFFC548	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC54C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC550	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display the char in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC554	           		 DisplayCharr:
FFFFFFFFFFFFC554	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC558	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC55C	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC560	06109004		 	rori	r1,r1,#8	
FFFFFFFFFFFFC564	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFC568	06109002		 	roli	r1,r1,#8
FFFFFFFFFFFFC56C	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFC570	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC574	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC578	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display the half-word in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC57C	           		 DisplayHalf:
FFFFFFFFFFFFC57C	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC580	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC584	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC588	0610A004		 	rori	r1,r1,#16
FFFFFFFFFFFFC58C	31FFF155		 	call	DisplayCharr
FFFFFFFFFFFFC590	0610A002		 	roli	r1,r1,#16
FFFFFFFFFFFFC594	31FFF155		 	call	DisplayCharr
FFFFFFFFFFFFC598	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC59C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC5A0	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display the 64 bit word in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC5A4	           		 DisplayWord:
FFFFFFFFFFFFC5A4	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC5A8	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC5AC	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFC5B0	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC5B4	E0C00007		 	setlo	r3,#7
FFFFFFFFFFFFC5B8	           		 dspwd1:
FFFFFFFFFFFFC5B8	06109002		 	roli	r1,r1,#8
FFFFFFFFFFFFC5BC	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFC5C0	BE01FFCF		 	loop	r3,dspwd1
FFFFFFFFFFFFC5C4	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC5C8	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFC5CC	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC5D0	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display memory pointed to by r2.
                  	           		 ; destroys r1,r3
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC5D4	           		 DisplayMemB:
FFFFFFFFFFFFC5D4	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC5D8	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC5DC	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFC5E0	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC5E4	E040003A		 	setlo	r1,#':'
FFFFFFFFFFFFC5E8	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC5EC	02208009		 	mov		r1,r2
FFFFFFFFFFFFC5F0	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFC5F4	E0C00007		 	setlo	r3,#7
FFFFFFFFFFFFC5F8	           		 dspmem1:
FFFFFFFFFFFFC5F8	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFC5FC	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC600	4A208000		 	lbu		r1,[r2]
FFFFFFFFFFFFC604	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFC608	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFC60C	BE01FF6F		 	loop	r3,dspmem1
FFFFFFFFFFFFC610	31FFF135		 	call	CRLF
FFFFFFFFFFFFC614	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC618	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFC61C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC620	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFC624	           		 DisplayMemC:
FFFFFFFFFFFFC624	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC628	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC62C	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFC630	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC634	E040003A		 	setlo	r1,#':'
FFFFFFFFFFFFC638	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC63C	02208009		 	mov		r1,r2
FFFFFFFFFFFFC640	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFC644	E0C00003		 	setlo	r3,#3
FFFFFFFFFFFFC648	           		 dspmemc1:
FFFFFFFFFFFFC648	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFC64C	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC650	4C208000		 	lcu		r1,[r2]
FFFFFFFFFFFFC654	31FFF155		 	call	DisplayCharr
FFFFFFFFFFFFC658	0A210002		 	addui	r2,r2,#2
FFFFFFFFFFFFC65C	BE01FF6F		 	loop	r3,dspmemc1
FFFFFFFFFFFFC660	31FFF135		 	call	CRLF
FFFFFFFFFFFFC664	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC668	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFC66C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC670	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFC674	           		 DisplayMemW:
FFFFFFFFFFFFC674	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC678	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC67C	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC680	E040003A		 	setlo	r1,#':'
FFFFFFFFFFFFC684	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC688	02208009		 	mov		r1,r2
FFFFFFFFFFFFC68C	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFC690	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFC694	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC698	46208000		 	lw		r1,[r2]
FFFFFFFFFFFFC69C	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFC6A0	0A210008		 	addui	r2,r2,#8
FFFFFFFFFFFFC6A4	31FFF135		 	call	CRLF
FFFFFFFFFFFFC6A8	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC6AC	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC6B0	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Converts binary number in r1 into BCD number in r2 and r1.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC6B4	           		 BinToBCD:
FFFFFFFFFFFFC6B4	0FEF0030		 	subui	sp,sp,#48
FFFFFFFFFFFFC6B8	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFC6BC	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFC6C0	67E28010		 	sw		r5,16[sp]
FFFFFFFFFFFFC6C4	67E30018		 	sw		r6,24[sp]
FFFFFFFFFFFFC6C8	67E38020		 	sw		r7,32[sp]
FFFFFFFFFFFFC6CC	67E40028		 	sw		r8,40[sp]
FFFFFFFFFFFFC6D0	E080000A		 	setlo	r2,#10
FFFFFFFFFFFFC6D4	E2000013		 	setlo	r8,#19		; number of digits to produce - 1
FFFFFFFFFFFFC6D8	           		 bta1:
FFFFFFFFFFFFC6D8	04110C1C		 	modu	r3,r1,r2
FFFFFFFFFFFFC6DC	0631F800		 	shli	r3,r3,#60	; shift result to uppermost bits
FFFFFFFFFFFFC6E0	0653F800		 	shli	r7,r5,#60	; copy low order nybble of r5 to r4 topmost nybble
FFFFFFFFFFFFC6E4	06420801		 	shrui	r4,r4,#4
FFFFFFFFFFFFC6E8	04439009		 	or		r4,r4,r7
FFFFFFFFFFFFC6EC	06528801		 	shrui	r5,r5,#4
FFFFFFFFFFFFC6F0	04519409		 	or		r5,r5,r3	; copy new bcd digit into uppermost bits of r5
FFFFFFFFFFFFC6F4	1E108000		 	divui	r1,r1,r2	; r1=r1/10
FFFFFFFFFFFFC6F8	BE047F0F		 	loop	r8,bta1
FFFFFFFFFFFFC6FC	06426001		 	shrui	r4,r4,#48	; right align number in register
FFFFFFFFFFFFC700	06532000		 	shli	r6,r5,#16
FFFFFFFFFFFFC704	04431009		 	or		r4,r4,r6	; copy bits into r4
FFFFFFFFFFFFC708	0652E001		 	shrui	r5,r5,#48
FFFFFFFFFFFFC70C	02408009		 	mov		r1,r4
FFFFFFFFFFFFC710	02510009		 	mov		r2,r5
FFFFFFFFFFFFC714	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFC718	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFC71C	47E28010		 	lw		r5,16[sp]
FFFFFFFFFFFFC720	47E30018		 	lw		r6,24[sp]
FFFFFFFFFFFFC724	47E38020		 	lw		r7,32[sp]
FFFFFFFFFFFFC728	47E40028		 	lw		r8,40[sp]
FFFFFFFFFFFFC72C	37EF8030		 	ret		#48
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Converts BCD number in r1 into Ascii number in r2 and r1.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC730	           		 BCDToAscii:
FFFFFFFFFFFFC730	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC734	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFC738	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFC73C	67E28010		 	sw		r5,16[sp]
FFFFFFFFFFFFC740	67E40018		 	sw		r8,24[sp]
FFFFFFFFFFFFC744	E200000F		 	setlo	r8,#15
FFFFFFFFFFFFC748	           		 bta2:
FFFFFFFFFFFFC748	1411000F		 	andi	r2,r1,#0x0F
FFFFFFFFFFFFC74C	16210030		 	ori		r2,r2,#0x30
FFFFFFFFFFFFC750	06217000		 	shli	r2,r2,#56
FFFFFFFFFFFFC754	06421001		 	shrui	r4,r4,#8
FFFFFFFFFFFFC758	0632F000		 	shli	r5,r3,#56
FFFFFFFFFFFFC75C	04429009		 	or		r4,r4,r5
FFFFFFFFFFFFC760	06319001		 	shrui	r3,r3,#8
FFFFFFFFFFFFC764	04310C09		 	or		r3,r3,r2
FFFFFFFFFFFFC768	06108801		 	shrui	r1,r1,#4
FFFFFFFFFFFFC76C	BE047EEF		 	loop	r8,bta2
FFFFFFFFFFFFC770	02408009		 	mov		r1,r4
FFFFFFFFFFFFC774	02310009		 	mov		r2,r3
FFFFFFFFFFFFC778	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFC77C	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFC780	47E28010		 	lw		r5,16[sp]
FFFFFFFFFFFFC784	47E40018		 	lw		r8,24[sp]
FFFFFFFFFFFFC788	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert a binary number into a 20 character ascii string.
                  	           		 ; r1 = number to convert
                  	           		 ; r2 = address of string buffer
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC78C	           		 BinToStr:
FFFFFFFFFFFFC78C	0FEF0038		 	subui	sp,sp,#56
FFFFFFFFFFFFC790	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFC794	67E38008		 	sw		r7,8[sp]
FFFFFFFFFFFFC798	67E40010		 	sw		r8,16[sp]
FFFFFFFFFFFFC79C	67E48018		 	sw		r9,24[sp]
FFFFFFFFFFFFC7A0	67E50020		 	sw		r10,32[sp]
FFFFFFFFFFFFC7A4	67E58028		 	sw		r11,40[sp]
FFFFFFFFFFFFC7A8	67EF8030		 	sw		lr,48[sp]
FFFFFFFFFFFFC7AC	02258009		 	mov		r11,r2
FFFFFFFFFFFFC7B0	31FFF1AD		 	call	BinToBCD
FFFFFFFFFFFFC7B4	02250009		 	mov		r10,r2	; save off r2
FFFFFFFFFFFFC7B8	31FFF1CC		 	call	BCDToAscii
FFFFFFFFFFFFC7BC	E2400001		 	setlo	r9,#1
FFFFFFFFFFFFC7C0	           		 btos3:
FFFFFFFFFFFFC7C0	E2000007		 	setlo	r8,#7
FFFFFFFFFFFFC7C4	           		 btos1:
FFFFFFFFFFFFC7C4	06938600		 	shli	r7,r9,#3
FFFFFFFFFFFFC7C8	0A738000		 	addui	r7,r7,r8
FFFFFFFFFFFFC7CC	0A738004		 	addui	r7,r7,#4
FFFFFFFFFFFFC7D0	141180FF		 	andi	r3,r1,#0xff
FFFFFFFFFFFFC7D4	6A758C10		 	sb		r3,[r7+r11]
FFFFFFFFFFFFC7D8	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFC7DC	BE047F4F		 	loop	r8,btos1
FFFFFFFFFFFFC7E0	02208009		 	mov		r1,r2
FFFFFFFFFFFFC7E4	BE04FEEF		 	loop	r9,btos3
                  	           		 ; the last four digits
FFFFFFFFFFFFC7E8	02A08009		 	mov		r1,r10	; get back r2
FFFFFFFFFFFFC7EC	31FFF1CC		 	call	BCDToAscii
FFFFFFFFFFFFC7F0	E2000003		 	setlo	r8,#3
FFFFFFFFFFFFC7F4	           		 btos2:
FFFFFFFFFFFFC7F4	141180FF		 	andi	r3,r1,#0xff
FFFFFFFFFFFFC7F8	6A858C10		 	sb		r3,[r8+r11]
FFFFFFFFFFFFC7FC	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFC800	BE047FAF		 	loop	r8,btos2
FFFFFFFFFFFFC804	60B00014		 	sb		r0,20[r11]	; null terminate
FFFFFFFFFFFFC808	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFC80C	47E38008		 	lw		r7,8[sp]
FFFFFFFFFFFFC810	47E40010		 	lw		r8,16[sp]
FFFFFFFFFFFFC814	47E48018		 	lw		r9,24[sp]
FFFFFFFFFFFFC818	47E50020		 	lw		r10,32[sp]
FFFFFFFFFFFFC81C	47E58028		 	lw		r11,40[sp]
FFFFFFFFFFFFC820	47EF8030		 	lw		lr,48[sp]
FFFFFFFFFFFFC824	37EF8038		 	ret		#56
                  	           		 
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; System Monitor Program
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFC828	           		 Monitor:
FFFFFFFFFFFFC828	E6BEFFF8		; SETLO
FFFFFFFFFFFFC82C	6A0D782D		 	lea		sp,STACKTOP0	; top of stack; reset the stack pointer
FFFFFFFFFFFFC830	6000141C		 	sb		r0,KeybdEcho	; turn off keyboard echo
FFFFFFFFFFFFC834	           		 PromptLn:
FFFFFFFFFFFFC834	31FFF135		 	call	CRLF
FFFFFFFFFFFFC838	E0400024		 	setlo	r1,#'$'
FFFFFFFFFFFFC83C	31FFF07F		 	call	DisplayChar
                  	           		 
                  	           		 ; Get characters until a CR is keyed
                  	           		 ;
FFFFFFFFFFFFC840	           		 Prompt3:
                  	           		 ;	lw		r1,#2			; get keyboard character
                  	           		 ;	syscall	#417
FFFFFFFFFFFFC840	31FFEF07		 	call	KeybdGetChar
FFFFFFFFFFFFC844	B01FFFFF		 	beqi	r1,#-1,Prompt3	; wait for a character
FFFFFFFFFFFFC848	B010030D		 	beqi	r1,#CR,Prompt1
FFFFFFFFFFFFC84C	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFC850	BE007F8A		 	bra		Prompt3
                  	           		 
                  	           		 ; Process the screen line that the CR was keyed on
                  	           		 ;
FFFFFFFFFFFFC854	           		 Prompt1:
FFFFFFFFFFFFC854	60001418		 	sb		r0,CursorCol	; go back to the start of the line
FFFFFFFFFFFFC858	31FFF06F		 	call	CalcScreenLoc	; r1 = screen memory location
FFFFFFFFFFFFC85C	02118009		 	mov		r3,r1
FFFFFFFFFFFFC860	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC864	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC868	31FFF06B		 	call	ScreenToAscii
FFFFFFFFFFFFC86C	B2100424		 	bnei	r1,#'$',Prompt2	; skip over '$' prompt character
FFFFFFFFFFFFC870	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC874	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC878	31FFF06B		 	call	ScreenToAscii
                  	           		 
                  	           		 ; Dispatch based on command character
                  	           		 ;
FFFFFFFFFFFFC87C	           		 Prompt2:
FFFFFFFFFFFFC87C	B0106A3A		 	beqi	r1,#':',Editmem		; $: - edit memory
FFFFFFFFFFFFC880	B0107C44		 	beqi	r1,#'D',Dumpmem		; $D - dump memory
FFFFFFFFFFFFC884	B0109446		 	beqi	r1,#'F',Fillmem		; $F - fill memory
FFFFFFFFFFFFC888	           		 Prompt7:
FFFFFFFFFFFFC888	B2100242		 	bnei	r1,#'B',Prompt4		; $B - start tiny basic
FFFFFFFFFFFFC88C	33FFF7E0		 	jmp		CSTART
FFFFFFFFFFFFC890	           		 Prompt4:
FFFFFFFFFFFFC890	B0106F4A		 	beqi	r1,#'J',ExecuteCode	; $J - execute code
FFFFFFFFFFFFC894	B210024C		 	bnei	r1,#'L',Prompt9	; $L - load S19 file
FFFFFFFFFFFFC898	33FFF297		 	jmp		LoadSector
FFFFFFFFFFFFC89C	           		 Prompt9:
FFFFFFFFFFFFC89C	B210043F		 	bnei	r1,#'?',Prompt10	; $? - display help
FFFFFFFFFFFFC8A0	9A00C910		 	lea		r1,HelpMsg
FFFFFFFFFFFFC8A4	31FFF122		 	call	DisplayString
FFFFFFFFFFFFC8A8	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFC8AC	           		 Prompt10:
FFFFFFFFFFFFC8AC	B0100C43		 	beqi	r1,#'C',TestCLS		; $C - clear screen
FFFFFFFFFFFFC8B0	B2100252		 	bnei	r1,#'R',Prompt12
FFFFFFFFFFFFC8B4	33FFF235		 	jmp		RandomLinesCall
FFFFFFFFFFFFC8B8	           		 Prompt12:
FFFFFFFFFFFFC8B8	B2100249		 	bnei	r1,#'I',Prompt13
FFFFFFFFFFFFC8BC	33FFF528		 	jmp		Invaders
FFFFFFFFFFFFC8C0	           		 Prompt13:
FFFFFFFFFFFFC8C0	B2100250		 	bnei	r1,#'P',Prompt14
FFFFFFFFFFFFC8C4	33FFF411		 	jmp		Piano
FFFFFFFFFFFFC8C8	           		 Prompt14:
FFFFFFFFFFFFC8C8	B2100254		 	bnei	r1,#'T',Prompt15
FFFFFFFFFFFFC8CC	31FFEF53		 	call	tmp_read
FFFFFFFFFFFFC8D0	           		 Prompt15:
FFFFFFFFFFFFC8D0	33FFF20A		 	jmp		Monitor
                  	           		 
FFFFFFFFFFFFC8D4	           		 RandomLinesCall:
FFFFFFFFFFFFC8D4	31FFF374		 	call	RandomLines
FFFFFFFFFFFFC8D8	33FFF20A		 	jmp		Monitor
                  	           		 
FFFFFFFFFFFFC8DC	           		 TestCLS:
FFFFFFFFFFFFC8DC	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC8E0	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC8E4	31FFF06B		 	call	ScreenToAscii
FFFFFFFFFFFFC8E8	B21FD04C		 	bnei	r1,#'L',Monitor
FFFFFFFFFFFFC8EC	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC8F0	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC8F4	31FFF06B		 	call	ScreenToAscii
FFFFFFFFFFFFC8F8	B21FCC53		 	bnei	r1,#'S',Monitor
FFFFFFFFFFFFC8FC	31FFF011		 	call	ClearScreen
FFFFFFFFFFFFC900	60001418		 	sb		r0,CursorCol
FFFFFFFFFFFFC904	60001417		 	sb		r0,CursorRow
FFFFFFFFFFFFC908	31FFF06F		 	call	CalcScreenLoc
FFFFFFFFFFFFC90C	33FFF20A		 	jmp		Monitor
                  	           		 	
FFFFFFFFFFFFC910	           		 HelpMsg:
FFFFFFFFFFFFC910 70736944203D203F	 	db	"? = Display help",CR,LF
FFFFFFFFFFFFC918 706C65682079616C
FFFFFFFFFFFFC920 203D20534C430A0D	 	db	"CLS = clear screen",CR,LF
FFFFFFFFFFFFC928 6373207261656C63
FFFFFFFFFFFFC930 203A0A0D6E656572	 	db	": = Edit memory bytes",CR,LF
FFFFFFFFFFFFC938 6D2074696445203D
FFFFFFFFFFFFC940 79622079726F6D65
FFFFFFFFFFFFC948 3D204C0A0D736574	 	db	"L = Load S19 file",CR,LF
FFFFFFFFFFFFC950 31532064616F4C20
FFFFFFFFFFFFC958 0A0D656C69662039
FFFFFFFFFFFFC960 7C487C437C425B44	 	db	"D[B|C|H|W] = Dump memory",CR,LF
FFFFFFFFFFFFC968 6D7544203D205D57
FFFFFFFFFFFFC970 79726F6D656D2070
FFFFFFFFFFFFC978 7C437C425B460A0D	 	db	"F[B|C|H|W] = Fill memory",CR,LF
FFFFFFFFFFFFC980 46203D205D577C48
FFFFFFFFFFFFC988 6F6D656D206C6C69
FFFFFFFFFFFFC990 203D20420A0D7972	 	db	"B = start tiny basic",CR,LF
FFFFFFFFFFFFC998 6974207472617473
FFFFFFFFFFFFC9A0 636973616220796E
FFFFFFFFFFFFC9A8 754A203D204A0A0D	 	db	"J = Jump to code",CR,LF
FFFFFFFFFFFFC9B0 6F63206F7420706D
FFFFFFFFFFFFC9B8 203D20490A0D6564	 	db	"I = Invaders",CR,LF
FFFFFFFFFFFFC9C0 7372656461766E49
FFFFFFFFFFFFC9C8 6152203D20520A0D	 	db	"R = Random lines",CR,LF
FFFFFFFFFFFFC9D0 6E696C206D6F646E
FFFFFFFFFFFFC9D8 203D20540A0D7365	 	db	"T = get temperature",CR,LF
FFFFFFFFFFFFC9E0 706D657420746567
FFFFFFFFFFFFC9E8 0D65727574617265
FFFFFFFFFFFFC9F0 616950203D20500A	 	db	"P = Piano",CR,LF,0
FFFFFFFFFFFFC9F8 000000000A0D6F6E	 	align	4
FFFFFFFFFFFFCA00	           		 	align	4
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Ignore blanks in the input
                  	           		 ; r3 = text pointer
                  	           		 ; r1 destroyed
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCA00	           		 ignBlanks:
FFFFFFFFFFFFCA00	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCA04	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFCA08	           		 ignBlanks1:
FFFFFFFFFFFFCA08	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFCA0C	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFCA10	31FFF06B		 	call	ScreenToAscii
FFFFFFFFFFFFCA14	B01FFD20		 	beqi	r1,#' ',ignBlanks1
FFFFFFFFFFFFCA18	0E318002		 	subui	r3,r3,#2
FFFFFFFFFFFFCA1C	47EF8000		 	lw		r31,[sp]
FFFFFFFFFFFFCA20	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Edit memory byte(s).
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCA24	           		 EditMem:
FFFFFFFFFFFFCA24	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCA28	31FFF2D4		 	call	GetHexNumber
FFFFFFFFFFFFCA2C	04101409		 	or		r5,r1,r0
FFFFFFFFFFFFCA30	E1000007		 	setlo	r4,#7
FFFFFFFFFFFFCA34	           		 edtmem1:
FFFFFFFFFFFFCA34	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCA38	31FFF2D4		 	call	GetHexNumber
FFFFFFFFFFFFCA3C	60508000		 	sb		r1,[r5]
FFFFFFFFFFFFCA40	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFCA44	BE027F8F		 	loop	r4,edtmem1
FFFFFFFFFFFFCA48	33FFF20A		 	jmp		Monitor
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Execute code at the specified address.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCA4C	           		 ExecuteCode:
FFFFFFFFFFFFCA4C	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCA50	31FFF2D4		 	call	GetHexNumber
FFFFFFFFFFFFCA54	341F8000		 	jal		r31,[r1]
FFFFFFFFFFFFCA58	33FFF20A		 	jmp     Monitor
                  	           		 
FFFFFFFFFFFFCA5C	           		 LoadSector:
FFFFFFFFFFFFCA5C	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCA60	31FFF2D4		 	call	GetHexNumber
FFFFFFFFFFFFCA64	16013800		 	lw		r2,#0x3800
FFFFFFFFFFFFCA68	31FFF56D		 	call	spi_read_sector
FFFFFFFFFFFFCA6C	33FFF20A		 	jmp		Monitor
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Do a memory dump of the requested location.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCA70	           		 DumpMem:
FFFFFFFFFFFFCA70	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFCA74	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFCA78	31FFF06B		 	call	ScreenToAscii
FFFFFFFFFFFFCA7C	02130009		 	mov		r6,r1			; r6 = fill type character
FFFFFFFFFFFFCA80	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCA84	31FFF2D4		 	call	GetHexNumber	; get start address of dump
FFFFFFFFFFFFCA88	02110009		 	mov		r2,r1
FFFFFFFFFFFFCA8C	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCA90	31FFF2D4		 	call	GetHexNumber	; get number of bytes to dump
FFFFFFFFFFFFCA94	06108601		 	shrui	r1,r1,#3		; 1/8 as many dump rows
FFFFFFFFFFFFCA98	B2100200		 	bnei	r1,#0,Dumpmem2
FFFFFFFFFFFFCA9C	16008001		 	lw		r1,#1			; dump at least one row
FFFFFFFFFFFFCAA0	           		 Dumpmem2:
FFFFFFFFFFFFCAA0	31FFF135		 	call	CRLF
FFFFFFFFFFFFCAA4	B0600857		 	beqi	r6,#'W',DumpmemW
                  	           		 ;	beqi	r6,#'H',DumpmemH
FFFFFFFFFFFFCAA8	B0600443		 	beqi	r6,#'C',DumpmemC
FFFFFFFFFFFFCAAC	           		 DumpmemB:
FFFFFFFFFFFFCAAC	31FFF175		 	call	DisplayMemB
FFFFFFFFFFFFCAB0	BE00FFEF		 	loop	r1,DumpmemB
FFFFFFFFFFFFCAB4	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFCAB8	           		 DumpmemC:
FFFFFFFFFFFFCAB8	31FFF189		 	call	DisplayMemC
FFFFFFFFFFFFCABC	BE00FFEF		 	loop	r1,DumpmemC
FFFFFFFFFFFFCAC0	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFCAC4	           		 DumpmemW:
FFFFFFFFFFFFCAC4	31FFF19D		 	call	DisplayMemW
FFFFFFFFFFFFCAC8	BE00FFEF		 	loop	r1,DumpmemW
FFFFFFFFFFFFCACC	33FFF20A		 	jmp		Monitor
                  	           		 
                  	           		 ;	call	DisplayMem
                  	           		 ;	call	DisplayMem
                  	           		 ;	call	DisplayMem
                  	           		 ;	call	DisplayMem
                  	           		 ;	call	DisplayMem
                  	           		 ;	call	DisplayMem
                  	           		 ;	call	DisplayMem
FFFFFFFFFFFFCAD0	BE006ACA		 	bra		Monitor
                  	           		 
FFFFFFFFFFFFCAD4	           		 Fillmem:
FFFFFFFFFFFFCAD4	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFCAD8	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFCADC	31FFF06B		 	call	ScreenToAscii
FFFFFFFFFFFFCAE0	02130009		 	mov		r6,r1			; r6 = fill type character
FFFFFFFFFFFFCAE4	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCAE8	31FFF2D4		 	call	GetHexNumber	; get start address of dump
FFFFFFFFFFFFCAEC	02110009		 	mov		r2,r1
FFFFFFFFFFFFCAF0	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCAF4	31FFF2D4		 	call	GetHexNumber	; get number of bytes to fill
FFFFFFFFFFFFCAF8	02128009		 	mov		r5,r1
FFFFFFFFFFFFCAFC	31FFF280		 	call	ignBlanks
FFFFFFFFFFFFCB00	31FFF2D4		 	call	GetHexNumber	; get the fill byte
FFFFFFFFFFFFCB04	B0600743		 	beqi	r6,#'C',FillmemC
FFFFFFFFFFFFCB08	B0600A48		 	beqi	r6,#'H',FillmemH
FFFFFFFFFFFFCB0C	B0600D57		 	beqi	r6,#'W',FillmemW
FFFFFFFFFFFFCB10	           		 FillmemB:
FFFFFFFFFFFFCB10	60208000		 	sb		r1,[r2]
FFFFFFFFFFFFCB14	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFCB18	BE02FFCF		 	loop	r5,FillmemB
FFFFFFFFFFFFCB1C	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFCB20	           		 FillmemC:
FFFFFFFFFFFFCB20	62208000		 	sc		r1,[r2]
FFFFFFFFFFFFCB24	0A210002		 	addui	r2,r2,#2
FFFFFFFFFFFFCB28	BE02FFCF		 	loop	r5,FillmemC
FFFFFFFFFFFFCB2C	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFCB30	           		 FillmemH:
FFFFFFFFFFFFCB30	64208000		 	sh		r1,[r2]
FFFFFFFFFFFFCB34	0A210004		 	addui	r2,r2,#4
FFFFFFFFFFFFCB38	BE02FFCF		 	loop	r5,FillmemH
FFFFFFFFFFFFCB3C	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFCB40	           		 FillmemW:
FFFFFFFFFFFFCB40	66208000		 	sw		r1,[r2]
FFFFFFFFFFFFCB44	0A210008		 	addui	r2,r2,#8
FFFFFFFFFFFFCB48	BE02FFCF		 	loop	r5,FillmemW
FFFFFFFFFFFFCB4C	33FFF20A		 	jmp		Monitor
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Get a hexidecimal number. Maximum of sixteen digits.
                  	           		 ; R3 = text pointer (updated)
                  	           		 ; R1 = hex number
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCB50	           		 GetHexNumber:
FFFFFFFFFFFFCB50	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFCB54	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFCB58	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFCB5C	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFCB60	E0800000		 	setlo	r2,#0
FFFFFFFFFFFFCB64	E100000F		 	setlo	r4,#15
FFFFFFFFFFFFCB68	           		 gthxn2:
FFFFFFFFFFFFCB68	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFCB6C	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFCB70	31FFF06B		 	call	ScreenToAscii
FFFFFFFFFFFFCB74	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCB78	B01005FF		 	beqi	r1,#-1,gthxn1
FFFFFFFFFFFFCB7C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCB80	1410800F		 	andi	r1,r1,#0x0f
FFFFFFFFFFFFCB84	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCB88	BE027F0F		 	loop	r4,gthxn2
FFFFFFFFFFFFCB8C	           		 gthxn1:
FFFFFFFFFFFFCB8C	02208009		 	mov		r1,r2
FFFFFFFFFFFFCB90	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFCB94	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFCB98	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFCB9C	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                  	           		 ; to a hex nybble.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCBA0	           		 AsciiToHexNybble:
FFFFFFFFFFFFCBA0	A8100E30		 	bltui	r1,#'0',gthx3
FFFFFFFFFFFFCBA4	AE100339		 	bgtui	r1,#'9',gthx5
FFFFFFFFFFFFCBA8	0E108030		 	subui	r1,r1,#'0'
FFFFFFFFFFFFCBAC	37EF8000		 	ret
FFFFFFFFFFFFCBB0	           		 gthx5:
FFFFFFFFFFFFCBB0	A8100A41		 	bltui	r1,#'A',gthx3
FFFFFFFFFFFFCBB4	AE100446		 	bgtui	r1,#'F',gthx6
FFFFFFFFFFFFCBB8	0E108041		 	subui	r1,r1,#'A'
FFFFFFFFFFFFCBBC	0A10800A		 	addui	r1,r1,#10
FFFFFFFFFFFFCBC0	37EF8000		 	ret
FFFFFFFFFFFFCBC4	           		 gthx6:
FFFFFFFFFFFFCBC4	A8100561		 	bltui	r1,#'a',gthx3
FFFFFFFFFFFFCBC8	AE100466		 	bgtui	r1,#'f',gthx3
FFFFFFFFFFFFCBCC	0E108061		 	subui	r1,r1,#'a'
FFFFFFFFFFFFCBD0	0A10800A		 	addui	r1,r1,#10
FFFFFFFFFFFFCBD4	37EF8000		 	ret
FFFFFFFFFFFFCBD8	           		 gthx3:
FFFFFFFFFFFFCBD8	E07FFFFF		 	setlo	r1,#-1		; not a hex number
FFFFFFFFFFFFCBDC	37EF8000		 	ret
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Load an S19 format file
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFCBE0	           		 LoadS19:
FFFFFFFFFFFFCBE0	BE00006A		 	bra		ProcessRec
FFFFFFFFFFFFCBE4	           		 NextRec:
FFFFFFFFFFFFCBE4	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCBE8	B21FFF0A		 	bne		r1,#LF,NextRec
FFFFFFFFFFFFCBEC	           		 ProcessRec:
FFFFFFFFFFFFCBEC	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCBF0	B01F0E1A		 	beqi	r1,#26,Monitor	; CTRL-Z ?
FFFFFFFFFFFFCBF4	B21FFC53		 	bnei	r1,#'S',NextRec
FFFFFFFFFFFFCBF8	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCBFC	A01FFA30		 	blt		r1,#'0',NextRec
FFFFFFFFFFFFCC00	A61FF939		 	bgt		r1,#'9',NextRec
FFFFFFFFFFFFCC04	04101009		 	or		r4,r1,r0		; r4 = record type
FFFFFFFFFFFFCC08	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCC0C	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCC10	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFCC14	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCC18	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCC1C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCC20	04208809		 	or		r2,r2,r1		; r2 = byte count
FFFFFFFFFFFFCC24	04208C09		 	or		r3,r2,r1		; r3 = byte count
FFFFFFFFFFFFCC28	B04FEF30		 	beqi	r4,#'0',NextRec	; manufacturer ID record, ignore
FFFFFFFFFFFFCC2C	B0401E31		 	beqi	r4,#'1',ProcessS1
FFFFFFFFFFFFCC30	B0401F32		 	beqi	r4,#'2',ProcessS2
FFFFFFFFFFFFCC34	B0402033		 	beqi	r4,#'3',ProcessS3
FFFFFFFFFFFFCC38	B04FEB35		 	beqi	r4,#'5',NextRec	; record count record, ignore
FFFFFFFFFFFFCC3C	B0402037		 	beqi	r4,#'7',ProcessS7
FFFFFFFFFFFFCC40	B0402238		 	beqi	r4,#'8',ProcessS8
FFFFFFFFFFFFCC44	B0402439		 	beqi	r4,#'9',ProcessS9
FFFFFFFFFFFFCC48	BE007CEA		 	bra		NextRec
                  	           		 
FFFFFFFFFFFFCC4C	           		 pcssxa:
FFFFFFFFFFFFCC4C	143180FF		 	andi	r3,r3,#0xff
FFFFFFFFFFFFCC50	0E318001		 	subui	r3,r3,#1		; one less for loop
FFFFFFFFFFFFCC54	           		 pcss1a:
FFFFFFFFFFFFCC54	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCC58	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCC5C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCC60	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCC64	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCC68	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCC6C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCC70	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCC74	60510000		 	sb		r2,[r5]
FFFFFFFFFFFFCC78	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFCC7C	BE01FECF		 	loop	r3,pcss1a
                  	           		 ; Get the checksum byte
FFFFFFFFFFFFCC80	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCC84	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCC88	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCC8C	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCC90	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCC94	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCC98	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCC9C	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCCA0	BE007A2A		 	bra		NextRec
                  	           		 
FFFFFFFFFFFFCCA4	           		 ProcessS1:
FFFFFFFFFFFFCCA4	31FFF338		 	call	S19Get16BitAddress
FFFFFFFFFFFFCCA8	BE007D2A		 	bra		pcssxa
FFFFFFFFFFFFCCAC	           		 ProcessS2:
FFFFFFFFFFFFCCAC	31FFF33E		 	call	S19Get24BitAddress
FFFFFFFFFFFFCCB0	BE007CEA		 	bra		pcssxa
FFFFFFFFFFFFCCB4	           		 ProcessS3:
FFFFFFFFFFFFCCB4	31FFF344		 	call	S19Get32BitAddress
FFFFFFFFFFFFCCB8	BE007CAA		 	bra		pcssxa
FFFFFFFFFFFFCCBC	           		 ProcessS7:
FFFFFFFFFFFFCCBC	31FFF344		 	call	S19Get32BitAddress
FFFFFFFFFFFFCCC0	66028000		 	sw		r5,S19StartAddress
FFFFFFFFFFFFCCC4	BE005B2A		 	bra		Monitor
FFFFFFFFFFFFCCC8	           		 ProcessS8:
FFFFFFFFFFFFCCC8	31FFF33E		 	call	S19Get24BitAddress
FFFFFFFFFFFFCCCC	66028000		 	sw		r5,S19StartAddress
FFFFFFFFFFFFCCD0	BE005ACA		 	bra		Monitor
FFFFFFFFFFFFCCD4	           		 ProcessS9:
FFFFFFFFFFFFCCD4	31FFF338		 	call	S19Get16BitAddress
FFFFFFFFFFFFCCD8	66028000		 	sw		r5,S19StartAddress
FFFFFFFFFFFFCCDC	33FFF20A		 	jmp		Monitor
                  	           		 
FFFFFFFFFFFFCCE0	           		 S19Get16BitAddress:
FFFFFFFFFFFFCCE0	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCCE4	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFCCE8	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCCEC	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCCF0	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFCCF4	BE00038A		 	bra		S1932b
                  	           		 
FFFFFFFFFFFFCCF8	           		 S19Get24BitAddress:
FFFFFFFFFFFFCCF8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCCFC	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFCD00	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD04	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD08	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFCD0C	BE0001CA		 	bra		S1932a
                  	           		 
FFFFFFFFFFFFCD10	           		 S19Get32BitAddress:
FFFFFFFFFFFFCD10	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCD14	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFCD18	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD1C	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD20	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFCD24	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD28	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD2C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCD30	04110809		 	or		r2,r1,r2
FFFFFFFFFFFFCD34	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD38	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD3C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCD40	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCD44	           		 S1932a:
FFFFFFFFFFFFCD44	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD48	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD4C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCD50	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCD54	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD58	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD5C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCD60	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCD64	           		 S1932b:
FFFFFFFFFFFFCD64	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD68	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD6C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCD70	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCD74	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD78	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD7C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCD80	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCD84	31FFF36A		 	call	sGetChar
FFFFFFFFFFFFCD88	31FFF2E8		 	call	AsciiToHexNybble
FFFFFFFFFFFFCD8C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFCD90	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFCD94	0442100A		 	xor		r4,r4,r4
FFFFFFFFFFFFCD98	04201409		 	or		r5,r2,r0
FFFFFFFFFFFFCD9C	47EF8000		 	lw		r31,[sp]
FFFFFFFFFFFFCDA0	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFCDA4	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Get a character from auxillary input, checking the keyboard status for a
                  	           		 ; CTRL-C
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCDA8	           		 sGetChar:
FFFFFFFFFFFFCDA8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCDAC	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFCDB0	           		 sgc2:
FFFFFFFFFFFFCDB0	31FFEF1C		 	call	KeybdCheckForKey
FFFFFFFFFFFFCDB4	BE103C08		 	beq		r1,r0,sgc1
FFFFFFFFFFFFCDB8	31FFEF07		 	call	KeybdGetchar
FFFFFFFFFFFFCDBC	B01E9B00		 	beqi	r1,#CRTLC,Monitor
FFFFFFFFFFFFCDC0	           		 sgc1:
FFFFFFFFFFFFCDC0	31FFFD9D		 	call	AUXIN
FFFFFFFFFFFFCDC4	BE107F62		 	ble		r1,r0,sgc2
FFFFFFFFFFFFCDC8	47EF8000		 	lw		r31,[sp]
FFFFFFFFFFFFCDCC	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Draw random lines on the bitmap screen.
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCDD0	           		 RandomLines:
FFFFFFFFFFFFCDD0	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFCDD4	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFCDD8	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFCDDC	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFCDE0	660020E8		 	sw		r0,ctx3start	; prevent restarting context over and over again
FFFFFFFFFFFFCDE4	           		 rl5:
FFFFFFFFFFFFCDE4	00000050		 	gran
FFFFFFFFFFFFCDE8	020088A8		 	mfspr	r1,rand			; select a random color
FFFFFFFFFFFFCDEC	E69AE000		; SETLO
FFFFFFFFFFFFCDF0	EE800003		; SETMID
FFFFFFFFFFFFCDF4	6A0D042A		 	outh	r1,GACCEL
FFFFFFFFFFFFCDF8	           		 rl1:						; random X0
FFFFFFFFFFFFCDF8	00000050		 	gran
FFFFFFFFFFFFCDFC	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFCE00	16018554		 	lw		r3,#1364
FFFFFFFFFFFFCE04	0411841C		 	modu	r1,r1,r3
FFFFFFFFFFFFCE08	E69AE008		; SETLO
FFFFFFFFFFFFCE0C	EE800003		; SETMID
FFFFFFFFFFFFCE10	6A0D042A		 	outh	r1,GACCEL+8
FFFFFFFFFFFFCE14	           		 rl2:						; random X1
FFFFFFFFFFFFCE14	00000050		 	gran
FFFFFFFFFFFFCE18	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFCE1C	16018554		 	lw		r3,#1364
FFFFFFFFFFFFCE20	0411841C		 	modu	r1,r1,r3
FFFFFFFFFFFFCE24	E69AE010		; SETLO
FFFFFFFFFFFFCE28	EE800003		; SETMID
FFFFFFFFFFFFCE2C	6A0D042A		 	outh	r1,GACCEL+16
FFFFFFFFFFFFCE30	           		 rl3:						; random Y0
FFFFFFFFFFFFCE30	00000050		 	gran
FFFFFFFFFFFFCE34	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFCE38	16018300		 	lw		r3,#768
FFFFFFFFFFFFCE3C	0411841C		 	modu	r1,r1,r3
FFFFFFFFFFFFCE40	E69AE00C		; SETLO
FFFFFFFFFFFFCE44	EE800003		; SETMID
FFFFFFFFFFFFCE48	6A0D042A		 	outh	r1,GACCEL+12
FFFFFFFFFFFFCE4C	           		 rl4:						; random Y1
FFFFFFFFFFFFCE4C	00000050		 	gran
FFFFFFFFFFFFCE50	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFCE54	16018300		 	lw		r3,#768
FFFFFFFFFFFFCE58	0411841C		 	modu	r1,r1,r3
FFFFFFFFFFFFCE5C	E69AE014		; SETLO
FFFFFFFFFFFFCE60	EE800003		; SETMID
FFFFFFFFFFFFCE64	6A0D042A		 	outh	r1,GACCEL+20
FFFFFFFFFFFFCE68	E0400002		 	setlo	r1,#2			; draw line command
FFFFFFFFFFFFCE6C	E69AE03C		; SETLO
FFFFFFFFFFFFCE70	EE800003		; SETMID
FFFFFFFFFFFFCE74	6A0D042A		 	outh	r1,GACCEL+60
FFFFFFFFFFFFCE78	           		 rl8:
                  	           		 ;	call	KeybdGetChar
                  	           		 ;	beqi	r1,#CTRLC,rl7
FFFFFFFFFFFFCE78	E69AE038		; SETLO
FFFFFFFFFFFFCE7C	EE800003		; SETMID
FFFFFFFFFFFFCE80	6A0D0421		 	inch	r1,GACCEL+56	; ensure controller is in IDLE state
FFFFFFFFFFFFCE84	BE107FA9		 	bne		r1,r0,rl8
FFFFFFFFFFFFCE88	BE007AEA		 	bra		rl5
FFFFFFFFFFFFCE8C	           		 rl7:
FFFFFFFFFFFFCE8C	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFCE90	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFCE94	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFCE98	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Initialize sprite image caches with random data.
                  	           		 ;--------------------------------------------------------------------------
FFFFFFFFFFFFCE9C	           		 RandomizeSprram:
FFFFFFFFFFFFCE9C	E6980000		; SETLO
FFFFFFFFFFFFCEA0	EE800003		; SETMID
FFFFFFFFFFFFCEA4	6A0D082D		 	lea		r2,SPRRAM
FFFFFFFFFFFFCEA8	E10037FF		 	setlo	r4,#14335		; number of chars to initialize
FFFFFFFFFFFFCEAC	           		 rsr1:
FFFFFFFFFFFFCEAC	00000050		 	gran
FFFFFFFFFFFFCEB0	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFCEB4	92208000		 	outc	r1,[r2]
FFFFFFFFFFFFCEB8	0A210002		 	addui	r2,r2,#2
FFFFFFFFFFFFCEBC	BE027F8F		 	loop	r4,rsr1
FFFFFFFFFFFFCEC0	37EF8000		 	ret
                  	           		 	
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Setup the AC97/LM4550 audio controller. Check keyboard for a CTRL-C
                  	           		 ; interrupt which may be necessary if the audio controller isn't 
                  	           		 ; responding.
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCEC4	           		 SetupAC97:
FFFFFFFFFFFFCEC4	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFCEC8	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFCECC	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFCED0	           		 sac974:
FFFFFFFFFFFFCED0	E69C1026		; SETLO
FFFFFFFFFFFFCED4	EE800003		; SETMID
FFFFFFFFFFFFCED8	6A0D0029		 	outc	r0,AC97+0x26	; trigger a read of register 26 (status reg)
FFFFFFFFFFFFCEDC	           		 sac971:						; wait for status to register 0xF (all ready)
FFFFFFFFFFFFCEDC	31FFEF07		 	call	KeybdGetChar	; see if we needed to CTRL-C
FFFFFFFFFFFFCEE0	B0100A03		 	beqi	r1,#CTRLC,sac973
FFFFFFFFFFFFCEE4	E69C1068		; SETLO
FFFFFFFFFFFFCEE8	EE800003		; SETMID
FFFFFFFFFFFFCEEC	6A0D0421		 	inch	r1,AC97+0x68	; wait for dirty bit to clear
FFFFFFFFFFFFCEF0	BE107F69		 	bne		r1,r0,sac971
FFFFFFFFFFFFCEF4	E69C1026		; SETLO
FFFFFFFFFFFFCEF8	EE800003		; SETMID
FFFFFFFFFFFFCEFC	6A0D0421		 	inch	r1,AC97+0x26	; check status at reg h26, wait for
FFFFFFFFFFFFCF00	1410800F		 	andi	r1,r1,#0x0F		; analogue to be ready
FFFFFFFFFFFFCF04	B21FF30F		 	bnei	r1,#0x0F,sac974
FFFFFFFFFFFFCF08	           		 sac973:
FFFFFFFFFFFFCF08	E69C1002		; SETLO
FFFFFFFFFFFFCF0C	EE800003		; SETMID
FFFFFFFFFFFFCF10	6A0D0029		 	outc	r0,AC97+2		; master volume, 0db attenuation, mute off
FFFFFFFFFFFFCF14	E69C1004		; SETLO
FFFFFFFFFFFFCF18	EE800003		; SETMID
FFFFFFFFFFFFCF1C	6A0D0029		 	outc	r0,AC97+4		; headphone volume, 0db attenuation, mute off
FFFFFFFFFFFFCF20	E69C1018		; SETLO
FFFFFFFFFFFFCF24	EE800003		; SETMID
FFFFFFFFFFFFCF28	6A0D0029		 	outc	r0,AC97+0x18	; PCM gain (mixer) mute off, no attenuation
FFFFFFFFFFFFCF2C	E69C100A		; SETLO
FFFFFFFFFFFFCF30	EE800003		; SETMID
FFFFFFFFFFFFCF34	6A0D0029		 	outc	r0,AC97+0x0A	; mute PC beep
FFFFFFFFFFFFCF38	E07F8000		 	setlo	r1,#0x8000		; bypass 3D sound
FFFFFFFFFFFFCF3C	E69C1020		; SETLO
FFFFFFFFFFFFCF40	EE800003		; SETMID
FFFFFFFFFFFFCF44	6A0D0429		 	outc	r1,AC97+0x20
FFFFFFFFFFFFCF48	           		 sac972:
FFFFFFFFFFFFCF48	31FFEF07		 	call	KeybdGetChar
FFFFFFFFFFFFCF4C	B0100503		 	beqi	r1,#CTRLC,sac975
FFFFFFFFFFFFCF50	E69C1068		; SETLO
FFFFFFFFFFFFCF54	EE800003		; SETMID
FFFFFFFFFFFFCF58	6A0D0421		 	inch	r1,AC97+0x68	; wait for dirty bits to clear
FFFFFFFFFFFFCF5C	BE107F69		 	bne		r1,r0,sac972	; wait a while for the settings to take effect
FFFFFFFFFFFFCF60	           		 sac975:
FFFFFFFFFFFFCF60	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFCF64	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFCF68	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Sound a 800 Hz beep
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFCF6C	           		 Beep:
FFFFFFFFFFFFCF6C	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFCF70	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFCF74	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFCF78	E0400008		 	setlo	r1,#8
FFFFFFFFFFFFCF7C	E69C0600		; SETLO
FFFFFFFFFFFFCF80	EE800003		; SETMID
FFFFFFFFFFFFCF84	6A0D0428		 	outb	r1,LED
FFFFFFFFFFFFCF88	1600800F		 	ori		r1,r0,#15		; master volume to max
FFFFFFFFFFFFCF8C	E6950080		; SETLO
FFFFFFFFFFFFCF90	EE800003		; SETMID
FFFFFFFFFFFFCF94	6A0D0429		 	outc	r1,PSG+128
FFFFFFFFFFFFCF98	1600B46E		 	ori		r1,r0,#13422	; 800Hz
FFFFFFFFFFFFCF9C	E6950000		; SETLO
FFFFFFFFFFFFCFA0	EE800003		; SETMID
FFFFFFFFFFFFCFA4	6A0D0429		 	outc	r1,PSGFREQ0
FFFFFFFFFFFFCFA8	E0400009		 	setlo	r1,#9
FFFFFFFFFFFFCFAC	E69C0600		; SETLO
FFFFFFFFFFFFCFB0	EE800003		; SETMID
FFFFFFFFFFFFCFB4	6A0D0428		 	outb	r1,LED
                  	           		 	; decay  (16.384 ms)2
                  	           		 	; attack (8.192 ms)1
                  	           		 	; release (1.024 s)A
                  	           		 	; sustain level C
FFFFFFFFFFFFCFB8	E07FCA12		 	setlo	r1,#0xCA12
FFFFFFFFFFFFCFBC	E6950006		; SETLO
FFFFFFFFFFFFCFC0	EE800003		; SETMID
FFFFFFFFFFFFCFC4	6A0D0429		 	outc	r1,PSGADSR0
FFFFFFFFFFFFCFC8	16009104		 	ori		r1,r0,#0x1104	; gate, output enable, triangle waveform
FFFFFFFFFFFFCFCC	E6950004		; SETLO
FFFFFFFFFFFFCFD0	EE800003		; SETMID
FFFFFFFFFFFFCFD4	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFCFD8	E6A625A0		; SETLO
FFFFFFFFFFFFCFDC	EE800000		; SETMID
FFFFFFFFFFFFCFE0	040D0409		 	ori		r1,r0,#2500000	; delay about 1s
FFFFFFFFFFFFCFE4	           		 beep1:
FFFFFFFFFFFFCFE4	BE00800F		 	loop	r1,beep1
FFFFFFFFFFFFCFE8	E040000D		 	setlo	r1,#13
FFFFFFFFFFFFCFEC	E69C0600		; SETLO
FFFFFFFFFFFFCFF0	EE800003		; SETMID
FFFFFFFFFFFFCFF4	6A0D0428		 	outb	r1,LED
FFFFFFFFFFFFCFF8	16008104		 	ori		r1,r0,#0x0104	; gate off, output enable, triangle waveform
FFFFFFFFFFFFCFFC	E6950004		; SETLO
FFFFFFFFFFFFD000	EE800003		; SETMID
FFFFFFFFFFFFD004	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFD008	E6A625A0		; SETLO
FFFFFFFFFFFFD00C	EE800000		; SETMID
FFFFFFFFFFFFD010	040D0409		 	ori		r1,r0,#2500000	; delay about 1s
FFFFFFFFFFFFD014	           		 beep2:
FFFFFFFFFFFFD014	BE00800F		 	loop	r1,beep2
FFFFFFFFFFFFD018	E0400010		 	setlo	r1,#16
FFFFFFFFFFFFD01C	E69C0600		; SETLO
FFFFFFFFFFFFD020	EE800003		; SETMID
FFFFFFFFFFFFD024	6A0D0428		 	outb	r1,LED
FFFFFFFFFFFFD028	16008000		 	ori		r1,r0,#0x0000	; gate off, output enable off, no waveform
FFFFFFFFFFFFD02C	E6950004		; SETLO
FFFFFFFFFFFFD030	EE800003		; SETMID
FFFFFFFFFFFFD034	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFD038	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFD03C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFD040	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; 
FFFFFFFFFFFFD044	           		 Piano:
FFFFFFFFFFFFD044	1600800F		 	ori		r1,r0,#15		; master volume to max
FFFFFFFFFFFFD048	E6950080		; SETLO
FFFFFFFFFFFFD04C	EE800003		; SETMID
FFFFFFFFFFFFD050	6A0D0429		 	outc	r1,PSG+128
FFFFFFFFFFFFD054	           		 playnt:
FFFFFFFFFFFFD054	31FFEF07		 	call	KeybdGetChar
FFFFFFFFFFFFD058	B01DF403		 	beqi	r1,#CTRLC,Monitor
FFFFFFFFFFFFD05C	B0100861		 	beqi	r1,#'a',playnt1a
FFFFFFFFFFFFD060	B0100A62		 	beqi	r1,#'b',playnt1b
FFFFFFFFFFFFD064	B0100C63		 	beqi	r1,#'c',playnt1c
FFFFFFFFFFFFD068	B0100E64		 	beqi	r1,#'d',playnt1d
FFFFFFFFFFFFD06C	B0101065		 	beqi	r1,#'e',playnt1e
FFFFFFFFFFFFD070	B0101266		 	beqi	r1,#'f',playnt1f
FFFFFFFFFFFFD074	B0101467		 	beqi	r1,#'g',playnt1g
FFFFFFFFFFFFD078	BE007EEA		 	bra		playnt
                  	           		 
FFFFFFFFFFFFD07C	           		 playnt1a:
FFFFFFFFFFFFD07C	E0401C31		 	setlo	r1,#7217
FFFFFFFFFFFFD080	31FFF434		 	call	Tone
FFFFFFFFFFFFD084	BE007E8A		 	bra		playnt
FFFFFFFFFFFFD088	           		 playnt1b:
FFFFFFFFFFFFD088	E0401FA5		 	setlo	r1,#8101
FFFFFFFFFFFFD08C	31FFF434		 	call	Tone
FFFFFFFFFFFFD090	BE007E2A		 	bra		playnt
FFFFFFFFFFFFD094	           		 playnt1c:
FFFFFFFFFFFFD094	E04010C3		 	setlo	r1,#4291
FFFFFFFFFFFFD098	31FFF434		 	call	Tone
FFFFFFFFFFFFD09C	BE007DCA		 	bra		playnt
FFFFFFFFFFFFD0A0	           		 playnt1d:
FFFFFFFFFFFFD0A0	E04012D1		 	setlo	r1,#4817
FFFFFFFFFFFFD0A4	31FFF434		 	call	Tone
FFFFFFFFFFFFD0A8	BE007D6A		 	bra		playnt
FFFFFFFFFFFFD0AC	           		 playnt1e:
FFFFFFFFFFFFD0AC	E040151F		 	setlo	r1,#5407
FFFFFFFFFFFFD0B0	31FFF434		 	call	Tone
FFFFFFFFFFFFD0B4	BE007D0A		 	bra		playnt
FFFFFFFFFFFFD0B8	           		 playnt1f:
FFFFFFFFFFFFD0B8	E0401660		 	setlo	r1,#5728
FFFFFFFFFFFFD0BC	31FFF434		 	call	Tone
FFFFFFFFFFFFD0C0	BE007CAA		 	bra		playnt
FFFFFFFFFFFFD0C4	           		 playnt1g:
FFFFFFFFFFFFD0C4	E040191E		 	setlo	r1,#6430
FFFFFFFFFFFFD0C8	31FFF434		 	call	Tone
FFFFFFFFFFFFD0CC	BE007C4A		 	bra		playnt
                  	           		 
FFFFFFFFFFFFD0D0	           		 Tone:
FFFFFFFFFFFFD0D0	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFD0D4	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFD0D8	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFD0DC	E6950000		; SETLO
FFFFFFFFFFFFD0E0	EE800003		; SETMID
FFFFFFFFFFFFD0E4	6A0D0429		 	outc	r1,PSGFREQ0
                  	           		 	; decay  (16.384 ms)2
                  	           		 	; attack (8.192 ms)1
                  	           		 	; release (1.024 s)A
                  	           		 	; sustain level C
FFFFFFFFFFFFD0E8	E07FCA12		 	setlo	r1,#0xCA12
FFFFFFFFFFFFD0EC	E6950006		; SETLO
FFFFFFFFFFFFD0F0	EE800003		; SETMID
FFFFFFFFFFFFD0F4	6A0D0429		 	outc	r1,PSGADSR0
FFFFFFFFFFFFD0F8	16009104		 	ori		r1,r0,#0x1104	; gate, output enable, triangle waveform
FFFFFFFFFFFFD0FC	E6950004		; SETLO
FFFFFFFFFFFFD100	EE800003		; SETMID
FFFFFFFFFFFFD104	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFD108	E683D090		; SETLO
FFFFFFFFFFFFD10C	040D0409		 	ori		r1,r0,#250000	; delay about 10ms
FFFFFFFFFFFFD110	           		 tone1:
FFFFFFFFFFFFD110	BE00800F		 	loop	r1,tone1
FFFFFFFFFFFFD114	16008104		 	ori		r1,r0,#0x0104	; gate off, output enable, triangle waveform
FFFFFFFFFFFFD118	E6950004		; SETLO
FFFFFFFFFFFFD11C	EE800003		; SETMID
FFFFFFFFFFFFD120	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFD124	E683D090		; SETLO
FFFFFFFFFFFFD128	040D0409		 	ori		r1,r0,#250000	; delay about 10ms
FFFFFFFFFFFFD12C	           		 tone2:
FFFFFFFFFFFFD12C	BE00800F		 	loop	r1,tone2
FFFFFFFFFFFFD130	16008000		 	ori		r1,r0,#0x0000	; gate off, output enable off, no waveform
FFFFFFFFFFFFD134	E6950004		; SETLO
FFFFFFFFFFFFD138	EE800003		; SETMID
FFFFFFFFFFFFD13C	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFD140	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFD144	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFD148	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
FFFFFFFFFFFFD14C	           		 SetupRasterIRQ:
FFFFFFFFFFFFD14C	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFD150	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFD154	E04000C8		 	setlo	r1,#200
FFFFFFFFFFFFD158	E69A0100		; SETLO
FFFFFFFFFFFFD15C	EE800003		; SETMID
FFFFFFFFFFFFD160	6A0D0429		 	outc	r1,RASTERIRQ
FFFFFFFFFFFFD164	E04000F0		 	setlo	r1,#240
FFFFFFFFFFFFD168	E69A0102		; SETLO
FFFFFFFFFFFFD16C	EE800003		; SETMID
FFFFFFFFFFFFD170	6A0D0429		 	outc	r1,RASTERIRQ+2
FFFFFFFFFFFFD174	E0400118		 	setlo	r1,#280
FFFFFFFFFFFFD178	E69A0104		; SETLO
FFFFFFFFFFFFD17C	EE800003		; SETMID
FFFFFFFFFFFFD180	6A0D0429		 	outc	r1,RASTERIRQ+4
FFFFFFFFFFFFD184	E0400140		 	setlo	r1,#320
FFFFFFFFFFFFD188	E69A0106		; SETLO
FFFFFFFFFFFFD18C	EE800003		; SETMID
FFFFFFFFFFFFD190	6A0D0429		 	outc	r1,RASTERIRQ+6
FFFFFFFFFFFFD194	E0400168		 	setlo	r1,#360
FFFFFFFFFFFFD198	E69A0108		; SETLO
FFFFFFFFFFFFD19C	EE800003		; SETMID
FFFFFFFFFFFFD1A0	6A0D0429		 	outc	r1,RASTERIRQ+8
FFFFFFFFFFFFD1A4	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFD1A8	37EF8008		 	ret		#8
                  	           		 
FFFFFFFFFFFFD1AC	           		 RasterIRQfn:
FFFFFFFFFFFFD1AC	E69A011E		; SETLO
FFFFFFFFFFFFD1B0	EE800003		; SETMID
FFFFFFFFFFFFD1B4	6A0D0421		 	inch	r1,RASTERIRQ+30		; get the raster compare register # (clears IRQ)
FFFFFFFFFFFFD1B8	B0100901		 	beqi	r1,#1,rirq1
FFFFFFFFFFFFD1BC	B0100802		 	beqi	r1,#2,rirq2
FFFFFFFFFFFFD1C0	B0100703		 	beqi	r1,#3,rirq3
FFFFFFFFFFFFD1C4	B0100604		 	beqi	r1,#4,rirq4
FFFFFFFFFFFFD1C8	B0100505		 	beqi	r1,#5,rirq5
FFFFFFFFFFFFD1CC	B0100406		 	beqi	r1,#6,rirq6
FFFFFFFFFFFFD1D0	B0100307		 	beqi	r1,#7,rirq7
FFFFFFFFFFFFD1D4	B0100208		 	beqi	r1,#8,rirq8
FFFFFFFFFFFFD1D8	37EF8000		 	ret
FFFFFFFFFFFFD1DC	           		 rirq1:
FFFFFFFFFFFFD1DC	           		 rirq2:
FFFFFFFFFFFFD1DC	           		 rirq3:
FFFFFFFFFFFFD1DC	           		 rirq4:
FFFFFFFFFFFFD1DC	           		 rirq5:
FFFFFFFFFFFFD1DC	           		 rirq6:
FFFFFFFFFFFFD1DC	           		 rirq7:
FFFFFFFFFFFFD1DC	           		 rirq8:
FFFFFFFFFFFFD1DC	1A108028		 	mului	r1,r1,#40
FFFFFFFFFFFFD1E0	0A1080CC		 	addui	r1,r1,#204
FFFFFFFFFFFFD1E4	E69AD002		; SETLO
FFFFFFFFFFFFD1E8	EE800003		; SETMID
FFFFFFFFFFFFD1EC	6A0D0429		 	outc	r1,SPRITEREGS+2
FFFFFFFFFFFFD1F0	E69AD012		; SETLO
FFFFFFFFFFFFD1F4	EE800003		; SETMID
FFFFFFFFFFFFD1F8	6A0D0429		 	outc	r1,SPRITEREGS+18
FFFFFFFFFFFFD1FC	E69AD022		; SETLO
FFFFFFFFFFFFD200	EE800003		; SETMID
FFFFFFFFFFFFD204	6A0D0429		 	outc	r1,SPRITEREGS+34
FFFFFFFFFFFFD208	E69AD032		; SETLO
FFFFFFFFFFFFD20C	EE800003		; SETMID
FFFFFFFFFFFFD210	6A0D0429		 	outc	r1,SPRITEREGS+50
FFFFFFFFFFFFD214	E69AD042		; SETLO
FFFFFFFFFFFFD218	EE800003		; SETMID
FFFFFFFFFFFFD21C	6A0D0429		 	outc	r1,SPRITEREGS+66
FFFFFFFFFFFFD220	E69AD052		; SETLO
FFFFFFFFFFFFD224	EE800003		; SETMID
FFFFFFFFFFFFD228	6A0D0429		 	outc	r1,SPRITEREGS+82
FFFFFFFFFFFFD22C	E69AD062		; SETLO
FFFFFFFFFFFFD230	EE800003		; SETMID
FFFFFFFFFFFFD234	6A0D0429		 	outc	r1,SPRITEREGS+98
FFFFFFFFFFFFD238	E69AD072		; SETLO
FFFFFFFFFFFFD23C	EE800003		; SETMID
FFFFFFFFFFFFD240	6A0D0429		 	outc	r1,SPRITEREGS+114
FFFFFFFFFFFFD244	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFD248	           		 DisplayDatetime:
FFFFFFFFFFFFD248	0FEF0030		 	subui	sp,sp,#48
FFFFFFFFFFFFD24C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFD250	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFD254	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFD258	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFD25C	67E28020		 	sw		r5,32[sp]
FFFFFFFFFFFFD260	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFD264	31FFEFF2		 	call	CursorOff
FFFFFFFFFFFFD268	16008003		 	lw		r1,#3				; get cursor position
FFFFFFFFFFFFD26C	0181CD17		 	syscall	#410
FFFFFFFFFFFFD270	02120009		 	mov		r4,r1				; r4 = row
FFFFFFFFFFFFD274	02228009		 	mov		r5,r2				; r5 = col
FFFFFFFFFFFFD278	16008002		 	lw		r1,#2				; set cursor position
FFFFFFFFFFFFD27C	1601002E		 	lw		r2,#46				; move cursor down to last display line
FFFFFFFFFFFFD280	16018040		 	lw		r3,#64
FFFFFFFFFFFFD284	0181CD17		 	syscall	#410
FFFFFFFFFFFFD288	16008001		 	lw		r1,#1				; get the snapshotted date and time
FFFFFFFFFFFFD28C	0181D017		 	syscall	#416
FFFFFFFFFFFFD290	31FFF169		 	call	DisplayWord			; display on screen
FFFFFFFFFFFFD294	16008002		 	lw		r1,#2				; restore cursor position
FFFFFFFFFFFFD298	02410009		 	mov		r2,r4				; r2 = row
FFFFFFFFFFFFD29C	02518009		 	mov		r3,r5				; r3 = col
FFFFFFFFFFFFD2A0	0181CD17		 	syscall	#410
FFFFFFFFFFFFD2A4	31FFEFF7		 	call	CursorOn
FFFFFFFFFFFFD2A8	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFD2AC	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFD2B0	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFD2B4	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFD2B8	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFD2BC	47E28020		 	lw		r5,32[sp]
FFFFFFFFFFFFD2C0	37EF8030		 	ret		#48
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
FFFFFFFFFFFFD2C4	           		 InitializeGame:
FFFFFFFFFFFFD2C4	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFD2C8	27F40000004		 	sm		[sp],r3/lr
FFFFFFFFFFFFD2CC	E0C00140		 	setlo	r3,#320
FFFFFFFFFFFFD2D0	62019508		 	sc		r3,Manpos
FFFFFFFFFFFFD2D4	62001500		 	sc		r0,Score
FFFFFFFFFFFFD2D8	60001510		 	sb		r0,MissileActive
FFFFFFFFFFFFD2DC	62001512		 	sc		r0,MissileX
FFFFFFFFFFFFD2E0	62001514		 	sc		r0,MissileY
FFFFFFFFFFFFD2E4	27740000004		 	lm		[sp],r3/lr
FFFFFFFFFFFFD2E8	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFD2EC	           		 DrawScore:
FFFFFFFFFFFFD2EC	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFD2F0	27F40000005		 	sm		[sp],r1/r3/lr
FFFFFFFFFFFFD2F4	E0C00001		 	setlo	r3,#1
FFFFFFFFFFFFD2F8	60019417		 	sb		r3,CursorRow
FFFFFFFFFFFFD2FC	E0C00028		 	setlo	r3,#40
FFFFFFFFFFFFD300	60019418		 	sb		r3,CursorCol
FFFFFFFFFFFFD304	40009500		 	lb		r1,Score
FFFFFFFFFFFFD308	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD30C	40009501		 	lb		r1,Score+1
FFFFFFFFFFFFD310	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD314	27740000005		 	lm		[sp],r1/r3/lr
FFFFFFFFFFFFD318	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFD31C	           		 DrawMissile:
FFFFFFFFFFFFD31C	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFD320	27F40000001		 	sm		[sp],r1/lr
FFFFFFFFFFFFD324	42009514		 	lc		r1,MissileY
FFFFFFFFFFFFD328	AC101402		 	bleu	r1,#2,MissileOff
FFFFFFFFFFFFD32C	42009512		 	lc		r1,MissileX
FFFFFFFFFFFFD330	06108601		 	shrui	r1,r1,#3
FFFFFFFFFFFFD334	60009418		 	sb		r1,CursorCol
FFFFFFFFFFFFD338	42009514		 	lc		r1,MissileY
FFFFFFFFFFFFD33C	60009417		 	sb		r1,CursorRow
FFFFFFFFFFFFD340	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFD344	62009514		 	sc		r1,MissileY
FFFFFFFFFFFFD348	E040005E		 	setlo	r1,#'^'
FFFFFFFFFFFFD34C	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD350	40009418		 	lb		r1,CursorCol
FFFFFFFFFFFFD354	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFD358	60009418		 	sb		r1,CursorCol
FFFFFFFFFFFFD35C	40009417		 	lb		r1,CursorRow
FFFFFFFFFFFFD360	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFD364	60009417		 	sb		r1,CursorRow
FFFFFFFFFFFFD368	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD36C	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD370	27740000001		 	lm		[sp],r1/lr
FFFFFFFFFFFFD374	37EF8010		 	ret		#16
FFFFFFFFFFFFD378	           		 MissileOff:
FFFFFFFFFFFFD378	60001510		 	sb		r0,MissileActive
FFFFFFFFFFFFD37C	42009512		 	lc		r1,MissileX
FFFFFFFFFFFFD380	06108601		 	shrui	r1,r1,#3
FFFFFFFFFFFFD384	60009418		 	sb		r1,CursorCol
FFFFFFFFFFFFD388	42009514		 	lc		r1,MissileY
FFFFFFFFFFFFD38C	60009417		 	sb		r1,CursorRow
FFFFFFFFFFFFD390	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD394	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD398	27740000001		 	lm		[sp],r1/lr
FFFFFFFFFFFFD39C	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFD3A0	           		 DrawMan:
FFFFFFFFFFFFD3A0	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFD3A4	27F40000005		 	sm		[sp],r1/r3/lr
FFFFFFFFFFFFD3A8	E0C0002E		 	setlo	r3,#46
FFFFFFFFFFFFD3AC	60019417		 	sb		r3,CursorRow
FFFFFFFFFFFFD3B0	42019508		 	lc		r3,Manpos
FFFFFFFFFFFFD3B4	06318601		 	shrui	r3,r3,#3
FFFFFFFFFFFFD3B8	60019418		 	sb		r3,CursorCol
FFFFFFFFFFFFD3BC	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD3C0	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD3C4	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFD3C8	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD3CC	E0400041		 	setlo	r1,#'A'
FFFFFFFFFFFFD3D0	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD3D4	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFD3D8	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD3DC	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD3E0	31FFF07F		 	call	DisplayChar
FFFFFFFFFFFFD3E4	27740000005		 	lm		[sp],r1/r3/lr
FFFFFFFFFFFFD3E8	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFD3EC	           		 DrawInvader:
FFFFFFFFFFFFD3EC	46018000		 	lw		r3,InvaderPos
FFFFFFFFFFFFD3F0	160080E9		 	lw		r1,#233
FFFFFFFFFFFFD3F4	62308000		 	sc		r1,[r3]
FFFFFFFFFFFFD3F8	160080F2		 	lw		r1,#242
FFFFFFFFFFFFD3FC	62308001		 	sc		r1,1[r3]
FFFFFFFFFFFFD400	160080DF		 	lw		r1,#223
FFFFFFFFFFFFD404	62308002		 	sc		r1,2[r3]
FFFFFFFFFFFFD408	37EF8000		 	ret
                  	           		 
FFFFFFFFFFFFD40C	           		 DrawInvaders:
FFFFFFFFFFFFD40C	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFD410	27F4000000F		 	sm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFD414	42009520		 	lc		r1,InvadersRow1
FFFFFFFFFFFFD418	42021570		 	lc		r4,InvadersColpos
FFFFFFFFFFFFD41C	14110001		 	andi	r2,r1,#1
FFFFFFFFFFFFD420	BE2003A8		 	beq		r2,r0,dinv1
FFFFFFFFFFFFD424	40019571		 	lb		r3,InvadersRowpos
FFFFFFFFFFFFD428	60019417		 	sb		r3,CursorRow
FFFFFFFFFFFFD42C	60021418		 	sb		r4,CursorCol
FFFFFFFFFFFFD430	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD434	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD438	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFD43C	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD440	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFD444	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD448	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFD44C	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD450	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD454	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD458	40009417		 	lb		r1,CursorRow
FFFFFFFFFFFFD45C	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFD460	60009417		 	sb		r1,CursorRow
FFFFFFFFFFFFD464	40009418		 	lb		r1,CursorCol
FFFFFFFFFFFFD468	0E108005		 	subui	r1,r1,#5
FFFFFFFFFFFFD46C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD470	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD474	E0400058		 	setlo	r1,#'X'
FFFFFFFFFFFFD478	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD47C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD480	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD484	E0400058		 	setlo	r1,#'X'
FFFFFFFFFFFFD488	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD48C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFD490	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD494	           		 dinv1:
FFFFFFFFFFFFD494	2774000000F		 	lm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFD498	37EF8028		 	ret		#40
FFFFFFFFFFFFD49C	           		 DrawBombs:
FFFFFFFFFFFFD49C	37EF8000		 	ret
                  	           		 
FFFFFFFFFFFFD4A0	           		 Invaders:
FFFFFFFFFFFFD4A0	FFFFFFFFFFFF0000		 	subui	sp,#240
FFFFFFFFFFFFD4A4	27F4000000F		 	sm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFD4A8	31FFF4B1		 	call	InitializeGame
FFFFFFFFFFFFD4AC	           		 InvadersLoop:
FFFFFFFFFFFFD4AC	31FFF4BB		 	call	DrawScore
FFFFFFFFFFFFD4B0	31FFF503		 	call	DrawInvaders
FFFFFFFFFFFFD4B4	31FFF527		 	call	DrawBombs
FFFFFFFFFFFFD4B8	31FFF4C7		 	call	DrawMissile
FFFFFFFFFFFFD4BC	31FFF4E8		 	call	DrawMan
FFFFFFFFFFFFD4C0	           		 TestMoveMan:
FFFFFFFFFFFFD4C0	31FFEF07		 	call	KeybdGetChar
FFFFFFFFFFFFD4C4	B010046B		 	beqi	r1,#'k',MoveManRight
FFFFFFFFFFFFD4C8	B010096A		 	beqi	r1,#'j',MoveManLeft
FFFFFFFFFFFFD4CC	B0100D20		 	beqi	r1,#' ',FireMissile
FFFFFFFFFFFFD4D0	BE0002AA		 	bra		Invaders1
FFFFFFFFFFFFD4D4	           		 MoveManRight:
FFFFFFFFFFFFD4D4	42011508		 	lc		r2,Manpos
FFFFFFFFFFFFD4D8	E6800280		; SETLO
FFFFFFFFFFFFD4DC	BE2D0247		 	bgtu	r2,#640,Invaders1
FFFFFFFFFFFFD4E0	0A210008		 	addui	r2,r2,#8
FFFFFFFFFFFFD4E4	62011508		 	sc		r2,Manpos
FFFFFFFFFFFFD4E8	BE0001EA		 	bra		Invaders1
FFFFFFFFFFFFD4EC	           		 MoveManLeft:
FFFFFFFFFFFFD4EC	42011508		 	lc		r2,Manpos
FFFFFFFFFFFFD4F0	BE2001A2		 	ble		r2,r0,Invaders1
FFFFFFFFFFFFD4F4	0E210008		 	subui	r2,r2,#8
FFFFFFFFFFFFD4F8	62011508		 	sc		r2,Manpos
FFFFFFFFFFFFD4FC	BE00014A		 	bra		Invaders1
FFFFFFFFFFFFD500	           		 FireMissile:
FFFFFFFFFFFFD500	40011510		 	lb		r2,MissileActive
FFFFFFFFFFFFD504	BE200109		 	bne		r2,r0,Invaders1
FFFFFFFFFFFFD508	E0800001		 	setlo	r2,#1
FFFFFFFFFFFFD50C	60011510		 	sb		r2,MissileActive
FFFFFFFFFFFFD510	42011508		 	lc		r2,Manpos
FFFFFFFFFFFFD514	62011512		 	sc		r2,MissileX
FFFFFFFFFFFFD518	E080002E		 	setlo	r2,#46
FFFFFFFFFFFFD51C	62011514		 	sc		r2,MissileY
FFFFFFFFFFFFD520	BE00002A		 	bra		Invaders1
FFFFFFFFFFFFD524	           		 Invaders1:
FFFFFFFFFFFFD524	B0100203		 	beqi	r1,#CTRLC,InvadersEnd
FFFFFFFFFFFFD528	BE007C2A		 	bra		InvadersLoop
FFFFFFFFFFFFD52C	           		 InvadersEnd:
FFFFFFFFFFFFD52C	2774000000F		 	lm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFD530	0BEF00F0		 	addui	sp,sp,#240
FFFFFFFFFFFFD534	BE0017AA		 	bra		Monitor
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
                  	           		 ;
                  	           		 ; Initialize the SD card
                  	           		 ; Returns
                  	           		 ; r = 0 if successful, 1 otherwise
                  	           		 ;
FFFFFFFFFFFFD538	           		 spi_init:
FFFFFFFFFFFFD538	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFD53C	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD540	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFD544	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFD548	E69C0500		; SETLO
FFFFFFFFFFFFD54C	EE800003		; SETMID
FFFFFFFFFFFFD550	6A0D0C2D		 	lea		r3,SPIMASTER
FFFFFFFFFFFFD554	16008001		 	lw		r1,#SPI_INIT_SD
FFFFFFFFFFFFD558	90308002		 	outb	r1,SPI_TRANS_TYPE_REG[r3]
FFFFFFFFFFFFD55C	16008001		 	lw		r1,#SPI_TRANS_START
FFFFFFFFFFFFD560	90308003		 	outb	r1,SPI_TRANS_CTRL_REG[r3]
FFFFFFFFFFFFD564	DE000000		 	nop
FFFFFFFFFFFFD568	           		 spi_init1:
FFFFFFFFFFFFD568	80308004		 	inb		r1,SPI_TRANS_STATUS_REG[r3]
FFFFFFFFFFFFD56C	02110009		 	mov		r2,r1							; note: some time needs to be wasted
FFFFFFFFFFFFD570	02208009		 	mov		r1,r2							; between status reads.
FFFFFFFFFFFFD574	B01FFD01		 	beqi	r1,#SPI_TRANS_BUSY,spi_init1
FFFFFFFFFFFFD578	80308005		 	inb		r1,SPI_TRANS_ERROR_REG[r3]
FFFFFFFFFFFFD57C	2A108204		 	bfext	r1,r1,#1,#0
FFFFFFFFFFFFD580	B2100500		 	bne		r1,#SPI_INIT_NO_ERROR,spi_error
FFFFFFFFFFFFD584	9A00D946		 	lea		r1,spi_init_ok_msg
FFFFFFFFFFFFD588	31FFF122		 	call	DisplayString
FFFFFFFFFFFFD58C	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFD590	BE0000AA		 	bra		spi_init_exit
FFFFFFFFFFFFD594	           		 spi_error:
FFFFFFFFFFFFD594	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD598	9A00D960		 	lea		r1,spi_init_error_msg
FFFFFFFFFFFFD59C	31FFF122		 	call	DisplayString
FFFFFFFFFFFFD5A0	16008001		 	lw		r1,#1
FFFFFFFFFFFFD5A4	           		 spi_init_exit:
FFFFFFFFFFFFD5A4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFD5A8	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFD5AC	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFD5B0	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; SPI read sector
                  	           		 ;
                  	           		 ; r1= sector number to read
                  	           		 ; r2= address to place read data
                  	           		 ; Returns:
                  	           		 ; r1 = 0 if successful
                  	           		 ;
FFFFFFFFFFFFD5B4	           		 spi_read_sector:
FFFFFFFFFFFFD5B4	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFD5B8	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD5BC	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFD5C0	67E10010		 	sw		r2,16[sp]
FFFFFFFFFFFFD5C4	67E18018		 	sw		r3,24[sp]
FFFFFFFFFFFFD5C8	67E20020		 	sw		r4,32[sp]
FFFFFFFFFFFFD5CC	E69C0500		; SETLO
FFFFFFFFFFFFD5D0	EE800003		; SETMID
FFFFFFFFFFFFD5D4	6A0D0C2D		 	lea		r3,SPIMASTER
                  	           		 
                  	           		 	; spi master wants a byte address, so we multiply the sector number
                  	           		 	; by 512.
FFFFFFFFFFFFD5D8	06109206		 	shlui	r1,r1,#9
FFFFFFFFFFFFD5DC	90308007		 	outb	r1,SPI_SD_ADDR_7_0_REG[r3]
FFFFFFFFFFFFD5E0	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFD5E4	90308008		 	outb	r1,SPI_SD_ADDR_15_8_REG[r3]
FFFFFFFFFFFFD5E8	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFD5EC	90308009		 	outb	r1,SPI_SD_ADDR_23_16_REG[r3]
FFFFFFFFFFFFD5F0	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFD5F4	9030800A		 	outb	r1,SPI_SD_ADDR_31_24_REG[r3]
                  	           		 	
                  	           		 	; Force the reciever fifo to be empty, in case a prior error leaves it
                  	           		 	; in an unknown state.
FFFFFFFFFFFFD5F8	16008001		 	lw		r1,#1
FFFFFFFFFFFFD5FC	90308014		 	outb	r1,SPI_RX_FIFO_CTRL_REG[r3]
                  	           		 
FFFFFFFFFFFFD600	16008002		 	lw		r1,#RW_READ_SD_BLOCK
FFFFFFFFFFFFD604	90308002		 	outb	r1,SPI_TRANS_TYPE_REG[r3]
FFFFFFFFFFFFD608	16008001		 	lw		r1,#SPI_TRANS_START
FFFFFFFFFFFFD60C	90308003		 	outb	r1,SPI_TRANS_CTRL_REG[r3]
FFFFFFFFFFFFD610	DE000000		 	nop
FFFFFFFFFFFFD614	           		 spi_read_sect1:
FFFFFFFFFFFFD614	80308004		 	inb		r1,SPI_TRANS_STATUS_REG[r3]
FFFFFFFFFFFFD618	02120009		 	mov		r4,r1							; just a delay between consecutive status reg reads
FFFFFFFFFFFFD61C	02408009		 	mov		r1,r4
FFFFFFFFFFFFD620	B01FFD01		 	beqi	r1,#SPI_TRANS_BUSY,spi_read_sect1
FFFFFFFFFFFFD624	80308005		 	inb		r1,SPI_TRANS_ERROR_REG[r3]
FFFFFFFFFFFFD628	2A108614		 	bfext	r1,r1,#3,#2
FFFFFFFFFFFFD62C	B2100800		 	bnei	r1,#SPI_READ_NO_ERROR,spi_read_error
FFFFFFFFFFFFD630	16020200		 	lw		r4,#512		; read 512 bytes from fifo
FFFFFFFFFFFFD634	           		 spi_read_sect2:
FFFFFFFFFFFFD634	80308010		 	inb		r1,SPI_RX_FIFO_DATA_REG[r3]
FFFFFFFFFFFFD638	60208000		 	sb		r1,[r2]
FFFFFFFFFFFFD63C	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFD640	BE027FAF		 	loop	r4,spi_read_sect2
FFFFFFFFFFFFD644	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFD648	BE0000AA		 	bra		spi_read_ret
FFFFFFFFFFFFD64C	           		 spi_read_error:
FFFFFFFFFFFFD64C	31FFF14B		 	call	DisplayByte
FFFFFFFFFFFFD650	9A00D99E		 	lea		r1,spi_read_error_msg
FFFFFFFFFFFFD654	31FFF122		 	call	DisplayString
FFFFFFFFFFFFD658	16008001		 	lw		r1,#1
FFFFFFFFFFFFD65C	           		 spi_read_ret:
FFFFFFFFFFFFD65C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFD660	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFD664	47E10010		 	lw		r2,16[sp]
FFFFFFFFFFFFD668	47E18018		 	lw		r3,24[sp]
FFFFFFFFFFFFD66C	47E20020		 	lw		r4,32[sp]
FFFFFFFFFFFFD670	37EF8028		 	ret		#40
                  	           		 
                  	           		 ; Read the boot sector from the disk.
                  	           		 ; Must find it first by looking for the signature bytes 'EB' and '55AA'.
                  	           		 ;
FFFFFFFFFFFFD674	           		 spi_read_boot:
FFFFFFFFFFFFD674	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFD678	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD67C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFD680	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFD684	67E28018		 	sw		r5,24[sp]
FFFFFFFFFFFFD688	660030F8		 	sw		r0,startSector					; default starting sector
FFFFFFFFFFFFD68C	160181F4		 	lw		r3,#500	;1934720						; number of sectors to read (up to 1GB)
FFFFFFFFFFFFD690	16028000		 	lw		r5,#0							; r5 = starting address
FFFFFFFFFFFFD694	           		 spi_read_boot1:
FFFFFFFFFFFFD694	02508009		 	mov		r1,r5							; r1 = sector number
FFFFFFFFFFFFD698	16010008		 	lw		r2,#8							; eight digits
FFFFFFFFFFFFD69C	60001418		 	sb		r0,CursorCol
FFFFFFFFFFFFD6A0	31FFF13F		 	call	DisplayNum						; Display the sector number being checked
FFFFFFFFFFFFD6A4	02508009		 	mov		r1,r5							; r1 = sector number
FFFFFFFFFFFFD6A8	E6800000		; SETLO
FFFFFFFFFFFFD6AC	EE800402		; SETMID
FFFFFFFFFFFFD6B0	040D0809		 	lw		r2,#0x100800000					; r2 = target address
FFFFFFFFFFFFD6B4	31FFF56D		 	call	spi_read_sector
                  	           		 
                  	           		 ; The following displays the contents of the sector
                  	           		 ;	lw		r1,#0x10
                  	           		 ;	lw		r2,#0x3800
                  	           		 ;spi_read_boot5:
                  	           		 ;	call	DisplayMemB
                  	           		 ;	loop	r1,spi_read_boot5
                  	           		 
FFFFFFFFFFFFD6B8	0A528001		 	addui	r5,r5,#1						; move to next sector
FFFFFFFFFFFFD6BC	E6800000		; SETLO
FFFFFFFFFFFFD6C0	EE800402		; SETMID
FFFFFFFFFFFFD6C4	6A0D0405		 	lbu		r1,0x100800000
FFFFFFFFFFFFD6C8	121100EB		 	cmpui	r2,r1,#0xEB
FFFFFFFFFFFFD6CC	BE200088		 	beq		r2,r0,spi_read_boot2
FFFFFFFFFFFFD6D0	           		 spi_read_boot3:
FFFFFFFFFFFFD6D0	BE01FE2F		 	loop	r3,spi_read_boot1
FFFFFFFFFFFFD6D4	16008001		 	lw		r1,#1							; r1 = 1 for error
FFFFFFFFFFFFD6D8	BE0001EA		 	bra		spi_read_boot4
FFFFFFFFFFFFD6DC	           		 spi_read_boot2:
FFFFFFFFFFFFD6DC	9A00D728		 	lea		r1,msgFoundEB
FFFFFFFFFFFFD6E0	31FFF122		 	call	DisplayString
FFFFFFFFFFFFD6E4	E68001FE		; SETLO
FFFFFFFFFFFFD6E8	EE800402		; SETMID
FFFFFFFFFFFFD6EC	6A0D0405		 	lbu		r1,0x1008001FE					; check for 0x55AA signature
FFFFFFFFFFFFD6F0	B21FF855		 	bnei	r1,#0x55,spi_read_boot3
FFFFFFFFFFFFD6F4	E68001FF		; SETLO
FFFFFFFFFFFFD6F8	EE800402		; SETMID
FFFFFFFFFFFFD6FC	6A0D0405		 	lbu		r1,0x1008001FF
FFFFFFFFFFFFD700	E68000AA		; SETLO
FFFFFFFFFFFFD704	BE1D7E69		 	bnei	r1,#0xAA,spi_read_boot3
FFFFFFFFFFFFD708	0E508001		 	subui	r1,r5,#1
FFFFFFFFFFFFD70C	6600B0F8		 	sw		r1,startSector
FFFFFFFFFFFFD710	0410840A		 	xor		r1,r1,r1						; r1 = 0, for okay status
FFFFFFFFFFFFD714	           		 spi_read_boot4:
FFFFFFFFFFFFD714	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFD718	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFD71C	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFD720	47E28018		 	lw		r5,24[sp]
FFFFFFFFFFFFD724	37EF8020		 	ret		#32
                  	           		 
FFFFFFFFFFFFD728	           		 msgFoundEB:
FFFFFFFFFFFFD728 424520646E756F46	 	db	"Found EB code.",CR,LF,0
FFFFFFFFFFFFD730 0A0D2E65646F6320
FFFFFFFFFFFFD73C	           		 	.align 4
                  	           		 
                  	           		 ; Load the FAT tables into memory
                  	           		 ;
FFFFFFFFFFFFD73C	           		 loadFAT:
FFFFFFFFFFFFD73C	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFD740	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD744	E6800016		; SETLO
FFFFFFFFFFFFD748	EE800402		; SETMID
FFFFFFFFFFFFD74C	6A0D0C06		 	lcu		r3,0x100800016					; sectors per FAT
FFFFFFFFFFFFD750	E6800010		; SETLO
FFFFFFFFFFFFD754	EE800402		; SETMID
FFFFFFFFFFFFD758	6A0D0805		 	lbu		r2,0x100800010					; number of FATs
FFFFFFFFFFFFD75C	04310C18		 	mulu	r3,r3,r2						; offset
FFFFFFFFFFFFD760	E6800200		; SETLO
FFFFFFFFFFFFD764	EE800402		; SETMID
FFFFFFFFFFFFD768	6A0D082D		 	lea		r2,0x100800200					; where to place FAT
FFFFFFFFFFFFD76C	E680000E		; SETLO
FFFFFFFFFFFFD770	EE800402		; SETMID
FFFFFFFFFFFFD774	6A0D1406		 	lcu		r5,0x10080000E					; r5 = # reserved sectors before FAT
FFFFFFFFFFFFD778	460330F8		 	lw		r6,startSector
FFFFFFFFFFFFD77C	04531403		 	addu	r5,r5,r6
FFFFFFFFFFFFD780	           		 loadFAT1:
FFFFFFFFFFFFD780	02508009		 	mov		r1,r5							; r1 = sector #
FFFFFFFFFFFFD784	31FFF56D		 	call	spi_read_sector
FFFFFFFFFFFFD788	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFD78C	0A210200		 	addui	r2,r2,#512						; advance 512 bytes
FFFFFFFFFFFFD790	BE01FF8F		 	loop	r3,loadFAT1
FFFFFFFFFFFFD794	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFD798	37EF8008		 	ret		#8
                  	           		 
                  	           		 ; Load the root directory from disk
                  	           		 ; r2 = where to place root directory in memory
                  	           		 ;
FFFFFFFFFFFFD79C	           		 loadRootDirectory:
FFFFFFFFFFFFD79C	E6800016		; SETLO
FFFFFFFFFFFFD7A0	EE800402		; SETMID
FFFFFFFFFFFFD7A4	6A0D0C06		 	lcu		r3,0x100800016					; sectors per FAT
FFFFFFFFFFFFD7A8	E6800010		; SETLO
FFFFFFFFFFFFD7AC	EE800402		; SETMID
FFFFFFFFFFFFD7B0	6A0D1005		 	lbu		r4,0x100800010					; number of FATs
FFFFFFFFFFFFD7B4	04320C18		 	mulu	r3,r3,r4						; offset
FFFFFFFFFFFFD7B8	E680000E		; SETLO
FFFFFFFFFFFFD7BC	EE800402		; SETMID
FFFFFFFFFFFFD7C0	6A0D1006		 	lcu		r4,0x10080000E					; r2 = # reserved sectors before FAT
FFFFFFFFFFFFD7C4	04320C03		 	addu	r3,r3,r4						; r3 = root directory sector number
FFFFFFFFFFFFD7C8	460330F8		 	lw		r6,startSector
FFFFFFFFFFFFD7CC	04331403		 	addu	r5,r3,r6						; r5 = root directory sector number
                  	           		 	; we have to use two byte loads here because the number is at an unaligned data address
FFFFFFFFFFFFD7D0	E6800011		; SETLO
FFFFFFFFFFFFD7D4	EE800402		; SETMID
FFFFFFFFFFFFD7D8	6A0D1C05		 	lbu		r7,0x100800011					; r7 <= number of root directory entries
FFFFFFFFFFFFD7DC	E6800012		; SETLO
FFFFFFFFFFFFD7E0	EE800402		; SETMID
FFFFFFFFFFFFD7E4	6A0D2005		 	lbu		r8,0x100800012
FFFFFFFFFFFFD7E8	06841006		 	shlui	r8,r8,#8
FFFFFFFFFFFFD7EC	04741C09		 	or		r7,r7,r8
FFFFFFFFFFFFD7F0	02740009		 	mov		r8,r7							; r8 = number of root directory entries
FFFFFFFFFFFFD7F4	06738A06		 	shlui	r7,r7,#5						; r7 *=32 = size of root directory table (bytes)
FFFFFFFFFFFFD7F8	06739201		 	shrui	r7,r7,#9						; r7 /= 512 = number of sectors in root directory
FFFFFFFFFFFFD7FC	02718009		 	mov		r3,r7
FFFFFFFFFFFFD800	           		 loadRootDir1:
FFFFFFFFFFFFD800	02508009		 	mov		r1,r5
FFFFFFFFFFFFD804	31FFF56D		 	call	spi_read_sector
FFFFFFFFFFFFD808	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFD80C	0A210200		 	addui	r2,r2,#512
FFFFFFFFFFFFD810	BE01FF8F		 	loop	r3,loadRootDir1
                  	           		 
FFFFFFFFFFFFD814	           		 loadBootFile:
                  	           		 	; For now we cheat and just go directly to sector 512.
FFFFFFFFFFFFD814	BE0004AA		 	bra		loadBootFileTmp
                  	           		 
FFFFFFFFFFFFD818	E6800016		; SETLO
FFFFFFFFFFFFD81C	EE800402		; SETMID
FFFFFFFFFFFFD820	6A0D0C06		 	lcu		r3,0x100800016					; sectors per FAT
FFFFFFFFFFFFD824	E6800010		; SETLO
FFFFFFFFFFFFD828	EE800402		; SETMID
FFFFFFFFFFFFD82C	6A0D0805		 	lbu		r2,0x100800010					; number of FATs
FFFFFFFFFFFFD830	04310C18		 	mulu	r3,r3,r2						; offset
FFFFFFFFFFFFD834	E680000E		; SETLO
FFFFFFFFFFFFD838	EE800402		; SETMID
FFFFFFFFFFFFD83C	6A0D0806		 	lcu		r2,0x10080000E					; r2 = # reserved sectors before FAT
FFFFFFFFFFFFD840	04310C03		 	addu	r3,r3,r2						; r3 = root directory sector number
                  	           		 	; we have to use two byte loads here because the number is at an unaligned data address
FFFFFFFFFFFFD844	E6800011		; SETLO
FFFFFFFFFFFFD848	EE800402		; SETMID
FFFFFFFFFFFFD84C	6A0D1C05		 	lbu		r7,0x100800011					; r7 <= number of root directory entries
FFFFFFFFFFFFD850	E6800012		; SETLO
FFFFFFFFFFFFD854	EE800402		; SETMID
FFFFFFFFFFFFD858	6A0D2005		 	lbu		r8,0x100800012
FFFFFFFFFFFFD85C	06841006		 	shlui	r8,r8,#8
FFFFFFFFFFFFD860	04741C09		 	or		r7,r7,r8
FFFFFFFFFFFFD864	02740009		 	mov		r8,r7							; r8 = number of root directory entries
FFFFFFFFFFFFD868	06738A06		 	shlui	r7,r7,#5						; r7 *=32 = size of root directory table (bytes)
FFFFFFFFFFFFD86C	06739201		 	shrui	r7,r7,#9						; r7 /= 512 = number of sectors in root directory
                  	           		 
                  	           		 ; now we need to fetch the sectors of the root directory and put them somewhere in
                  	           		 ; memory
                  	           		 ;
FFFFFFFFFFFFD870	           		 loadBootFile4:
FFFFFFFFFFFFD870	46308000		 	lw		r1,[r3]							; get filename
FFFFFFFFFFFFD874	E68F4F42		; SETLO
FFFFFFFFFFFFD878	EEA51951		; SETMID
FFFFFFFFFFFFD87C	F68454C4		; SETHI
FFFFFFFFFFFFD880	041D0407		 	cmpui	r1,r1,#0x454C4946544F4F42		; "BOOTFILE"
FFFFFFFFFFFFD884	BE100068		 	beq		r1,r0,loadBootFile5
FFFFFFFFFFFFD888	           		 loadBootFile3:
FFFFFFFFFFFFD888	0A318020		 	addui	r3,r3,#32						; move to next directory entry
FFFFFFFFFFFFD88C	BE03FF2F		 	loop	r7,loadBootFile4
                  	           		 ; boot file not found
                  	           		 
                  	           		 ; here we found the file in the directory
                  	           		 ;
FFFFFFFFFFFFD890	           		 loadBootFile5:
FFFFFFFFFFFFD890	4C31001A		 	lcu		r2,0x1a[r3]						; get starting cluster
FFFFFFFFFFFFD894	E6800011		; SETLO
FFFFFFFFFFFFD898	EE800402		; SETMID
FFFFFFFFFFFFD89C	6A0D1C06		 	lcu		r7,0x100800011					; r7 = number of root directory entries
FFFFFFFFFFFFD8A0	06738A06		 	shlui	r7,r7,#5						; r7 *=32 = size of root directory table (bytes)
FFFFFFFFFFFFD8A4	06739201		 	shrui	r7,r7,#9						; r7 /= 512 = number of sectors in root directory
                  	           		 
FFFFFFFFFFFFD8A8	           		 loadBootFileTmp:
                  	           		 	; We load the number of sectors per cluster, then load a single cluster of the file.
                  	           		 	; This is 16kib
FFFFFFFFFFFFD8A8	E680000D		; SETLO
FFFFFFFFFFFFD8AC	EE800402		; SETMID
FFFFFFFFFFFFD8B0	6A0D0C05		 	lbu		r3,0x10080000D					; sectors per cluster
FFFFFFFFFFFFD8B4	E6800200		; SETLO
FFFFFFFFFFFFD8B8	EE800402		; SETMID
FFFFFFFFFFFFD8BC	6A0D082D		 	lea		r2,0x100800200					; where to place FAT in memory
FFFFFFFFFFFFD8C0	4602B0F8		 	lw		r5,startSector					; r5=start sector of disk
FFFFFFFFFFFFD8C4	0A528200		 	addui	r5,r5,#512						; r5= sector 512
FFFFFFFFFFFFD8C8	           		 loadBootFile1:
FFFFFFFFFFFFD8C8	02508009		 	mov		r1,r5							; r1=sector to read
FFFFFFFFFFFFD8CC	31FFF56D		 	call	spi_read_sector
FFFFFFFFFFFFD8D0	0A528001		 	addui	r5,r5,#1						; r5 = next sector
FFFFFFFFFFFFD8D4	0A210200		 	addui	r2,r2,#512
FFFFFFFFFFFFD8D8	BE01FF8F		 	loop	r3,loadBootFile1
FFFFFFFFFFFFD8DC	E6800200		; SETLO
FFFFFFFFFFFFD8E0	EE800402		; SETMID
FFFFFFFFFFFFD8E4	6A0D0407		 	lhu		r1,0x100800200					; make sure it's bootable
FFFFFFFFFFFFD8E8	E68F4F42		; SETLO
FFFFFFFFFFFFD8EC	EE800151		; SETMID
FFFFFFFFFFFFD8F0	BE1D0129		 	bnei	r1,#0x544F4F42,loadBootFile2
FFFFFFFFFFFFD8F4	16008016		 	lw		r1,#0x16
FFFFFFFFFFFFD8F8	9A00D920		 	lea		r1,msgJumpingToBoot
FFFFFFFFFFFFD8FC	31FFF122		 	call	DisplayString
FFFFFFFFFFFFD900	E6800204		; SETLO
FFFFFFFFFFFFD904	EE800402		; SETMID
FFFFFFFFFFFFD908	040D0409		 	lw		r1,#0x100800204
FFFFFFFFFFFFD90C	341F8000		 	jal		lr,[r1]
FFFFFFFFFFFFD910	33FFF20A		 	jmp		Monitor
FFFFFFFFFFFFD914	           		 loadBootFile2:
FFFFFFFFFFFFD914	9A00D930		 	lea		r1,msgNotBootable
FFFFFFFFFFFFD918	31FFF122		 	call	DisplayString
FFFFFFFFFFFFD91C	33FFF20A		 	jmp		Monitor
                  	           		 
FFFFFFFFFFFFD920	           		 msgJumpingToBoot:
FFFFFFFFFFFFD920 20676E69706D754A	 	db	"Jumping to boot",0	
FFFFFFFFFFFFD928 00746F6F62206F74
FFFFFFFFFFFFD930	           		 msgNotBootable:
FFFFFFFFFFFFD930 2064726163204453	 	db	"SD card not bootable.",0
FFFFFFFFFFFFD938 746F6F6220746F6E
FFFFFFFFFFFFD946	           		 spi_init_ok_msg:
FFFFFFFFFFFFD940 4453002E656C6261	 	db "SD card initialized okay.",0
FFFFFFFFFFFFD948 6E69206472616320
FFFFFFFFFFFFD950 657A696C61697469
FFFFFFFFFFFFD958 002E79616B6F2064
FFFFFFFFFFFFD960	           		 spi_init_error_msg:
FFFFFFFFFFFFD960 20726F727265203A	 	db	": error occurred initializing the SD card.",0
FFFFFFFFFFFFD968 646572727563636F
FFFFFFFFFFFFD970 6C616974696E6920
FFFFFFFFFFFFD978 687420676E697A69
FFFFFFFFFFFFD980 7261632044532065
FFFFFFFFFFFFD98B	           		 spi_boot_error_msg:
FFFFFFFFFFFFD988 6163204453002E64	 	db	"SD card boot error",0
FFFFFFFFFFFFD990 20746F6F62206472
FFFFFFFFFFFFD99E	           		 spi_read_error_msg:
FFFFFFFFFFFFD998 445300726F727265	 	db	"SD card read error",0
FFFFFFFFFFFFD9A0 6572206472616320
FFFFFFFFFFFFD9A8 726F727265206461
                  	           		 
FFFFFFFFFFFFD9B4	           		 	.align	4
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Ethernet
                  	           		 ;==============================================================================
                  	           		 my_MAC1	EQU	0x00
                  	           		 my_MAC2	EQU	0xFF
                  	           		 my_MAC3	EQU	0xEE
                  	           		 my_MAC4	EQU	0xF0
                  	           		 my_MAC5	EQU	0xDA
                  	           		 my_MAC6	EQU	0x42
                  	           		 
FFFFFFFFFFFFD9B4	           		 	.bss
FFFFFFFFFFFFD9B4 0000000000000000	 eth_unique_id	dw		0
                  	           		 
FFFFFFFFFFFFD9BC	           		 	.code
                  	           		 
                  	           		 ; Initialize the ethmac controller.
                  	           		 ; Supply a MAC address, set MD clock
                  	           		 ;
FFFFFFFFFFFFD9BC	           		 eth_init:
FFFFFFFFFFFFD9BC	E69C2000		; SETLO
FFFFFFFFFFFFD9C0	EE800003		; SETMID
FFFFFFFFFFFFD9C4	6A0D0C2D		 	lea		r3,ETHMAC
FFFFFFFFFFFFD9C8	16008064		 	lw		r1,#0x64			; 100
FFFFFFFFFFFFD9CC	64308028		 	sh		r1,MIIMODER[r3]
FFFFFFFFFFFFD9D0	16008007		 	lw		r1,#7				; PHY address
FFFFFFFFFFFFD9D4	64308030		 	sh		r1,MIIADDRESS[r3]
FFFFFFFFFFFFD9D8	E6B0DA42		; SETLO
FFFFFFFFFFFFD9DC	EEBFFFBB		; SETMID
FFFFFFFFFFFFD9E0	040D0409		 	lw		r1,#0xEEF0DA42
FFFFFFFFFFFFD9E4	64308040		 	sh		r1,0x40[r3]			; MAC0
FFFFFFFFFFFFD9E8	160080FF		 	lw		r1,#0x00FF
FFFFFFFFFFFFD9EC	64308044		 	sh		r1,0x44[r3]			; MAC1
FFFFFFFFFFFFD9F0	37EF8000		 	ret
                  	           		 
                  	           		 ; Request a packet and display on screen
                  	           		 ; r1 = address where to put packet
                  	           		 ;
FFFFFFFFFFFFD9F4	           		 eth_request_packet:
FFFFFFFFFFFFD9F4	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFD9F8	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFD9FC	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFDA00	67E20010		 	sw		r4,16[sp]
FFFFFFFFFFFFDA04	E69C2000		; SETLO
FFFFFFFFFFFFDA08	EE800003		; SETMID
FFFFFFFFFFFFDA0C	6A0D0C2D		 	lea		r3,ETHMAC
FFFFFFFFFFFFDA10	16010004		 	lw		r2,#4				; clear rx interrupt
FFFFFFFFFFFFDA14	64310004		 	sh		r2,4[r3]
FFFFFFFFFFFFDA18	64308604		 	sh		r1,0x604[r3]		; storage address
FFFFFFFFFFFFDA1C	16016000		 	lw		r2,#0xe000			; enable interrupt
FFFFFFFFFFFFDA20	64310600		 	sh		r2,0x600[r3]
FFFFFFFFFFFFDA24	           		 eth1:
FFFFFFFFFFFFDA24	DE000000		 	nop
FFFFFFFFFFFFDA28	84310004		 	inh		r2,4[r3]
FFFFFFFFFFFFDA2C	2A210414		 	bfext	r2,r2,#2,#2			; get bit #2
FFFFFFFFFFFFDA30	BE207FA8		 	beq		r2,r0,eth1
FFFFFFFFFFFFDA34	84310600		 	inh		r2,0x600[r3]		; get from descriptor
FFFFFFFFFFFFDA38	06212001		 	shrui	r2,r2,#16
FFFFFFFFFFFFDA3C	16018000		 	lw		r3,#0
FFFFFFFFFFFFDA40	E6901D88		; SETLO
FFFFFFFFFFFFDA44	EE800003		; SETMID
FFFFFFFFFFFFDA48	6A0D102D		 	lea		r4,TEXTSCR+7560		; second last line of screen
FFFFFFFFFFFFDA4C	           		 eth20:
FFFFFFFFFFFFDA4C	6A118805		 	lbu		r2,[r1+r3]			; get byte
FFFFFFFFFFFFDA50	6A418911		 	sc		r2,[r4+r3*2]		; store to screen
FFFFFFFFFFFFDA54	0A318001		 	addui	r3,r3,#1
FFFFFFFFFFFFDA58	12310053		 	cmpui	r2,r3,#83
FFFFFFFFFFFFDA5C	BE207F89		 	bne		r2,r0,eth20
FFFFFFFFFFFFDA60	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFDA64	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFDA68	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFDA6C	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; r1 = packet address
                  	           		 ;
FFFFFFFFFFFFDA70	           		 eth_interpret_packet:
FFFFFFFFFFFFDA70	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFDA74	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFDA78	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFDA7C	4A11000C		 	lbu		r2,12[r1]
FFFFFFFFFFFFDA80	4A11800D		 	lbu		r3,13[r1]
FFFFFFFFFFFFDA84	B2200608		 	bnei	r2,#8,eth2			; 0x806 ?
FFFFFFFFFFFFDA88	B2300506		 	bnei	r3,#6,eth2
FFFFFFFFFFFFDA8C	16008002		 	lw		r1,#2				; return r1 = 2 for ARP
FFFFFFFFFFFFDA90	           		 eth5:
FFFFFFFFFFFFDA90	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFDA94	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFDA98	37EF8010		 	ret		#16
FFFFFFFFFFFFDA9C	           		 eth2:
FFFFFFFFFFFFDA9C	B2200C08		 	bnei	r2,#8,eth3			; 0x800 ?
FFFFFFFFFFFFDAA0	B2300B00		 	bnei	r3,#0,eth3
FFFFFFFFFFFFDAA4	4A110017		 	lbu		r2,23[r1]
FFFFFFFFFFFFDAA8	B2200301		 	bnei	r2,#1,eth4
FFFFFFFFFFFFDAAC	16008001		 	lw		r1,#1
FFFFFFFFFFFFDAB0	BE007F0A		 	bra		eth5				; return 1 ICMP
FFFFFFFFFFFFDAB4	           		 eth4:
FFFFFFFFFFFFDAB4	B2200311		 	bnei	r2,#0x11,eth6
FFFFFFFFFFFFDAB8	16008003		 	lw		r1,#3				; return 3 for UDP
FFFFFFFFFFFFDABC	BE007EAA		 	bra		eth5
FFFFFFFFFFFFDAC0	           		 eth6:
FFFFFFFFFFFFDAC0	B2200306		 	bnei	r2,#6,eth7
FFFFFFFFFFFFDAC4	16008004		 	lw		r1,#4				; return 4 for TCP
FFFFFFFFFFFFDAC8	BE007E4A		 	bra		eth5
FFFFFFFFFFFFDACC	           		 eth7:
FFFFFFFFFFFFDACC	           		 eth3:
FFFFFFFFFFFFDACC	0410840A		 	xor		r1,r1,r1			; return zero for unknown
FFFFFFFFFFFFDAD0	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFDAD4	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFDAD8	37EF8010		 	ret		#16
                  	           		 
                  	           		 ; r1 = address of packet to send
                  	           		 ; r2 = packet length
                  	           		 ;
FFFFFFFFFFFFDADC	           		 eth_send_packet:
FFFFFFFFFFFFDADC	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFDAE0	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFDAE4	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFDAE8	E69C2000		; SETLO
FFFFFFFFFFFFDAEC	EE800003		; SETMID
FFFFFFFFFFFFDAF0	6A0D0C2D		 	lea		r3,ETHMAC
                  	           		 	; wait for tx buffer to be clear
FFFFFFFFFFFFDAF4	           		 eth8:
FFFFFFFFFFFFDAF4	84320400		 	inh		r4,0x400[r3]
FFFFFFFFFFFFDAF8	2A421E7C		 	bfext	r4,r4,#15,#15
FFFFFFFFFFFFDAFC	B04FFE01		 	beqi	r4,#1,eth8
FFFFFFFFFFFFDB00	16020001		 	lw		r4,#1			; clear tx interrupt
FFFFFFFFFFFFDB04	64320004		 	sh		r4,4[r3]
                  	           		 	; set address
FFFFFFFFFFFFDB08	64308404		 	sh		r1,0x404[r3]
                  	           		 	; set the packet length field and enable interrupts
FFFFFFFFFFFFDB0C	06212006		 	shlui	r2,r2,#16
FFFFFFFFFFFFDB10	16217000		 	ori		r2,r2,#0xF000
FFFFFFFFFFFFDB14	64310400		 	sh		r2,0x400[r3]
FFFFFFFFFFFFDB18	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFDB1C	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFDB20	37EF8010		 	ret		#16
                  	           		 
                  	           		 ; Only for IP type packets (not ARP)
                  	           		 ; r1 = rx buffer address
                  	           		 ; r2 = swap flag
                  	           		 ; Returns:
                  	           		 ; r1 = data start index
                  	           		 ;
FFFFFFFFFFFFDB24	           		 eth_build_packet:
FFFFFFFFFFFFDB24	0FEF0040		 	subui	sp,sp,#64
FFFFFFFFFFFFDB28	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFDB2C	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFDB30	67E28010		 	sw		r5,16[sp]
FFFFFFFFFFFFDB34	67E30018		 	sw		r6,24[sp]
FFFFFFFFFFFFDB38	67E38020		 	sw		r7,32[sp]
FFFFFFFFFFFFDB3C	67E40028		 	sw		r8,40[sp]
FFFFFFFFFFFFDB40	67E48030		 	sw		r9,48[sp]
FFFFFFFFFFFFDB44	67E50038		 	sw		r10,56[sp]
FFFFFFFFFFFFDB48	4A118006		 	lbu		r3,6[r1]
FFFFFFFFFFFFDB4C	4A120007		 	lbu		r4,7[r1]
FFFFFFFFFFFFDB50	4A128008		 	lbu		r5,8[r1]
FFFFFFFFFFFFDB54	4A130009		 	lbu		r6,9[r1]
FFFFFFFFFFFFDB58	4A13800A		 	lbu		r7,10[r1]
FFFFFFFFFFFFDB5C	4A14000B		 	lbu		r8,11[r1]
                  	           		 	; write to destination header
FFFFFFFFFFFFDB60	60118000		 	sb		r3,[r1]
FFFFFFFFFFFFDB64	60120001		 	sb		r4,1[r1]
FFFFFFFFFFFFDB68	60128002		 	sb		r5,2[r1]
FFFFFFFFFFFFDB6C	60130003		 	sb		r6,3[r1]
FFFFFFFFFFFFDB70	60138004		 	sb		r7,4[r1]
FFFFFFFFFFFFDB74	60140005		 	sb		r8,5[r1]
                  	           		 	; write to source header
FFFFFFFFFFFFDB78	16018000		 	lw		r3,#my_MAC1
FFFFFFFFFFFFDB7C	60118006		 	sb		r3,6[r1]
FFFFFFFFFFFFDB80	160180FF		 	lw		r3,#my_MAC2
FFFFFFFFFFFFDB84	60118007		 	sb		r3,7[r1]
FFFFFFFFFFFFDB88	160180EE		 	lw		r3,#my_MAC3
FFFFFFFFFFFFDB8C	60118008		 	sb		r3,8[r1]
FFFFFFFFFFFFDB90	160180F0		 	lw		r3,#my_MAC4
FFFFFFFFFFFFDB94	60118009		 	sb		r3,9[r1]
FFFFFFFFFFFFDB98	160180DA		 	lw		r3,#my_MAC5
FFFFFFFFFFFFDB9C	6011800A		 	sb		r3,10[r1]
FFFFFFFFFFFFDBA0	16018042		 	lw		r3,#my_MAC6
FFFFFFFFFFFFDBA4	6011800B		 	sb		r3,11[r1]
FFFFFFFFFFFFDBA8	B2201101		 	bnei	r2,#1,eth16			// if (swap)
FFFFFFFFFFFFDBAC	4A11801A		 	lbu		r3,26[r1]
FFFFFFFFFFFFDBB0	4A12001B		 	lbu		r4,27[r1]
FFFFFFFFFFFFDBB4	4A12801C		 	lbu		r5,28[r1]
FFFFFFFFFFFFDBB8	4A13001D		 	lbu		r6,29[r1]
                  	           		 	; read destination
FFFFFFFFFFFFDBBC	4A13801E		 	lbu		r7,30[r1]
FFFFFFFFFFFFDBC0	4A14001F		 	lbu		r8,31[r1]
FFFFFFFFFFFFDBC4	4A148020		 	lbu		r9,32[r1]
FFFFFFFFFFFFDBC8	4A150021		 	lbu		r10,33[r1]
                  	           		 	; write to sender
FFFFFFFFFFFFDBCC	6013801A		 	sb		r7,26[r1]
FFFFFFFFFFFFDBD0	6014001B		 	sb		r8,27[r1]
FFFFFFFFFFFFDBD4	6014801C		 	sb		r9,28[r1]
FFFFFFFFFFFFDBD8	6015001D		 	sb		r10,29[r1]
                  	           		 	; write destination
FFFFFFFFFFFFDBDC	6011801E		 	sb		r3,30[r1]
FFFFFFFFFFFFDBE0	6012001F		 	sb		r4,31[r1]
FFFFFFFFFFFFDBE4	60128020		 	sb		r5,32[r1]
FFFFFFFFFFFFDBE8	60130021		 	sb		r6,33[r1]
FFFFFFFFFFFFDBEC	           		 eth16:
FFFFFFFFFFFFDBEC	4601D9B4		 	lw		r3,eth_unique_id
FFFFFFFFFFFFDBF0	0A318001		 	addui	r3,r3,#1
FFFFFFFFFFFFDBF4	6601D9B4		 	sw		r3,eth_unique_id
FFFFFFFFFFFFDBF8	60118013		 	sb		r3,19[r1]
FFFFFFFFFFFFDBFC	06319001		 	shrui	r3,r3,#8
FFFFFFFFFFFFDC00	60118012		 	sb		r3,18[r1]
FFFFFFFFFFFFDC04	4A11800E		 	lbu		r3,14[r1]
FFFFFFFFFFFFDC08	1431800F		 	andi	r3,r3,#0xF
FFFFFFFFFFFFDC0C	06318406		 	shlui	r3,r3,#2		; *4
FFFFFFFFFFFFDC10	0A30800E		 	addui	r1,r3,#14		; return datastart in r1
FFFFFFFFFFFFDC14	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFDC18	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFDC1C	47E28010		 	lw		r5,16[sp]
FFFFFFFFFFFFDC20	47E30018		 	lw		r6,24[sp]
FFFFFFFFFFFFDC24	47E38020		 	lw		r7,32[sp]
FFFFFFFFFFFFDC28	47E40028		 	lw		r8,40[sp]
FFFFFFFFFFFFDC2C	47E48030		 	lw		r9,48[sp]
FFFFFFFFFFFFDC30	47E50038		 	lw		r10,56[sp]
FFFFFFFFFFFFDC34	37EF8040		 	ret		#64
                  	           		 
                  	           		 ; Compute IPv4 checksum of header
                  	           		 ; r1 = packet address
                  	           		 ; r2 = data start
                  	           		 ;
FFFFFFFFFFFFDC38	           		 eth_checksum:
FFFFFFFFFFFFDC38	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFDC3C	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFDC40	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFDC44	67E28010		 	sw		r5,16[sp]
                  	           		 	; set checksum to zero
FFFFFFFFFFFFDC48	60100018		 	sb		r0,24[r1]
FFFFFFFFFFFFDC4C	60100019		 	sb		r0,25[r1]
FFFFFFFFFFFFDC50	04318C0A		 	xor		r3,r3,r3		; r3 = sum = zero
FFFFFFFFFFFFDC54	1602000E		 	lw		r4,#14
FFFFFFFFFFFFDC58	           		 eth15:
FFFFFFFFFFFFDC58	02228009		 	mov		r5,r2
FFFFFFFFFFFFDC5C	0E528001		 	subui	r5,r5,#1		; r5 = datastart - 1
FFFFFFFFFFFFDC60	BE428101		 	bge		r4,r5,eth14
FFFFFFFFFFFFDC64	6A121405		 	lbu		r5,[r1+r4]		; shi = [rx_addr+i]
FFFFFFFFFFFFDC68	6A121845		 	lbu		r6,1[r1+r4]		; slo = [rx_addr+i+1]
FFFFFFFFFFFFDC6C	06529006		 	shlui	r5,r5,#8
FFFFFFFFFFFFDC70	04531409		 	or		r5,r5,r6		; shilo
FFFFFFFFFFFFDC74	04328C03		 	addu	r3,r3,r5		; sum = sum + shilo
FFFFFFFFFFFFDC78	0A420002		 	addui	r4,r4,#2		; i = i + 2
FFFFFFFFFFFFDC7C	BE007EEA		 	bra		eth15
FFFFFFFFFFFFDC80	           		 eth14:
FFFFFFFFFFFFDC80	02328009		 	mov		r5,r3			; r5 = sum
FFFFFFFFFFFFDC84	1431FFFF		 	andi	r3,r3,#0xffff
FFFFFFFFFFFFDC88	0652A001		 	shrui	r5,r5,#16
FFFFFFFFFFFFDC8C	04328C03		 	addu	r3,r3,r5
FFFFFFFFFFFFDC90	02318004		 	com		r3,r3
FFFFFFFFFFFFDC94	60118019		 	sb		r3,25[r1]		; low byte
FFFFFFFFFFFFDC98	06319001		 	shrui	r3,r3,#8
FFFFFFFFFFFFDC9C	60118018		 	sb		r3,24[r1]		; high byte
FFFFFFFFFFFFDCA0	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFDCA4	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFDCA8	67E28010		 	sw		r5,16[sp]
FFFFFFFFFFFFDCAC	37EF8018		 	ret		#24	
                  	           		 
                  	           		 ; r1 = packet address
                  	           		 ; returns r1 = 1 if this IP
                  	           		 ;	
FFFFFFFFFFFFDCB0	           		 eth_verifyIP:
FFFFFFFFFFFFDCB0	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFDCB4	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFDCB8	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFDCBC	67E20010		 	sw		r4,16[sp]
FFFFFFFFFFFFDCC0	67E28018		 	sw		r5,24[sp]
FFFFFFFFFFFFDCC4	4A11001E		 	lbu		r2,30[r1]
FFFFFFFFFFFFDCC8	4A11801F		 	lbu		r3,31[r1]
FFFFFFFFFFFFDCCC	4A120020		 	lbu		r4,32[r1]
FFFFFFFFFFFFDCD0	4A128021		 	lbu		r5,33[r1]
                  	           		 	; Check for general broadcast
FFFFFFFFFFFFDCD4	E68000FF		; SETLO
FFFFFFFFFFFFDCD8	BE2D01A9		 	bnei	r2,#0xFF,eth11
FFFFFFFFFFFFDCDC	E68000FF		; SETLO
FFFFFFFFFFFFDCE0	BE3D0169		 	bnei	r3,#0xFF,eth11
FFFFFFFFFFFFDCE4	E68000FF		; SETLO
FFFFFFFFFFFFDCE8	BE4D0129		 	bnei	r4,#0xFF,eth11
FFFFFFFFFFFFDCEC	E68000FF		; SETLO
FFFFFFFFFFFFDCF0	BE5D00E9		 	bnei	r5,#0xFF,eth11
FFFFFFFFFFFFDCF4	           		 eth12:
FFFFFFFFFFFFDCF4	16008001		 	lw		r1,#1
FFFFFFFFFFFFDCF8	           		 eth13:
FFFFFFFFFFFFDCF8	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFDCFC	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFDD00	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFDD04	47E28018		 	lw		r5,24[sp]
FFFFFFFFFFFFDD08	37EF8020		 	ret		#32
FFFFFFFFFFFFDD0C	           		 eth11:
FFFFFFFFFFFFDD0C	02208009		 	mov		r1,r2
FFFFFFFFFFFFDD10	06109006		 	shlui	r1,r1,#8
FFFFFFFFFFFFDD14	04118409		 	or		r1,r1,r3
FFFFFFFFFFFFDD18	06109006		 	shlui	r1,r1,#8
FFFFFFFFFFFFDD1C	04120409		 	or		r1,r1,r4
FFFFFFFFFFFFDD20	06109006		 	shlui	r1,r1,#8
FFFFFFFFFFFFDD24	04128409		 	or		r1,r1,r5
FFFFFFFFFFFFDD28	E6A8012A		; SETLO
FFFFFFFFFFFFDD2C	EEBFFF02		; SETMID
FFFFFFFFFFFFDD30	BE1D7E28		 	beqi	r1,#0xC0A8012A,eth12
FFFFFFFFFFFFDD34	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFDD38	BE007E0A		 	bra		eth13
                  	           		 
                  	           		 
FFFFFFFFFFFFDD3C	           		 eth_main:
FFFFFFFFFFFFDD3C	31FFF66F		 	call	eth_init
FFFFFFFFFFFFDD40	           		 eth_loop:
FFFFFFFFFFFFDD40	0410840A		 	xor		r1,r1,r1		
FFFFFFFFFFFFDD44	E6800000		; SETLO
FFFFFFFFFFFFDD48	EE800400		; SETMID
FFFFFFFFFFFFDD4C	040D0409		 	lw		r1,#0x1_00000000		; memory address zero
FFFFFFFFFFFFDD50	31FFF67D		 	call	eth_request_packet
FFFFFFFFFFFFDD54	31FFF69C		 	call	eth_interpret_packet	; r1 = packet type
                  	           		 
FFFFFFFFFFFFDD58	B2102801		 	bnei	r1,#1,eth10
FFFFFFFFFFFFDD5C	02110009		 	mov		r2,r1					; save off r1, r2 = packet type
FFFFFFFFFFFFDD60	E6800000		; SETLO
FFFFFFFFFFFFDD64	EE800400		; SETMID
FFFFFFFFFFFFDD68	040D0409		 	lw		r1,#0x1_00000000		; memory address zero
FFFFFFFFFFFFDD6C	31FFF72C		 	call	eth_verifyIP
FFFFFFFFFFFFDD70	02118009		 	mov     r3,r1
FFFFFFFFFFFFDD74	02208009		 	mov     r1,r2					; r1 = packet type again
FFFFFFFFFFFFDD78	B2302001		 	bnei	r3,#1,eth10
                  	           		 
FFFFFFFFFFFFDD7C	E6800000		; SETLO
FFFFFFFFFFFFDD80	EE800400		; SETMID
FFFFFFFFFFFFDD84	040D0409		 	lw		r1,#0x1_00000000		; memory address zero
FFFFFFFFFFFFDD88	16010001		 	lw		r2,#1
FFFFFFFFFFFFDD8C	31FFF6C9		 	call	eth_build_packet
FFFFFFFFFFFFDD90	02118009		 	mov		r3,r1					; r3 = icmpstart
FFFFFFFFFFFFDD94	E6800000		; SETLO
FFFFFFFFFFFFDD98	EE800400		; SETMID
FFFFFFFFFFFFDD9C	040D0409		 	lw		r1,#0x1_00000000		; memory address zero
FFFFFFFFFFFFDDA0	6A118010		 	sb		r0,[r1+r3]				; [rx_addr+icmpstart] = 0
FFFFFFFFFFFFDDA4	4A110011		 	lbu		r2,17[r1]
FFFFFFFFFFFFDDA8	0A21000E		 	addui	r2,r2,#14				; r2 = len
FFFFFFFFFFFFDDAC	02230009		 	mov		r6,r2					; r6 = len
FFFFFFFFFFFFDDB0	6A119085		 	lbu		r4,2[r1+r3]				; shi
FFFFFFFFFFFFDDB4	6A1194C5		 	lbu		r5,3[r1+r3]				; slo
FFFFFFFFFFFFDDB8	06421006		 	shlui	r4,r4,#8
FFFFFFFFFFFFDDBC	04429009		 	or		r4,r4,r5				; sum = {shi,slo};
FFFFFFFFFFFFDDC0	02420004		 	com		r4,r4					; sum = ~sum
FFFFFFFFFFFFDDC4	0E420800		 	subui	r4,r4,#0x800			; sum = sum - 0x800
FFFFFFFFFFFFDDC8	02420004		 	com		r4,r4					; sum = ~sum
FFFFFFFFFFFFDDCC	6A1190D0		 	sb		r4,3[r1+r3]
FFFFFFFFFFFFDDD0	06421001		 	shrui	r4,r4,#8
FFFFFFFFFFFFDDD4	6A119090		 	sb		r4,2[r1+r3]
FFFFFFFFFFFFDDD8	02310009		 	mov		r2,r3
FFFFFFFFFFFFDDDC	31FFF70E		 	call	eth_checksum
FFFFFFFFFFFFDDE0	E6800000		; SETLO
FFFFFFFFFFFFDDE4	EE800400		; SETMID
FFFFFFFFFFFFDDE8	040D0409		 	lw		r1,#0x1_00000000		; memory address zero
FFFFFFFFFFFFDDEC	02610009		 	mov		r2,r6
FFFFFFFFFFFFDDF0	31FFF6B7		 	call	eth_send_packet
FFFFFFFFFFFFDDF4	33FFF750		 	jmp		eth_loop
FFFFFFFFFFFFDDF8	           		 eth10:
                  	           		 	; r2 = rx_addr
FFFFFFFFFFFFDDF8	B21FD202		 	bnei	r1,#2,eth_loop		; Do we have ARP ?
                  	           		 ;	xor		r2,r2,r2			; memory address zero
FFFFFFFFFFFFDDFC	E6B5E100		; SETLO
FFFFFFFFFFFFDE00	EE800017		; SETMID
FFFFFFFFFFFFDE04	040D0809		 	lw		r2,#1_00000000
                  	           		 	; get the opcode
FFFFFFFFFFFFDE08	4A268015		 	lbu		r13,21[r2]
FFFFFFFFFFFFDE0C	B2DFCD01		 	bnei	r13,#1,eth_loop		; ARP request
                  	           		 	; get destination IP address
FFFFFFFFFFFFDE10	4A248026		 	lbu		r9,38[r2]
FFFFFFFFFFFFDE14	4A250027		 	lbu		r10,39[r2]
FFFFFFFFFFFFDE18	4A258028		 	lbu		r11,40[r2]
FFFFFFFFFFFFDE1C	4A260029		 	lbu		r12,41[r2]
                  	           		 	; set r15 = destination IP
FFFFFFFFFFFFDE20	02978009		 	mov		r15,r9
FFFFFFFFFFFFDE24	06F79006		 	shlui	r15,r15,#8
FFFFFFFFFFFFDE28	04F53C09		 	or		r15,r15,r10
FFFFFFFFFFFFDE2C	06F79006		 	shlui	r15,r15,#8
FFFFFFFFFFFFDE30	04F5BC09		 	or		r15,r15,r11
FFFFFFFFFFFFDE34	06F79006		 	shlui	r15,r15,#8
FFFFFFFFFFFFDE38	04F63C09		 	or		r15,r15,r12
                  	           		 	; Is it our IP ?
FFFFFFFFFFFFDE3C	E6A8012A		; SETLO
FFFFFFFFFFFFDE40	EEBFFF02		; SETMID
FFFFFFFFFFFFDE44	BEFD77E9		 	bnei	r15,#0xC0A8012A,eth_loop; //192.168.1.42
                  	           		 	; get source IP address
FFFFFFFFFFFFDE48	4A22801C		 	lbu		r5,28[r2]
FFFFFFFFFFFFDE4C	4A23001D		 	lbu		r6,29[r2]
FFFFFFFFFFFFDE50	4A23801E		 	lbu		r7,30[r2]
FFFFFFFFFFFFDE54	4A24001F		 	lbu		r8,31[r2]
                  	           		 	; set r14 = source IP
FFFFFFFFFFFFDE58	02570009		 	mov		r14,r5
FFFFFFFFFFFFDE5C	06E71006		 	shlui	r14,r14,#8
FFFFFFFFFFFFDE60	04E33809		 	or		r14,r14,r6
FFFFFFFFFFFFDE64	06E71006		 	shlui	r14,r14,#8
FFFFFFFFFFFFDE68	04E3B809		 	or		r14,r14,r7
FFFFFFFFFFFFDE6C	06E71006		 	shlui	r14,r14,#8
FFFFFFFFFFFFDE70	04E43809		 	or		r14,r14,r8
                  	           		 	; Get the source MAC address
FFFFFFFFFFFFDE74	4A280016		 	lbu		r16,22[r2]
FFFFFFFFFFFFDE78	4A288017		 	lbu		r17,23[r2]
FFFFFFFFFFFFDE7C	4A290018		 	lbu		r18,24[r2]
FFFFFFFFFFFFDE80	4A298019		 	lbu		r19,25[r2]
FFFFFFFFFFFFDE84	4A2A001A		 	lbu		r20,26[r2]
FFFFFFFFFFFFDE88	4A2A801B		 	lbu		r21,27[r2]
                  	           		 	; write to destination header
FFFFFFFFFFFFDE8C	60280000		 	sb		r16,[r2]
FFFFFFFFFFFFDE90	60288001		 	sb		r17,1[r2]
FFFFFFFFFFFFDE94	60290002		 	sb		r18,2[r2]
FFFFFFFFFFFFDE98	60298003		 	sb		r19,3[r2]
FFFFFFFFFFFFDE9C	602A0004		 	sb		r20,4[r2]
FFFFFFFFFFFFDEA0	602A8005		 	sb		r21,5[r2]
                  	           		 	; and write to ARP destination
FFFFFFFFFFFFDEA4	60280020		 	sb		r16,32[r2]
FFFFFFFFFFFFDEA8	60288021		 	sb		r17,33[r2]
FFFFFFFFFFFFDEAC	60290022		 	sb		r18,34[r2]
FFFFFFFFFFFFDEB0	60298023		 	sb		r19,35[r2]
FFFFFFFFFFFFDEB4	602A0024		 	sb		r20,36[r2]
FFFFFFFFFFFFDEB8	602A8025		 	sb		r21,37[r2]
                  	           		 	; write to source header
                  	           		 ;	stbc	#0x00,6[r2]
                  	           		 ;	stbc	#0xFF,7[r2]
                  	           		 ;	stbc	#0xEE,8[r2]
                  	           		 ;	stbc	#0xF0,9[r2]
                  	           		 ;	stbc	#0xDA,10[r2]
                  	           		 ;	stbc	#0x42,11[r2]
FFFFFFFFFFFFDEBC	60200006		 	sb		r0,6[r2]
FFFFFFFFFFFFDEC0	160080FF		 	lw		r1,#0xFF
FFFFFFFFFFFFDEC4	60208007		 	sb		r1,7[r2]
FFFFFFFFFFFFDEC8	160080EE		 	lw		r1,#0xEE
FFFFFFFFFFFFDECC	60208008		 	sb		r1,8[r2]
FFFFFFFFFFFFDED0	160080F0		 	lw		r1,#0xF0
FFFFFFFFFFFFDED4	60208009		 	sb		r1,9[r2]
FFFFFFFFFFFFDED8	160080DA		 	lw		r1,#0xDA
FFFFFFFFFFFFDEDC	6020800A		 	sb		r1,10[r2]
FFFFFFFFFFFFDEE0	16008042		 	lw		r1,#0x42
FFFFFFFFFFFFDEE4	6020800B		 	sb		r1,11[r2]
                  	           		 	; write to ARP source
                  	           		 ;	stbc	#0x00,22[r2]
                  	           		 ;	stbc	#0xFF,23[r2]
                  	           		 ;	stbc	#0xEE,24[r2]
                  	           		 ;	stbc	#0xF0,25[r2]
                  	           		 ;	stbc	#0xDA,26[r2]
                  	           		 ;	stbc	#0x42,27[r2]
FFFFFFFFFFFFDEE8	60200016		 	sb		r0,22[r2]
FFFFFFFFFFFFDEEC	160080FF		 	lw		r1,#0xFF
FFFFFFFFFFFFDEF0	60208017		 	sb		r1,23[r2]
FFFFFFFFFFFFDEF4	160080EE		 	lw		r1,#0xEE
FFFFFFFFFFFFDEF8	60208018		 	sb		r1,24[r2]
FFFFFFFFFFFFDEFC	160080F0		 	lw		r1,#0xF0
FFFFFFFFFFFFDF00	60208019		 	sb		r1,25[r2]
FFFFFFFFFFFFDF04	160080DA		 	lw		r1,#0xDA
FFFFFFFFFFFFDF08	6020801A		 	sb		r1,26[r2]
FFFFFFFFFFFFDF0C	16008042		 	lw		r1,#0x42
FFFFFFFFFFFFDF10	6020801B		 	sb		r1,27[r2]
                  	           		 	; swap sender / destination IP
                  	           		 	; write sender
FFFFFFFFFFFFDF14	6024801C		 	sb		r9,28[r2]
FFFFFFFFFFFFDF18	6025001D		 	sb		r10,29[r2]
FFFFFFFFFFFFDF1C	6025801E		 	sb		r11,30[r2]
FFFFFFFFFFFFDF20	6026001F		 	sb		r12,31[r2]
                  	           		 	; write destination
FFFFFFFFFFFFDF24	60228026		 	sb		r5,38[r2]
FFFFFFFFFFFFDF28	60230027		 	sb		r6,39[r2]
FFFFFFFFFFFFDF2C	60238028		 	sb		r7,40[r2]
FFFFFFFFFFFFDF30	60240029		 	sb		r8,41[r2]
                  	           		 	; change request to reply
                  	           		 ;	stbc	#2,21[r2]
FFFFFFFFFFFFDF34	16008002		 	lw		r1,#2
FFFFFFFFFFFFDF38	60208015		 	sb		r1,21[r2]
FFFFFFFFFFFFDF3C	02208009		 	mov		r1,r2			; r1 = packet address
FFFFFFFFFFFFDF40	1601002A		 	lw		r2,#0x2A		; r2 = packet length
FFFFFFFFFFFFDF44	31FFF6B7		 	call	eth_send_packet
FFFFFFFFFFFFDF48	33FFF750		 	jmp		eth_loop
                  	           		 
                  	           		 	
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
                  	           		 ;****************************************************************;
                  	           		 ;                                                                ;
                  	           		 ;		Tiny BASIC for the Raptor64                              ;
                  	           		 ;                                                                ;
                  	           		 ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                  	           		 ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                  	           		 ; Adapted to the 68000 by:                                       ;
                  	           		 ;	Gordon brndly						                         ;
                  	           		 ;	12147 - 51 Street					                         ;
                  	           		 ;	Edmonton AB  T5W 3G8					                     ;
                  	           		 ;	Canada							                             ;
                  	           		 ;	(updated mailing address for 1996)			                 ;
                  	           		 ;                                                                ;
                  	           		 ; Adapted to the Raptor64 by:                                    ;
                  	           		 ;    Robert Finch                                                ;
                  	           		 ;    Ontario, Canada                                             ;
                  	           		 ;	 robfinch<remove>@opencores.org	                             ;  
                  	           		 ;****************************************************************;
                  	           		 ;    Copyright (C) 2012 by Robert Finch. This program may be	 ;
                  	           		 ;    freely distributed for personal use only. All commercial	 ;
                  	           		 ;		       rights are reserved.			                     ;
                  	           		 ;****************************************************************;
                  	           		 ;
                  	           		 ; Register Usage
                  	           		 ; r8 = text pointer (global usage)
                  	           		 ; r3,r4 = inputs parameters to subroutines
                  	           		 ; r2 = return value
                  	           		 ;
                  	           		 ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                  	           		 ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                  	           		 ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                  	           		 
                  	           		 ;
                  	           		 ; Standard jump table. You can change these addresses if you are
                  	           		 ; customizing this interpreter for a different environment.
                  	           		 ;
FFFFFFFFFFFFDF4C	           		 GOSTART:	
FFFFFFFFFFFFDF4C	33FFF7E0		 		jmp	CSTART	;	Cold Start entry point
FFFFFFFFFFFFDF50	           		 GOWARM:	
FFFFFFFFFFFFDF50	33FFF801		 		jmp	WSTART	;	Warm Start entry point
FFFFFFFFFFFFDF54	           		 GOOUT:	
FFFFFFFFFFFFDF54	33FFFD9B		 		jmp	OUTC	;	Jump to character-out routine
FFFFFFFFFFFFDF58	           		 GOIN:	
FFFFFFFFFFFFDF58	33FFFD9C		 		jmp	INC		;Jump to character-in routine
FFFFFFFFFFFFDF5C	           		 GOAUXO:	
FFFFFFFFFFFFDF5C	33FFFDA3		 		jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFFFFFFFFFFDF60	           		 GOAUXI:	
FFFFFFFFFFFFDF60	33FFFD9D		 		jmp	AUXIN	;	Jump to auxiliary-in routine
FFFFFFFFFFFFDF64	           		 GOBYE:	
FFFFFFFFFFFFDF64	33FFFE28		 		jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                  	           		 ;
                  	           		 ; Modifiable system constants:
                  	           		 ;
FFFFFFFFFFFFDF68	           		 		align	8
FFFFFFFFFFFFDF68 0000000010060000	 TXTBGN	dw	0x000000001_00600000	;TXT		;beginning of program memory
FFFFFFFFFFFFDF70 00000000107FFFF8	 ENDMEM	dw	0x000000001_07FFFFF8	;	end of available memory
                  	           		 ;
                  	           		 ; The main interpreter starts here:
                  	           		 ;
                  	           		 ; Usage
                  	           		 ; r1 = temp
                  	           		 ; r8 = text buffer pointer
                  	           		 ; r12 = end of text in text buffer
                  	           		 ;
FFFFFFFFFFFFDF78 0000000000000000	 	align	16
FFFFFFFFFFFFDF80	           		 	align	16
FFFFFFFFFFFFDF80	           		 CSTART:
                  	           		 	; First save off the link register and OS sp value
FFFFFFFFFFFFDF80	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFDF84	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDF88	660F1088		 	sw		sp,OSSP
FFFFFFFFFFFFDF8C	460F5F70		 	lw		sp,ENDMEM	; initialize stack pointer
FFFFFFFFFFFFDF90	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFDF94	67EF8000		 	sw      lr,[sp]    ; save off return address
FFFFFFFFFFFFDF98	60001417		 	sb		r0,CursorRow	; set screen output
FFFFFFFFFFFFDF9C	60001418		 	sb		r0,CursorCol
FFFFFFFFFFFFDFA0	6000141A		 	sb		r0,CursorFlash
FFFFFFFFFFFFDFA4	6400104C		 	sh		r0,pos
FFFFFFFFFFFFDFA8	E6800020		; SETLO
FFFFFFFFFFFFDFAC	EE800040		; SETMID
FFFFFFFFFFFFDFB0	040D0809		 	lw		r2,#0x10000020	; black chars, yellow background
                  	           		 ;	sh		r2,charToPrint
FFFFFFFFFFFFDFB4	31FFF011		 	call	ClearScreen
FFFFFFFFFFFFDFB8	9A00F6B8		 	lea		r1,msgInit	;	tell who we are
                  	           		 ;	call	PRMESGAUX
FFFFFFFFFFFFDFBC	9A00F6B8		 	lea		r1,msgInit	;	tell who we are
FFFFFFFFFFFFDFC0	31FFFD81		 	call	PRMESG
FFFFFFFFFFFFDFC4	4600DF68		 	lw		r1,TXTBGN	;	init. end-of-program pointer
FFFFFFFFFFFFDFC8	660090D0		 	sw		r1,TXTUNF
FFFFFFFFFFFFDFCC	4600DF70		 	lw		r1,ENDMEM	;	get address of end of memory
FFFFFFFFFFFFDFD0	0E109000		 	subui	r1,r1,#4096	; 	reserve 4K for the stack
FFFFFFFFFFFFDFD4	660090F8		 	sw		r1,STKBOT
FFFFFFFFFFFFDFD8	E6804000		; SETLO
FFFFFFFFFFFFDFDC	041D0405		 	subui   r1,r1,#16384 ;   1000 vars
FFFFFFFFFFFFDFE0	660090D8		 	sw      r1,VARBGN
FFFFFFFFFFFFDFE4	31FFF905		 	call    clearVars   ; clear the variable area
FFFFFFFFFFFFDFE8	460090D8		 	lw      r1,VARBGN   ; calculate number of bytes free
FFFFFFFFFFFFDFEC	460190D0		 	lw		r3,TXTUNF
FFFFFFFFFFFFDFF0	04118405		 	subu    r1,r1,r3
FFFFFFFFFFFFDFF4	E0800000		 	setlo	r2,#0
FFFFFFFFFFFFDFF8	31FFFCCC		 	call	PRTNUM
FFFFFFFFFFFFDFFC	9A00F760		 	lea		r1,msgBytesFree
FFFFFFFFFFFFE000	31FFFD81		 	call	PRMESG
FFFFFFFFFFFFE004	           		 WSTART:
FFFFFFFFFFFFE004	660010A8		 	sw		r0,LOPVAR   ; initialize internal variables
FFFFFFFFFFFFE008	66001098		 	sw		r0,STKGOS
FFFFFFFFFFFFE00C	66001090		 	sw		r0,CURRNT	;	current line number pointer = 0
FFFFFFFFFFFFE010	460F5F70		 	lw		sp,ENDMEM	;	init S.P. again, just in case
FFFFFFFFFFFFE014	9A00F76E		 	lea		r1,msgReady	;	display "Ready"
FFFFFFFFFFFFE018	31FFFD81		 	call	PRMESG
FFFFFFFFFFFFE01C	           		 ST3:
FFFFFFFFFFFFE01C	E040003E		 	setlo	r1,#'>'		; Prompt with a '>' and
FFFFFFFFFFFFE020	31FFFC1A		 	call	GETLN		; read a line.
FFFFFFFFFFFFE024	31FFFD5E		 	call	TOUPBUF 	; convert to upper case
FFFFFFFFFFFFE028	02860009		 	mov		r12,r8		; save pointer to end of line
FFFFFFFFFFFFE02C	9A04111B		 	lea		r8,BUFFER	; point to the beginning of line
FFFFFFFFFFFFE030	31FFFD3E		 	call	TSTNUM		; is there a number there?
FFFFFFFFFFFFE034	31FFFD55		 	call	IGNBLK		; skip trailing blanks
                  	           		 ; does line no. exist? (or nonzero?)
FFFFFFFFFFFFE038	BE101708		 	beq		r1,r0,DIRECT		; if not, it's a direct statement
FFFFFFFFFFFFE03C	AC1003FF		 	bleu	r1,#0xFFFF,ST2	; see if line no. is <= 16 bits
FFFFFFFFFFFFE040	9A00F78C		 	lea		r1,msgLineRange	; if not, we've overflowed
FFFFFFFFFFFFE044	BE007F2A		 	bra		ERROR
FFFFFFFFFFFFE048	           		 ST2:
                  	           		     ; ugliness - store a character at potentially an
                  	           		     ; odd address (unaligned).
FFFFFFFFFFFFE048	02110009		 	mov		r2,r1       ; r2 = line number
FFFFFFFFFFFFE04C	60817FFE		 	sb		r2,-2[r8]
FFFFFFFFFFFFE050	06211001		 	shrui	r2,r2,#8
FFFFFFFFFFFFE054	60817FFF		 	sb		r2,-1[r8]	; store the binary line no.
FFFFFFFFFFFFE058	0E840002		 	subui	r8,r8,#2
FFFFFFFFFFFFE05C	31FFFC4E		 	call	FNDLN		; find this line in save area
FFFFFFFFFFFFE060	02968009		 	mov		r13,r9		; save possible line pointer
FFFFFFFFFFFFE064	BE1001C8		 	beq		r1,r0,ST4	; if not found, insert
                  	           		 	; here we found the line, so we're replacing the line
                  	           		 	; in the text area
                  	           		 	; first step - delete the line
FFFFFFFFFFFFE068	E0400000		 	setlo	r1,#0
FFFFFFFFFFFFE06C	31FFFC62		 	call	FNDNXT		; find the next line (into r9)
FFFFFFFFFFFFE070	BE100049		 	bne		r1,r0,ST7
FFFFFFFFFFFFE074	BE900108		 	beq		r9,r0,ST6	; no more lines
FFFFFFFFFFFFE078	           		 ST7:
FFFFFFFFFFFFE078	02908009		 	mov		r1,r9		; r1 = pointer to next line
FFFFFFFFFFFFE07C	02D10009		 	mov		r2,r13		; pointer to line to be deleted
FFFFFFFFFFFFE080	460190D0		 	lw		r3,TXTUNF	; points to top of save area
FFFFFFFFFFFFE084	31FFFC6B		 	call	MVUP		; move up to delete
FFFFFFFFFFFFE088	660110D0		 	sw		r2,TXTUNF	; update the end pointer
                  	           		 	; we moved the lines of text after the line being
                  	           		 	; deleted down, so the pointer to the next line
                  	           		 	; needs to be reset
FFFFFFFFFFFFE08C	02D48009		 	mov		r9,r13
FFFFFFFFFFFFE090	BE00006A		 	bra		ST4
                  	           		 	; here there were no more lines, so just move the
                  	           		 	; end of text pointer down
FFFFFFFFFFFFE094	           		 ST6:
FFFFFFFFFFFFE094	660690D0		 	sw		r13,TXTUNF
FFFFFFFFFFFFE098	02D48009		 	mov		r9,r13
FFFFFFFFFFFFE09C	           		 ST4:
                  	           		 	; here we're inserting because the line wasn't found
                  	           		 	; or it was deleted	from the text area
FFFFFFFFFFFFE09C	02C08009		 	mov		r1,r12		; calculate the length of new line
FFFFFFFFFFFFE0A0	04140404		 	sub		r1,r1,r8
FFFFFFFFFFFFE0A4	A41FDE03		 	blei	r1,#3,ST3	; is it just a line no. & CR? if so, it was just a delete
                  	           		 
FFFFFFFFFFFFE0A8	460590D0		 	lw		r11,TXTUNF	; compute new end of text
FFFFFFFFFFFFE0AC	02B50009		 	mov		r10,r11		; r10 = old TXTUNF
FFFFFFFFFFFFE0B0	04B0AC02		 	add		r11,r11,r1		; r11 = new top of TXTUNF (r1=line length)
                  	           		 
FFFFFFFFFFFFE0B4	460090D8		 	lw		r1,VARBGN	; see if there's enough room
FFFFFFFFFFFFE0B8	BEB08064		 	bltu	r11,r1,ST5
FFFFFFFFFFFFE0BC	9A00F867		 	lea		r1,msgTooBig	; if not, say so
FFFFFFFFFFFFE0C0	33FFFC0A		 	jmp		ERROR
                  	           		 
                  	           		 	; open a space in the text area
FFFFFFFFFFFFE0C4	           		 ST5:
FFFFFFFFFFFFE0C4	660590D0		 	sw		r11,TXTUNF	; if so, store new end position
FFFFFFFFFFFFE0C8	02A08009		 	mov		r1,r10		; points to old end of text
FFFFFFFFFFFFE0CC	02B10009		 	mov		r2,r11		; points to new end of text
FFFFFFFFFFFFE0D0	02918009		 	mov		r3,r9       ; points to start of line after insert line
FFFFFFFFFFFFE0D4	31FFFC71		 	call	MVDOWN		; move things out of the way
                  	           		 
                  	           		 	; copy line into text space
FFFFFFFFFFFFE0D8	02808009		 	mov		r1,r8		; set up to do the insertion; move from buffer
FFFFFFFFFFFFE0DC	02D10009		 	mov		r2,r13		; to vacated space
FFFFFFFFFFFFE0E0	02C18009		 	mov		r3,r12		; until end of buffer
FFFFFFFFFFFFE0E4	31FFFC6B		 	call	MVUP		; do it
FFFFFFFFFFFFE0E8	BE0079AA		 	bra		ST3			; go back and get another line
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** Tables *** DIRECT *** EXEC ***
                  	           		 ;
                  	           		 ; This section of the code tests a string against a table. When
                  	           		 ; a match is found, control is transferred to the section of
                  	           		 ; code according to the table.
                  	           		 ;
                  	           		 ; At 'EXEC', r8 should point to the string, r9 should point to
                  	           		 ; the character table, and r10 should point to the execution
                  	           		 ; table. At 'DIRECT', r8 should point to the string, r9 and
                  	           		 ; r10 will be set up to point to TAB1 and TAB1_1, which are
                  	           		 ; the tables of all direct and statement commands.
                  	           		 ;
                  	           		 ; A '.' in the string will terminate the test and the partial
                  	           		 ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                  	           		 ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                  	           		 ;
                  	           		 ; There are two tables: the character table and the execution
                  	           		 ; table. The character table consists of any number of text items.
                  	           		 ; Each item is a string of characters with the last character's
                  	           		 ; high bit set to one. The execution table holds a 32-bit
                  	           		 ; execution addresses that correspond to each entry in the
                  	           		 ; character table.
                  	           		 ;
                  	           		 ; The end of the character table is a 0 byte which corresponds
                  	           		 ; to the default routine in the execution table, which is
                  	           		 ; executed if none of the other table items are matched.
                  	           		 ;
                  	           		 ; Character-matching tables:
                  	           		 
FFFFFFFFFFFFE0EC	           		 TAB1:
FFFFFFFFFFFFE0E8 D453494CBE0079AA	 	db	"LIS",'T'+0x80        ; Direct commands
FFFFFFFFFFFFE0F0 52D7454EC4414F4C	 	db	"RU",'N'+0x80
FFFFFFFFFFFFE0FE	           		 TAB2:
FFFFFFFFFFFFE0F8 454EC5564153CE55	 	db	"NEX",'T'+0x80         ; Direct / statement
FFFFFFFFFFFFE100 47C649D4454CD458	 	db	"GOT",'O'+0x80
FFFFFFFFFFFFE108 C255534F47CF544F	 	db	"GOSU",'B'+0x80
FFFFFFFFFFFFE110 4552CE5255544552	 	db	"RE",'M'+0x80
FFFFFFFFFFFFE118 55504E49D24F46CD	 	db	"INPU",'T'+0x80
FFFFFFFFFFFFE120 4F50D44E495250D4	 	db	"POKE",'C'+0x80
FFFFFFFFFFFFE128 C8454B4F50C3454B	 	db	"POKE",'H'+0x80
FFFFFFFFFFFFE130 4B4F50D7454B4F50	 	db	"POK",'E'+0x80
FFFFFFFFFFFFE138 C55942D04F5453C5	 	db	"BY",'E'+0x80
FFFFFFFFFFFFE140 4C43D34C43D35953	     db  "CL",'R'+0x80
FFFFFFFFFFFFE14E	           		 TAB4:
FFFFFFFFFFFFE148 455000C6434452D2	 	db	"PEEK",'C'+0x80        ;Functions
FFFFFFFFFFFFE150 C84B454550C34B45	 	db	"PEEK",'H'+0x80        ;Functions
FFFFFFFFFFFFE158 454550D74B454550	 	db	"PEE",'K'+0x80         ;Functions
FFFFFFFFFFFFE160 53D34241C44E52CB	 	db	"SIZ",'E'+0x80
FFFFFFFFFFFFE16F	           		 TAB5:
FFFFFFFFFFFFE168 5400D25355C55A49	 	db	"T",'O'+0x80           ;"TO" in "FOR"
FFFFFFFFFFFFE172	           		 TAB6:
FFFFFFFFFFFFE177	           		 TAB8:
FFFFFFFFFFFFE170 3E00D045545300CF	 	db	'>','='+0x80           ;Relational operators
FFFFFFFFFFFFE178 BCBD3CBDBEBE3CBD	 	db	'<'+0x80
FFFFFFFFFFFFE181	           		 TAB9:
FFFFFFFFFFFFE185	           		 TAB10:
FFFFFFFFFFFFE180 00D24F00C44E4100	     db  0
                  	           		 
FFFFFFFFFFFFE188	           		 	.align	8
                  	           		 
                  	           		 ;* Execution address tables:
FFFFFFFFFFFFE188	           		 TAB1_1:
FFFFFFFFFFFFE188 FFFFFFFFFFFFE440	 	dw	LISTX			;Direct commands
FFFFFFFFFFFFE190 FFFFFFFFFFFFE784	 	dw	LOAD
FFFFFFFFFFFFE198 FFFFFFFFFFFFE38C	 	dw	NEW
FFFFFFFFFFFFE1A0 FFFFFFFFFFFFE3A4	 	dw	RUN
FFFFFFFFFFFFE1A8 FFFFFFFFFFFFE830	 	dw	SAVE
FFFFFFFFFFFFE1B0	           		 TAB2_1:
FFFFFFFFFFFFE1B0 FFFFFFFFFFFFE610	 	dw	NEXT		;	Direct / statement
FFFFFFFFFFFFE1B8 FFFFFFFFFFFFE76C	 	dw	LET
FFFFFFFFFFFFE1C0 FFFFFFFFFFFFE680	 	dw	IF
FFFFFFFFFFFFE1C8 FFFFFFFFFFFFE3EC	 	dw	GOTO
FFFFFFFFFFFFE1D0 FFFFFFFFFFFFE520	 	dw	GOSUB
FFFFFFFFFFFFE1D8 FFFFFFFFFFFFE55C	 	dw	RETURN
FFFFFFFFFFFFE1E0 FFFFFFFFFFFFE688	 	dw	IF2			; REM
FFFFFFFFFFFFE1E8 FFFFFFFFFFFFE594	 	dw	FOR
FFFFFFFFFFFFE1F0 FFFFFFFFFFFFE6B0	 	dw	INPUT
FFFFFFFFFFFFE1F8 FFFFFFFFFFFFE488	 	dw	PRINT
FFFFFFFFFFFFE200 FFFFFFFFFFFFE944	 	dw	POKEC
FFFFFFFFFFFFE208 FFFFFFFFFFFFE970	 	dw	POKEH
FFFFFFFFFFFFE210 FFFFFFFFFFFFE99C	 	dw	POKEW
FFFFFFFFFFFFE218 FFFFFFFFFFFFE910	 	dw	POKE
FFFFFFFFFFFFE220 FFFFFFFFFFFFE39C	 	dw	STOP
FFFFFFFFFFFFE228 FFFFFFFFFFFFDF64	 	dw	GOBYE
FFFFFFFFFFFFE230 FFFFFFFFFFFFE9C8	 	dw	SYSX
FFFFFFFFFFFFE238 FFFFFFFFFFFFF690	 	dw	_cls
FFFFFFFFFFFFE240 FFFFFFFFFFFFE40C	 	dw  _clr
FFFFFFFFFFFFE248 FFFFFFFFFFFFF6A4	 	dw	_rdcf
FFFFFFFFFFFFE250 FFFFFFFFFFFFE764	 	dw	DEFLT
FFFFFFFFFFFFE258	           		 TAB4_1:
FFFFFFFFFFFFE258 FFFFFFFFFFFFEE44	 	dw  PEEKC
FFFFFFFFFFFFE260 FFFFFFFFFFFFEE58	 	dw  PEEKH
FFFFFFFFFFFFE268 FFFFFFFFFFFFEE6C	 	dw  PEEKW
FFFFFFFFFFFFE270 FFFFFFFFFFFFEE34	 	dw	PEEK			;Functions
FFFFFFFFFFFFE278 FFFFFFFFFFFFEE9C	 	dw	RND
FFFFFFFFFFFFE280 FFFFFFFFFFFFEF34	 	dw	ABS
FFFFFFFFFFFFE288 FFFFFFFFFFFFEF54	 	dw	SIZEX
FFFFFFFFFFFFE290 FFFFFFFFFFFFEE80	 	dw  USRX
FFFFFFFFFFFFE298 FFFFFFFFFFFFEC58	 	dw	XP40
FFFFFFFFFFFFE2A0	           		 TAB5_1
FFFFFFFFFFFFE2A0 FFFFFFFFFFFFE5AC	 	dw	FR1			;"TO" in "FOR"
FFFFFFFFFFFFE2A8 FFFFFFFFFFFFF024	 	dw	QWHAT
FFFFFFFFFFFFE2B0	           		 TAB6_1
FFFFFFFFFFFFE2B0 FFFFFFFFFFFFE5C0	 	dw	FR2			;"STEP" in "FOR"
FFFFFFFFFFFFE2B8 FFFFFFFFFFFFE5C8	 	dw	FR3
FFFFFFFFFFFFE2C0	           		 TAB8_1
FFFFFFFFFFFFE2C0 FFFFFFFFFFFFEAD8	 	dw	XP11	;>=		Relational operators
FFFFFFFFFFFFE2C8 FFFFFFFFFFFFEAE8	 	dw	XP12	;<>
FFFFFFFFFFFFE2D0 FFFFFFFFFFFFEAF8	 	dw	XP13	;>
FFFFFFFFFFFFE2D8 FFFFFFFFFFFFEB18	 	dw	XP15	;=
FFFFFFFFFFFFE2E0 FFFFFFFFFFFFEB08	 	dw	XP14	;<=
FFFFFFFFFFFFE2E8 FFFFFFFFFFFFEB28	 	dw	XP16	;<
FFFFFFFFFFFFE2F0 FFFFFFFFFFFFEB50	 	dw	XP17
FFFFFFFFFFFFE2F8	           		 TAB9_1
FFFFFFFFFFFFE2F8 FFFFFFFFFFFFEA44	     dw  XP_AND
FFFFFFFFFFFFE300 FFFFFFFFFFFFEA54	     dw  XP_ANDX
FFFFFFFFFFFFE308	           		 TAB10_1
FFFFFFFFFFFFE308 FFFFFFFFFFFFEA0C	     dw  XP_OR
FFFFFFFFFFFFE310 FFFFFFFFFFFFEA1C	     dw  XP_ORX
                  	           		 
FFFFFFFFFFFFE318	           		 	.align	4
                  	           		 
                  	           		 ;*
                  	           		 ; r3 = match flag (trashed)
                  	           		 ; r9 = text table
                  	           		 ; r10 = exec table
                  	           		 ; r11 = trashed
FFFFFFFFFFFFE318	           		 DIRECT:
FFFFFFFFFFFFE318	9A04E0EC		 	lea		r9,TAB1
FFFFFFFFFFFFE31C	9A056188		 	lea		r10,TAB1_1
FFFFFFFFFFFFE320	           		 EXEC:
FFFFFFFFFFFFE320	03F58009		 	mov		r11,lr		; save link reg
FFFFFFFFFFFFE324	31FFFD55		 	call	IGNBLK		; ignore leading blanks
FFFFFFFFFFFFE328	02BF8009		 	mov		lr,r11		; restore link reg
FFFFFFFFFFFFE32C	02858009		 	mov		r11,r8		; save the pointer
FFFFFFFFFFFFE330	E0C00000		 	setlo	r3,#0		; clear match flag
FFFFFFFFFFFFE334	           		 EXLP:
FFFFFFFFFFFFE334	4A808000		 	lbu		r1,[r8]		; get the program character
FFFFFFFFFFFFE338	0A840001		 	addui	r8,r8,#1
FFFFFFFFFFFFE33C	4A910000		 	lbu		r2,[r9]		; get the table character
FFFFFFFFFFFFE340	BE200069		 	bne		r2,r0,EXNGO		; If end of table,
FFFFFFFFFFFFE344	02B40009		 	mov		r8,r11		;	restore the text pointer and...
FFFFFFFFFFFFE348	BE0001EA		 	bra		EXGO		;   execute the default.
FFFFFFFFFFFFE34C	           		 EXNGO:
FFFFFFFFFFFFE34C	BE1181C8		 	beq		r1,r3,EXGO	; Else check for period... if so, execute
FFFFFFFFFFFFE350	1421007F		 	andi	r2,r2,#0x7f	; ignore the table's high bit
FFFFFFFFFFFFE354	BE208108		 	beq		r2,r1,EXMAT;		is there a match?
FFFFFFFFFFFFE358	0AA50008		 	addui	r10,r10,#8	;if not, try the next entry
FFFFFFFFFFFFE35C	02B40009		 	mov		r8,r11		; reset the program pointer
FFFFFFFFFFFFE360	E0C00000		 	setlo	r3,#0		; sorry, no match
FFFFFFFFFFFFE364	           		 EX1:
FFFFFFFFFFFFE364	0A948001		 	addui	r9,r9,#1
FFFFFFFFFFFFE368	4090FFFF		 	lb		r1,-1[r9]	; get to the end of the entry
FFFFFFFFFFFFE36C	BE107FC3		 	bgt		r1,r0,EX1
FFFFFFFFFFFFE370	BE007E2A		 	bra		EXLP		; back for more matching
FFFFFFFFFFFFE374	           		 EXMAT:
FFFFFFFFFFFFE374	E0C0002E		 	setlo	r3,#'.'		; we've got a match so far
FFFFFFFFFFFFE378	0A948001		 	addui	r9,r9,#1
FFFFFFFFFFFFE37C	4090FFFF		 	lb		r1,-1[r9]	; end of table entry?
FFFFFFFFFFFFE380	BE107DA3		 	bgt		r1,r0,EXLP		; if not, go back for more
FFFFFFFFFFFFE384	           		 EXGO:
FFFFFFFFFFFFE384	46A58000		 	lw		r11,[r10]	; execute the appropriate routine
FFFFFFFFFFFFE388	34B00000		 	jal		r0,[r11]
                  	           		 
                  	           		 ;    lb      r1,[r8]     ; get token from text space
                  	           		 ;    bpl
                  	           		 ;    and     r1,#0x7f
                  	           		 ;    shl     r1,#2       ; * 4 - word offset
                  	           		 ;    add     r1,r1,#TAB1_1
                  	           		 ;    lw      r1,[r1]
                  	           		 ;    jmp     [r1]
                  	           		 
                  	           		     
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; What follows is the code to execute direct and statement
                  	           		 ; commands. Control is transferred to these points via the command
                  	           		 ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                  	           		 ; After the command is executed, control is transferred to other
                  	           		 ; sections as follows:
                  	           		 ;
                  	           		 ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                  	           		 ; For 'RUN': go execute the first stored line if any; else go
                  	           		 ; back to the warm start point.
                  	           		 ; For 'GOTO' and 'GOSUB': go execute the target line.
                  	           		 ; For 'RETURN' and 'NEXT'; go back to saved return line.
                  	           		 ; For all others: if 'CURRNT' is 0, go to warm start; else go
                  	           		 ; execute next command. (This is done in 'FINISH'.)
                  	           		 ;
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                  	           		 ;
                  	           		 ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                  	           		 ;
                  	           		 ; 'STOP<CR>' goes back to WSTART
                  	           		 ;
                  	           		 ; 'RUN<CR>' finds the first stored line, stores its address
                  	           		 ; in CURRNT, and starts executing it. Note that only those
                  	           		 ; commands in TAB2 are legal for a stored program.
                  	           		 ;
                  	           		 ; There are 3 more entries in 'RUN':
                  	           		 ; 'RUNNXL' finds next line, stores it's address and executes it.
                  	           		 ; 'RUNTSL' stores the address of this line and executes it.
                  	           		 ; 'RUNSML' continues the execution on same line.
                  	           		 ;
                  	           		 ; 'GOTO expr<CR>' evaluates the expression, finds the target
                  	           		 ; line, and jumps to 'RUNTSL' to do it.
                  	           		 ;
FFFFFFFFFFFFE38C	           		 NEW:
FFFFFFFFFFFFE38C	31FFFBFB		 	call	ENDCHK
FFFFFFFFFFFFE390	4600DF68		 	lw		r1,TXTBGN
FFFFFFFFFFFFE394	660090D0		 	sw		r1,TXTUNF	;	set the end pointer
FFFFFFFFFFFFE398	31FFF905		 	call    clearVars
                  	           		 
FFFFFFFFFFFFE39C	           		 STOP:
FFFFFFFFFFFFE39C	31FFFBFB		 	call	ENDCHK
FFFFFFFFFFFFE3A0	BE00632A		 	bra		WSTART		; WSTART will reset the stack
                  	           		 
FFFFFFFFFFFFE3A4	           		 RUN:
FFFFFFFFFFFFE3A4	31FFFBFB		 	call	ENDCHK
FFFFFFFFFFFFE3A8	46045F68		 	lw		r8,TXTBGN	;	set pointer to beginning
FFFFFFFFFFFFE3AC	66041090		 	sw		r8,CURRNT
FFFFFFFFFFFFE3B0	31FFF905		 	call    clearVars
                  	           		 
FFFFFFFFFFFFE3B4	           		 RUNNXL:					; RUN <next line>
FFFFFFFFFFFFE3B4	46009090		 	lw		r1,CURRNT	; executing a program?
FFFFFFFFFFFFE3B8	BE106268		 	beq		r1,r0,WSTART	; if not, we've finished a direct stat.
FFFFFFFFFFFFE3BC	E0400000		 	setlo	r1,#0	    ; else find the next line number
FFFFFFFFFFFFE3C0	02848009		 	mov		r9,r8
FFFFFFFFFFFFE3C4	31FFFC52		 	call	FNDLNP		; search for the next line
FFFFFFFFFFFFE3C8	BE100069		 	bne		r1,r0,RUNTSL
FFFFFFFFFFFFE3CC	BE900049		 	bne		r9,r0,RUNTSL
FFFFFFFFFFFFE3D0	BE0061AA		 	bra		WSTART		; if we've fallen off the end, stop
                  	           		 
FFFFFFFFFFFFE3D4	           		 RUNTSL:					; RUN <this line>
FFFFFFFFFFFFE3D4	66049090		 	sw		r9,CURRNT	; set CURRNT to point to the line no.
FFFFFFFFFFFFE3D8	9A940002		 	lea		r8,2[r9]	; set the text pointer to
                  	           		 
FFFFFFFFFFFFE3DC	           		 RUNSML:                 ; RUN <same line>
FFFFFFFFFFFFE3DC	31FFFD77		 	call	CHKIO		; see if a control-C was pressed
FFFFFFFFFFFFE3E0	9A04E0FE		 	lea		r9,TAB2		; find command in TAB2
FFFFFFFFFFFFE3E4	9A0561B0		 	lea		r10,TAB2_1
FFFFFFFFFFFFE3E8	BE0079CA		 	bra		EXEC		; and execute it
                  	           		 
FFFFFFFFFFFFE3EC	           		 GOTO:
FFFFFFFFFFFFE3EC	31FFFA7C		 	call	OREXPR		;evaluate the following expression
FFFFFFFFFFFFE3F0	02128009		 	mov     r5,r1
FFFFFFFFFFFFE3F4	31FFFBFB		 	call	ENDCHK		;must find end of line
FFFFFFFFFFFFE3F8	02508009		 	mov     r1,r5
FFFFFFFFFFFFE3FC	31FFFC4E		 	call	FNDLN		; find the target line
FFFFFFFFFFFFE400	BE107EA9		 	bne		r1,r0,RUNTSL		; go do it
FFFFFFFFFFFFE404	9A00F833		 	lea		r1,msgBadGotoGosub
FFFFFFFFFFFFE408	BE00610A		 	bra		ERROR		; no such line no.
                  	           		 
FFFFFFFFFFFFE40C	           		 _clr:
FFFFFFFFFFFFE40C	31FFF905		     call    clearVars
FFFFFFFFFFFFE410	BE00084A		     bra     FINISH
                  	           		 
                  	           		 ; Clear the variable area of memory
FFFFFFFFFFFFE414	           		 clearVars:
FFFFFFFFFFFFE414	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFE418	67E30000		     sw		r6,[sp]
FFFFFFFFFFFFE41C	67EF8008		     sw		lr,8[sp]
FFFFFFFFFFFFE420	E1800800		     setlo   r6,#2048    ; number of words to clear
FFFFFFFFFFFFE424	460090D8		     lw      r1,VARBGN
FFFFFFFFFFFFE428	           		 cv1:
FFFFFFFFFFFFE428	66100000		     sw      r0,[r1]
FFFFFFFFFFFFE42C	08108008		     add     r1,r1,#8
FFFFFFFFFFFFE430	BE037FCF		     loop	r6,cv1
FFFFFFFFFFFFE434	47EF8008		     lw		lr,8[sp]
FFFFFFFFFFFFE438	47E30000		     lw		r6,[sp]
FFFFFFFFFFFFE43C	37EF8010		     ret		#16
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; LIST
                  	           		 ;
                  	           		 ; LISTX has two forms:
                  	           		 ; 'LIST<CR>' lists all saved lines
                  	           		 ; 'LIST #<CR>' starts listing at the line #
                  	           		 ; Control-S pauses the listing, control-C stops it.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE440	           		 LISTX:
FFFFFFFFFFFFE440	31FFFD3E		 	call	TSTNUM		; see if there's a line no.
FFFFFFFFFFFFE444	02128009		 	mov     r5,r1
FFFFFFFFFFFFE448	31FFFBFB		 	call	ENDCHK		; if not, we get a zero
FFFFFFFFFFFFE44C	02508009		 	mov     r1,r5
FFFFFFFFFFFFE450	31FFFC4E		 	call	FNDLN		; find this or next line
FFFFFFFFFFFFE454	           		 LS1:
FFFFFFFFFFFFE454	BE100049		 	bne		r1,r0,LS4
FFFFFFFFFFFFE458	BE905D68		 	beq		r9,r0,WSTART	; warm start if we passed the end
FFFFFFFFFFFFE45C	           		 LS4:
FFFFFFFFFFFFE45C	02908009		 	mov		r1,r9
FFFFFFFFFFFFE460	31FFFD1E		 	call	PRTLN		; print the line
FFFFFFFFFFFFE464	02148009		 	mov		r9,r1		; set pointer for next
FFFFFFFFFFFFE468	31FFFD77		 	call	CHKIO		; check for listing halt request
FFFFFFFFFFFFE46C	BE100088		 	beq		r1,r0,LS3
FFFFFFFFFFFFE470	B2100313		 	bnei	r1,#CTRLS,LS3	; pause the listing?
FFFFFFFFFFFFE474	           		 LS2:
FFFFFFFFFFFFE474	31FFFD77		 	call	CHKIO		; if so, wait for another keypress
FFFFFFFFFFFFE478	BE107FE8		 	beq		r1,r0,LS2
FFFFFFFFFFFFE47C	           		 LS3:
FFFFFFFFFFFFE47C	E0400000		 	setlo	r1,#0
FFFFFFFFFFFFE480	31FFFC52		 	call	FNDLNP		; find the next line
FFFFFFFFFFFFE484	BE007E8A		 	bra		LS1
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                  	           		 ; where '....' is a list of expressions, formats, back-arrows,
                  	           		 ; and strings.	These items a separated by commas.
                  	           		 ;
                  	           		 ; A format is a pound sign followed by a number.  It controls
                  	           		 ; the number of spaces the value of an expression is going to
                  	           		 ; be printed in.  It stays effective for the rest of the print
                  	           		 ; command unless changed by another format.  If no format is
                  	           		 ; specified, 11 positions will be used.
                  	           		 ;
                  	           		 ; A string is quoted in a pair of single- or double-quotes.
                  	           		 ;
                  	           		 ; An underline (back-arrow) means generate a <CR> without a <LF>
                  	           		 ;
                  	           		 ; A <CR LF> is generated after the entire list has been printed
                  	           		 ; or if the list is empty.  If the list ends with a semicolon,
                  	           		 ; however, no <CR LF> is generated.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE488	           		 PRINT:
FFFFFFFFFFFFE488	1602800B		 	lw		r5,#11		; D4 = number of print spaces
FFFFFFFFFFFFE48C	E0C0003A		 	setlo	r3,#':'
FFFFFFFFFFFFE490	9A0264A0		 	lea		r4,PR2
FFFFFFFFFFFFE494	31FFFD30		 	call	TSTC		; if null list and ":"
FFFFFFFFFFFFE498	31FFF135		 	call	CRLF		; give CR-LF and continue
FFFFFFFFFFFFE49C	BE007A0A		 	bra		RUNSML		;		execution on the same line
FFFFFFFFFFFFE4A0	           		 PR2:
FFFFFFFFFFFFE4A0	E0C0000D		 	setlo	r3,#CR
FFFFFFFFFFFFE4A4	9A0264B4		 	lea		r4,PR0
FFFFFFFFFFFFE4A8	31FFFD30		 	call	TSTC		;if null list and <CR>
FFFFFFFFFFFFE4AC	31FFF135		 	call	CRLF		;also give CR-LF and
FFFFFFFFFFFFE4B0	BE00782A		 	bra		RUNNXL		;execute the next line
FFFFFFFFFFFFE4B4	           		 PR0:
FFFFFFFFFFFFE4B4	E0C00023		 	setlo	r3,#'#'
FFFFFFFFFFFFE4B8	9A0264CC		 	lea		r4,PR1
FFFFFFFFFFFFE4BC	31FFFD30		 	call	TSTC		;else is it a format?
FFFFFFFFFFFFE4C0	31FFFA7C		 	call	OREXPR		; yes, evaluate expression
FFFFFFFFFFFFE4C4	04101409		 	lw		r5,r1		; and save it as print width
FFFFFFFFFFFFE4C8	BE00012A		 	bra		PR3		; look for more to print
FFFFFFFFFFFFE4CC	           		 PR1:
FFFFFFFFFFFFE4CC	E0C00024		 	setlo	r3,#'$'
FFFFFFFFFFFFE4D0	9A0264E4		 	lea		r4,PR4
FFFFFFFFFFFFE4D4	31FFFD30		 	call	TSTC	;	is character expression? (MRL)
FFFFFFFFFFFFE4D8	31FFFA7C		 	call	OREXPR	;	yep. Evaluate expression (MRL)
FFFFFFFFFFFFE4DC	31FFF7D5		 	call	GOOUT	;	print low byte (MRL)
FFFFFFFFFFFFE4E0	BE00006A		 	bra		PR3		;look for more. (MRL)
FFFFFFFFFFFFE4E4	           		 PR4:
FFFFFFFFFFFFE4E4	31FFFCA9		 	call	QTSTG	;	is it a string?
                  	           		 	; the following branch must occupy only two bytes!
FFFFFFFFFFFFE4E8	BE00010A		 	bra		PR8		;	if not, must be an expression
FFFFFFFFFFFFE4EC	           		 PR3:
FFFFFFFFFFFFE4EC	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFE4F0	9A026500		 	lea		r4,PR6
FFFFFFFFFFFFE4F4	31FFFD30		 	call	TSTC	;	if ",", go find next
FFFFFFFFFFFFE4F8	31FFFBEC		 	call	FIN		;in the list.
FFFFFFFFFFFFE4FC	BE007DCA		 	bra		PR0
FFFFFFFFFFFFE500	           		 PR6:
FFFFFFFFFFFFE500	31FFF135		 	call	CRLF		;list ends here
FFFFFFFFFFFFE504	BE0000AA		 	bra		FINISH
FFFFFFFFFFFFE508	           		 PR8:
FFFFFFFFFFFFE508	31FFFA7C		 	call	OREXPR		; evaluate the expression
FFFFFFFFFFFFE50C	04500809		 	lw		r2,r5		; set the width
FFFFFFFFFFFFE510	31FFFCCC		 	call	PRTNUM		; print its value
FFFFFFFFFFFFE514	BE007ECA		 	bra		PR3			; more to print?
                  	           		 
FFFFFFFFFFFFE518	           		 FINISH:
FFFFFFFFFFFFE518	31FFFBEC		 	call	FIN		; Check end of command
FFFFFFFFFFFFE51C	33FFFC09		 	jmp		QWHAT	; print "What?" if wrong
                  	           		 
                  	           		 
                  	           		 ;*******************************************************************
                  	           		 ;
                  	           		 ; *** GOSUB *** & RETURN ***
                  	           		 ;
                  	           		 ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                  	           		 ; except that the current text pointer, stack pointer, etc. are
                  	           		 ; saved so that execution can be continued after the subroutine
                  	           		 ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                  	           		 ; recursive), the save area must be stacked.  The stack pointer
                  	           		 ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                  	           		 ; If we are in the main routine, 'STKGOS' is zero (this was done
                  	           		 ; in the initialization section of the interpreter), but we still
                  	           		 ; save it as a flag for no further 'RETURN's.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE520	           		 GOSUB:
FFFFFFFFFFFFE520	31FFFC80		 	call	PUSHA		; save the current 'FOR' parameters
FFFFFFFFFFFFE524	31FFFA7C		 	call	OREXPR		; get line number
FFFFFFFFFFFFE528	31FFFC4E		 	call	FNDLN		; find the target line
FFFFFFFFFFFFE52C	BE100069		 	bne		r1,r0,gosub1
FFFFFFFFFFFFE530	9A00F833		 	lea		r1,msgBadGotoGosub
FFFFFFFFFFFFE534	BE0057AA		 	bra		ERROR		; if not there, say "How?"
FFFFFFFFFFFFE538	           		 gosub1:
FFFFFFFFFFFFE538	0DEF0018		 	sub		sp,sp,#24
FFFFFFFFFFFFE53C	67E40000		 	sw		r8,[sp]		; save text pointer
FFFFFFFFFFFFE540	46009090		 	lw		r1,CURRNT
FFFFFFFFFFFFE544	67E08008		 	sw		r1,8[sp]	; found it, save old 'CURRNT'...
FFFFFFFFFFFFE548	46009098		 	lw		r1,STKGOS
FFFFFFFFFFFFE54C	67E08010		 	sw		r1,16[sp]	; and 'STKGOS'
FFFFFFFFFFFFE550	660010A8		 	sw		r0,LOPVAR	; load new values
FFFFFFFFFFFFE554	660F1098		 	sw		sp,STKGOS
FFFFFFFFFFFFE558	BE0073EA		 	bra		RUNTSL
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                  	           		 ; returns the execution to the command after the most recent
                  	           		 ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                  	           		 ; a 'GOSUB' and is thus an error.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE55C	           		 RETURN:
FFFFFFFFFFFFE55C	31FFFBFB		 	call	ENDCHK		; there should be just a <CR>
FFFFFFFFFFFFE560	46009098		 	lw		r1,STKGOS	; get old stack pointer
FFFFFFFFFFFFE564	BE100069		 	bne		r1,r0,return1
FFFFFFFFFFFFE568	9A00F850		 	lea		r1,msgRetWoGosub
FFFFFFFFFFFFE56C	BE0055EA		 	bra		ERROR		; if zero, it doesn't exist
FFFFFFFFFFFFE570	           		 return1:
FFFFFFFFFFFFE570	021F0009		 	mov		sp,r1		; else restore it
FFFFFFFFFFFFE574	47E08010		 	lw		r1,16[sp]
FFFFFFFFFFFFE578	66009098		 	sw		r1,STKGOS	; and the old 'STKGOS'
FFFFFFFFFFFFE57C	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFE580	66009090		 	sw		r1,CURRNT	; and the old 'CURRNT'
FFFFFFFFFFFFE584	47E40000		 	lw		r8,[sp]		; and the old text pointer
FFFFFFFFFFFFE588	09EF0018		 	add		sp,sp,#24
FFFFFFFFFFFFE58C	31FFFC73		 	call	POPA		;and the old 'FOR' parameters
FFFFFFFFFFFFE590	BE007C4A		 	bra		FINISH		;and we are back home
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** FOR *** & NEXT ***
                  	           		 ;
                  	           		 ; 'FOR' has two forms:
                  	           		 ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                  	           		 ; The second form means the same thing as the first form with a
                  	           		 ; STEP of positive 1.  The interpreter will find the variable 'var'
                  	           		 ; and set its value to the current value of 'exp1'.  It also
                  	           		 ; evaluates 'exp2' and 'exp1' and saves all these together with
                  	           		 ; the text pointer, etc. in the 'FOR' save area, which consists of
                  	           		 ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                  	           		 ; already something in the save area (indicated by a non-zero
                  	           		 ; 'LOPVAR'), then the old save area is saved on the stack before
                  	           		 ; the new values are stored.  The interpreter will then dig in the
                  	           		 ; stack and find out if this same variable was used in another
                  	           		 ; currently active 'FOR' loop.  If that is the case, then the old
                  	           		 ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE594	           		 FOR:
FFFFFFFFFFFFE594	31FFFC80		 	call	PUSHA		; save the old 'FOR' save area
FFFFFFFFFFFFE598	31FFFBDA		 	call	SETVAL		; set the control variable
FFFFFFFFFFFFE59C	660090A8		 	sw		r1,LOPVAR	; save its address
FFFFFFFFFFFFE5A0	9A04E16F		 	lea		r9,TAB5
FFFFFFFFFFFFE5A4	9A0562A0		 	lea		r10,TAB5_1; use 'EXEC' to test for 'TO'
FFFFFFFFFFFFE5A8	33FFF8C8		 	jmp		EXEC
FFFFFFFFFFFFE5AC	           		 FR1:
FFFFFFFFFFFFE5AC	31FFFA7C		 	call	OREXPR		; evaluate the limit
FFFFFFFFFFFFE5B0	660090B8		 	sw		r1,LOPLMT	; save that
FFFFFFFFFFFFE5B4	9A04E172		 	lea		r9,TAB6
FFFFFFFFFFFFE5B8	9A0562B0		 	lea		r10,TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFFFFFFFFFFE5BC	33FFF8C8		 	jmp		EXEC
FFFFFFFFFFFFE5C0	           		 FR2:
FFFFFFFFFFFFE5C0	31FFFA7C		 	call	OREXPR		; found it, get the step value
FFFFFFFFFFFFE5C4	BE00004A		 	bra		FR4
FFFFFFFFFFFFE5C8	           		 FR3:
FFFFFFFFFFFFE5C8	E0400001		 	setlo	r1,#1		; not found, step defaults to 1
FFFFFFFFFFFFE5CC	           		 FR4:
FFFFFFFFFFFFE5CC	660090B0		 	sw		r1,LOPINC	; save that too
FFFFFFFFFFFFE5D0	           		 FR5:
FFFFFFFFFFFFE5D0	46011090		 	lw		r2,CURRNT
FFFFFFFFFFFFE5D4	660110C0		 	sw		r2,LOPLN	; save address of current line number
FFFFFFFFFFFFE5D8	660410C8		 	sw		r8,LOPPT	; and text pointer
FFFFFFFFFFFFE5DC	05E00C09		 	lw		r3,sp		; dig into the stack to find 'LOPVAR'
FFFFFFFFFFFFE5E0	460310A8		 	lw		r6,LOPVAR
FFFFFFFFFFFFE5E4	BE00004A		 	bra		FR7
FFFFFFFFFFFFE5E8	           		 FR6:
FFFFFFFFFFFFE5E8	0A318028		 	addui	r3,r3,#40	; look at next stack frame
FFFFFFFFFFFFE5EC	           		 FR7:
FFFFFFFFFFFFE5EC	46310000		 	lw		r2,[r3]		; is it zero?
FFFFFFFFFFFFE5F0	BE2000E8		 	beq		r2,r0,FR8	; if so, we're done
FFFFFFFFFFFFE5F4	BE237FA9		 	bne		r2,r6,FR6	; same as current LOPVAR? nope, look some more
                  	           		 
FFFFFFFFFFFFE5F8	04300409		     lw      r1,r3       ; Else remove 5 long words from...
FFFFFFFFFFFFE5FC	0A310028		 	addui	r2,r3,#40   ; inside the stack.
FFFFFFFFFFFFE600	05E00C09		 	lw		r3,sp		
FFFFFFFFFFFFE604	31FFFC71		 	call	MVDOWN
FFFFFFFFFFFFE608	09EF0028		 	add		sp,sp,#40	; set the SP 5 long words up
FFFFFFFFFFFFE60C	           		 FR8:
FFFFFFFFFFFFE60C	BE00786A		     bra	    FINISH		; and continue execution
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'NEXT var' serves as the logical (not necessarily physical) end
                  	           		 ; of the 'FOR' loop.  The control variable 'var' is checked with
                  	           		 ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                  	           		 ; the stack to find the right one and purges all those that didn't
                  	           		 ; match.  Either way, it then adds the 'STEP' to that variable and
                  	           		 ; checks the result with against the limit value.  If it is within
                  	           		 ; the limit, control loops back to the command following the
                  	           		 ; 'FOR'.  If it's outside the limit, the save area is purged and
                  	           		 ; execution continues.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE610	           		 NEXT:
FFFFFFFFFFFFE610	E0400000		 	setlo	r1,#0		; don't allocate it
FFFFFFFFFFFFE614	31FFFB2E		 	call	TSTV		; get address of variable
FFFFFFFFFFFFE618	BE100069		 	bne		r1,r0,NX4
FFFFFFFFFFFFE61C	9A00F80F		 	lea		r1,msgNextVar
FFFFFFFFFFFFE620	BE00504A		 	bra		ERROR		; if no variable, say "What?"
FFFFFFFFFFFFE624	           		 NX4:
FFFFFFFFFFFFE624	02148009		 	mov		r9,r1		; save variable's address
FFFFFFFFFFFFE628	           		 NX0:
FFFFFFFFFFFFE628	460090A8		 	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFFFFFFFFFFE62C	BE100069		 	bne		r1,r0,NX5   ; had a FOR loop
FFFFFFFFFFFFE630	9A00F7FC		 	lea		r1,msgNextFor
FFFFFFFFFFFFE634	BE004FAA		 	bra		ERROR
FFFFFFFFFFFFE638	           		 NX5:
FFFFFFFFFFFFE638	BE148068		 	beq		r1,r9,NX2	; else we check them OK, they agree
FFFFFFFFFFFFE63C	31FFFC73		 	call	POPA		; nope, let's see the next frame
FFFFFFFFFFFFE640	BE007F4A		 	bra		NX0
FFFFFFFFFFFFE644	           		 NX2:
FFFFFFFFFFFFE644	46908000		 	lw		r1,[r9]		; get control variable's value
FFFFFFFFFFFFE648	460110B0		 	lw		r2,LOPINC
FFFFFFFFFFFFE64C	04110403		 	addu	r1,r1,r2	; add in loop increment
                  	           		 ;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFFFFFFFFFFE650	66908000		 	sw		r1,[r9]		; save control variable's new value
FFFFFFFFFFFFE654	460190B8		 	lw		r3,LOPLMT	; get loop's limit value
FFFFFFFFFFFFE658	BE200063		 	bgt		r2,r0,NX1	; check loop increment, branch if loop increment is positive
FFFFFFFFFFFFE65C	BE1180E0		 	blt		r1,r3,NXPurge	; test against limit
FFFFFFFFFFFFE660	BE00004A		 	bra     NX3
FFFFFFFFFFFFE664	           		 NX1:
FFFFFFFFFFFFE664	BE1180A3		 	bgt		r1,r3,NXPurge
FFFFFFFFFFFFE668	           		 NX3:
FFFFFFFFFFFFE668	460410C0		 	lw		r8,LOPLN	; Within limit, go back to the...
FFFFFFFFFFFFE66C	66041090		 	sw		r8,CURRNT
FFFFFFFFFFFFE670	460410C8		 	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
FFFFFFFFFFFFE674	BE00752A		 	bra		FINISH
FFFFFFFFFFFFE678	           		 NXPurge:
FFFFFFFFFFFFE678	31FFFC73		     call    POPA        ; purge this loop
FFFFFFFFFFFFE67C	BE0074EA		     bra     FINISH
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                  	           		 ;
                  	           		 ; 'REM' can be followed by anything and is ignored by the
                  	           		 ; interpreter.
                  	           		 ;
                  	           		 ;REM
                  	           		 ;    br	    IF2		    ; skip the rest of the line
                  	           		 ; 'IF' is followed by an expression, as a condition and one or
                  	           		 ; more commands (including other 'IF's) separated by colons.
                  	           		 ; Note that the word 'THEN' is not used.  The interpreter evaluates
                  	           		 ; the expression.  If it is non-zero, execution continues.  If it
                  	           		 ; is zero, the commands that follow are ignored and execution
                  	           		 ; continues on the next line.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE680	           		 IF:
FFFFFFFFFFFFE680	31FFFA7C		     call	OREXPR		; evaluate the expression
FFFFFFFFFFFFE684	           		 IF1:
FFFFFFFFFFFFE684	BE106AC9		     bne	    r1,r0,RUNSML		; is it zero? if not, continue
FFFFFFFFFFFFE688	           		 IF2:
FFFFFFFFFFFFE688	02848009		     mov		r9,r8		; set lookup pointer
FFFFFFFFFFFFE68C	E0400000		 	setlo	r1,#0		; find line #0 (impossible)
FFFFFFFFFFFFE690	31FFFC63		 	call	FNDSKP		; if so, skip the rest of the line
FFFFFFFFFFFFE694	BE104B83		 	bgt		r1,r0,WSTART	; if no next line, do a warm start
FFFFFFFFFFFFE698	           		 IF3:
FFFFFFFFFFFFE698	BE0069EA		 	bra		RUNTSL		; run the next line
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; INPUT is called first and establishes a stack frame
FFFFFFFFFFFFE69C	           		 INPERR:
FFFFFFFFFFFFE69C	460F10A0		 	lw		sp,STKINP	; restore the old stack pointer
FFFFFFFFFFFFE6A0	47E40010		 	lw		r8,16[sp]
FFFFFFFFFFFFE6A4	66041090		 	sw		r8,CURRNT	; and old 'CURRNT'
FFFFFFFFFFFFE6A8	47E40008		 	lw		r8,8[sp]	; and old text pointer
FFFFFFFFFFFFE6AC	0BEF0028		 	addui	sp,sp,#40	; fall through will subtract 40
                  	           		 
                  	           		 ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                  	           		 ; of items.  If the item is a string in single or double quotes,
                  	           		 ; or is an underline (back arrow), it has the same effect as in
                  	           		 ; 'PRINT'.  If an item is a variable, this variable name is
                  	           		 ; printed out followed by a colon, then the interpreter waits for
                  	           		 ; an expression to be typed in.  The variable is then set to the
                  	           		 ; value of this expression.  If the variable is preceeded by a
                  	           		 ; string (again in single or double quotes), the string will be
                  	           		 ; displayed followed by a colon.  The interpreter the waits for an
                  	           		 ; expression to be entered and sets the variable equal to the
                  	           		 ; expression's value.  If the input expression is invalid, the
                  	           		 ; interpreter will print "What?", "How?", or "Sorry" and reprint
                  	           		 ; the prompt and redo the input.  The execution will not terminate
                  	           		 ; unless you press control-C.  This is handled in 'INPERR'.
                  	           		 ;
FFFFFFFFFFFFE6B0	           		 INPUT:
FFFFFFFFFFFFE6B0	0FEF0028		 	subui	sp,sp,#40	; allocate stack frame
FFFFFFFFFFFFE6B4	67E28020		 	sw      r5,32[sp]
FFFFFFFFFFFFE6B8	           		 IP6:
FFFFFFFFFFFFE6B8	67E40000		 	sw		r8,[sp]		; save in case of error
FFFFFFFFFFFFE6BC	31FFFCA9		 	call	QTSTG		; is next item a string?
FFFFFFFFFFFFE6C0	BE0000CA		 	bra		IP2			; nope - this branch must take only two bytes
FFFFFFFFFFFFE6C4	E0400001		 	setlo	r1,#1		; allocate var
FFFFFFFFFFFFE6C8	31FFFB2E		 	call	TSTV		; yes, but is it followed by a variable?
FFFFFFFFFFFFE6CC	BE1003E8		 	beq     r1,r0,IP4   ; if not, brnch
FFFFFFFFFFFFE6D0	02150009		 	mov		r10,r1		; put away the variable's address
FFFFFFFFFFFFE6D4	BE0001AA		 	bra		IP3			; if so, input to variable
FFFFFFFFFFFFE6D8	           		 IP2:
FFFFFFFFFFFFE6D8	67E40008		 	sw		r8,8[sp]	; save for 'PRTSTG'
FFFFFFFFFFFFE6DC	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFE6E0	31FFFB2E		 	call	TSTV		; must be a variable now
FFFFFFFFFFFFE6E4	BE100069		 	bne		r1,r0,IP7
FFFFFFFFFFFFE6E8	9A00F7DF		 	lea		r1,msgInputVar
FFFFFFFFFFFFE6EC	BE0049EA		 	bra		ERROR		; "What?" it isn't?
FFFFFFFFFFFFE6F0	           		 IP7:
FFFFFFFFFFFFE6F0	02150009		 	mov		r10,r1		; put away the variable's address
FFFFFFFFFFFFE6F4	40828000		 	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
FFFFFFFFFFFFE6F8	60800000		 	sb		r0,[r8]
FFFFFFFFFFFFE6FC	47E08008		 	lw		r1,8[sp]	; get back text pointer
FFFFFFFFFFFFE700	31FFFC93		 	call	PRTSTG		; print string as prompt
FFFFFFFFFFFFE704	60828000		 	sb		r5,[r8]		; un-null terminate
FFFFFFFFFFFFE708	           		 IP3
FFFFFFFFFFFFE708	67E40008		 	sw		r8,8[sp]	; save in case of error
FFFFFFFFFFFFE70C	46009090		 	lw		r1,CURRNT
FFFFFFFFFFFFE710	67E08010		 	sw		r1,16[sp]	; also save 'CURRNT'
FFFFFFFFFFFFE714	E07FFFFF		 	setlo	r1,#-1
FFFFFFFFFFFFE718	66009090		 	sw		r1,CURRNT	; flag that we are in INPUT
FFFFFFFFFFFFE71C	660F10A0		 	sw		sp,STKINP	; save the stack pointer too
FFFFFFFFFFFFE720	67E50018		 	sw		r10,24[sp]	; save the variable address
FFFFFFFFFFFFE724	E040003A		 	setlo	r1,#':'		; print a colon first
FFFFFFFFFFFFE728	31FFFC1A		 	call	GETLN		; then get an input line
FFFFFFFFFFFFE72C	9A04111B		 	lea		r8,BUFFER	; point to the buffer
FFFFFFFFFFFFE730	31FFFA7C		 	call	OREXPR		; evaluate the input
FFFFFFFFFFFFE734	47E50018		 	lw		r10,24[sp]	; restore the variable address
FFFFFFFFFFFFE738	66A08000		 	sw		r1,[r10]	; save value in variable
FFFFFFFFFFFFE73C	47E08010		 	lw		r1,16[sp]	; restore old 'CURRNT'
FFFFFFFFFFFFE740	66009090		 	sw		r1,CURRNT
FFFFFFFFFFFFE744	47E40008		 	lw		r8,8[sp]	; and the old text pointer
FFFFFFFFFFFFE748	           		 IP4:
FFFFFFFFFFFFE748	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFE74C	9A026758		 	lea		r4,IP5		; is the next thing a comma?
FFFFFFFFFFFFE750	31FFFD30		 	call	TSTC
FFFFFFFFFFFFE754	BE007B2A		 	bra		IP6			; yes, more items
FFFFFFFFFFFFE758	           		 IP5:
FFFFFFFFFFFFE758	47E28020		     lw      r5,32[sp]
FFFFFFFFFFFFE75C	09EF0028		 	add		sp,sp,#40	; clean up the stack
FFFFFFFFFFFFE760	33FFF946		 	jmp		FINISH
                  	           		 
                  	           		 
FFFFFFFFFFFFE764	           		 DEFLT:
FFFFFFFFFFFFE764	40808000		     lb      r1,[r8]
FFFFFFFFFFFFE768	B01F6C0D		 	beq	    r1,#CR,FINISH	    ; empty line is OK else it is 'LET'
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'LET' is followed by a list of items separated by commas.
                  	           		 ; Each item consists of a variable, an equals sign, and an
                  	           		 ; expression.  The interpreter evaluates the expression and sets
                  	           		 ; the variable to that value.  The interpreter will also handle
                  	           		 ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE76C	           		 LET:
FFFFFFFFFFFFE76C	31FFFBDA		     call	SETVAL		; do the assignment
FFFFFFFFFFFFE770	E0C0002C		     setlo	r3,#','
FFFFFFFFFFFFE774	9A026518		     lea		r4,FINISH
FFFFFFFFFFFFE778	31FFFD30		 	call	TSTC		; check for more 'LET' items
FFFFFFFFFFFFE77C	BE007F8A		 	bra	    LET
FFFFFFFFFFFFE780	           		 LT1:
FFFFFFFFFFFFE780	BE006CCA		     bra	    FINISH		; until we are finished.
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** LOAD *** & SAVE ***
                  	           		 ;
                  	           		 ; These two commands transfer a program to/from an auxiliary
                  	           		 ; device such as a cassette, another computer, etc.  The program
                  	           		 ; is converted to an easily-stored format: each line starts with
                  	           		 ; a colon, the line no. as 4 hex digits, and the rest of the line.
                  	           		 ; At the end, a line starting with an '@' sign is sent.  This
                  	           		 ; format can be read back with a minimum of processing time by
                  	           		 ; the Butterfly.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE784	           		 LOAD
FFFFFFFFFFFFE784	46045F68		 	lw		r8,TXTBGN	; set pointer to start of prog. area
FFFFFFFFFFFFE788	E040000D		 	setlo	r1,#CR		; For a CP/M host, tell it we're ready...
FFFFFFFFFFFFE78C	31FFF7D7		 	call	GOAUXO		; by sending a CR to finish PIP command.
FFFFFFFFFFFFE790	           		 LOD1:
FFFFFFFFFFFFE790	31FFF7D8		 	call	GOAUXI		; look for start of line
FFFFFFFFFFFFE794	BE107FE2		 	ble		r1,r0,LOD1
FFFFFFFFFFFFE798	B0100E40		 	beq		r1,#'@',LODEND	; end of program?
FFFFFFFFFFFFE79C	B0100D1A		 	beq     r1,#0x1A,LODEND	; or EOF marker
FFFFFFFFFFFFE7A0	B21FFC3A		 	bne		r1,#':',LOD1	; if not, is it start of line? if not, wait for it
FFFFFFFFFFFFE7A4	31FFF9F6		 	call	GCHAR		; get line number
FFFFFFFFFFFFE7A8	60808000		 	sb		r1,[r8]		; store it
FFFFFFFFFFFFE7AC	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFE7B0	60808001		 	sb		r1,1[r8]
FFFFFFFFFFFFE7B4	0A840002		 	addui	r8,r8,#2
FFFFFFFFFFFFE7B8	           		 LOD2:
FFFFFFFFFFFFE7B8	31FFF7D8		 	call	GOAUXI		; get another text char.
FFFFFFFFFFFFE7BC	BE107FE2		 	ble		r1,r0,LOD2
FFFFFFFFFFFFE7C0	60808000		 	sb		r1,[r8]
FFFFFFFFFFFFE7C4	0A840001		 	addui	r8,r8,#1	; store it
FFFFFFFFFFFFE7C8	B21FFC0D		 	bne		r1,#CR,LOD2		; is it the end of the line? if not, go back for more
FFFFFFFFFFFFE7CC	BE007E2A		 	bra		LOD1		; if so, start a new line
FFFFFFFFFFFFE7D0	           		 LODEND:
FFFFFFFFFFFFE7D0	660410D0		 	sw		r8,TXTUNF	; set end-of program pointer
FFFFFFFFFFFFE7D4	BE00418A		 	bra		WSTART		; back to direct mode
                  	           		 
                  	           		 
                  	           		 ; get character from input (16 bit value)
FFFFFFFFFFFFE7D8	           		 GCHAR:
FFFFFFFFFFFFE7D8	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFE7DC	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFE7E0	67E30008		 	sw		r6,8[sp]
FFFFFFFFFFFFE7E4	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFE7E8	E1800003		 	setlo   r6,#3       ; repeat four times
FFFFFFFFFFFFE7EC	E1400000		 	setlo	r5,#0
FFFFFFFFFFFFE7F0	           		 GCHAR1:
FFFFFFFFFFFFE7F0	31FFF7D8		 	call	GOAUXI		; get a char
FFFFFFFFFFFFE7F4	BE107FE2		 	ble		r1,r0,GCHAR1
FFFFFFFFFFFFE7F8	31FFFA07		 	call	asciiToHex
FFFFFFFFFFFFE7FC	06528800		 	shli	r5,r5,#4
FFFFFFFFFFFFE800	04509409		 	or		r5,r5,r1
FFFFFFFFFFFFE804	BE037F6F		 	loop	r6,GCHAR1
FFFFFFFFFFFFE808	02508009		 	mov		r1,r5
FFFFFFFFFFFFE80C	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFE810	47E30008		 	lw		r6,8[sp]
FFFFFFFFFFFFE814	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFE818	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; convert an ascii char to hex code
                  	           		 ; input
                  	           		 ;	r1 = char to convert
                  	           		 
FFFFFFFFFFFFE81C	           		 asciiToHex:
FFFFFFFFFFFFE81C	A4100239		 	blei	r1,#'9',a2h1	; less than '9'
FFFFFFFFFFFFE820	0E108007		 	subui	r1,r1,#7	; shift 'A' to '9'+1
FFFFFFFFFFFFE824	           		 a2h1:
FFFFFFFFFFFFE824	0E108030		 	subui	r1,r1,#'0'	;
FFFFFFFFFFFFE828	1410800F		 	andi	r1,r1,#15	; make sure a nybble
FFFFFFFFFFFFE82C	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 
FFFFFFFFFFFFE830	           		 SAVE:
FFFFFFFFFFFFE830	46045F68		 	lw		r8,TXTBGN	;set pointer to start of prog. area
FFFFFFFFFFFFE834	460490D0		 	lw		r9,TXTUNF	;set pointer to end of prog. area
FFFFFFFFFFFFE838	           		 SAVE1:
FFFFFFFFFFFFE838	31FFFA23		 	call    AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFFFFFFFFFFE83C	BE8481C5		 	bgeu	r8,r9,SAVEND	; are we finished?
FFFFFFFFFFFFE840	E040003A		 	setlo	r1,#':'		; if not, start a line
FFFFFFFFFFFFE844	31FFF7D7		 	call	GOAUXO
FFFFFFFFFFFFE848	4A808000		 	lbu		r1,[r8]		; get line number
FFFFFFFFFFFFE84C	4A810001		 	lbu		r2,1[r8]
FFFFFFFFFFFFE850	06211000		 	shli	r2,r2,#8
FFFFFFFFFFFFE854	04110409		 	or		r1,r1,r2
FFFFFFFFFFFFE858	0A840002		 	addui	r8,r8,#2
FFFFFFFFFFFFE85C	31FFFA2B		 	call	PWORD       ; output line number as 4-digit hex
FFFFFFFFFFFFE860	           		 SAVE2:
FFFFFFFFFFFFE860	40808000		 	lb		r1,[r8]		; get a text char.
FFFFFFFFFFFFE864	0A840001		 	addui	r8,r8,#1
FFFFFFFFFFFFE868	B01FF40D		 	beqi	r1,#CR,SAVE1		; is it the end of the line? if so, send CR & LF and start new line
FFFFFFFFFFFFE86C	31FFF7D7		 	call	GOAUXO		; send it out
FFFFFFFFFFFFE870	BE007F8A		 	bra		SAVE2		; go back for more text
FFFFFFFFFFFFE874	           		 SAVEND:
FFFFFFFFFFFFE874	E0400040		 	setlo	r1,#'@'		; send end-of-program indicator
FFFFFFFFFFFFE878	31FFF7D7		 	call	GOAUXO
FFFFFFFFFFFFE87C	31FFFA23		 	call    AUXOCRLF    ; followed by a CR & LF
FFFFFFFFFFFFE880	E040001A		 	setlo	r1,#0x1A	; and a control-Z to end the CP/M file
FFFFFFFFFFFFE884	31FFF7D7		 	call	GOAUXO
FFFFFFFFFFFFE888	BE003BEA		 	bra		WSTART		; then go do a warm start
                  	           		 
                  	           		 
                  	           		 ; output a CR LF sequence to auxillary output
                  	           		 ; Registers Affected
                  	           		 ;   r3 = LF
FFFFFFFFFFFFE88C	           		 AUXOCRLF:
FFFFFFFFFFFFE88C	0FEF0008		     subui   sp,sp,#8
FFFFFFFFFFFFE890	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFE894	E040000D		     setlo   r1,#CR
FFFFFFFFFFFFE898	31FFF7D7		     call    GOAUXO
FFFFFFFFFFFFE89C	E040000A		     setlo   r1,#LF
FFFFFFFFFFFFE8A0	31FFF7D7		     call    GOAUXO
FFFFFFFFFFFFE8A4	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFE8A8	37EF8008		     ret		#8
                  	           		 
                  	           		 
                  	           		 ; output a word in hex format
                  	           		 ; tricky because of the need to reverse the order of the chars
FFFFFFFFFFFFE8AC	           		 PWORD:
FFFFFFFFFFFFE8AC	0DEF0010		 	sub		sp,sp,#16
FFFFFFFFFFFFE8B0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE8B4	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFE8B8	9A02910F		 	lea		r5,NUMWKA+15
FFFFFFFFFFFFE8BC	02120009		 	mov		r4,r1		; r4 = value
FFFFFFFFFFFFE8C0	           		 pword1:
FFFFFFFFFFFFE8C0	02408009		     mov     r1,r4	    ; r1 = value
FFFFFFFFFFFFE8C4	06420801		     shrui	r4,r4,#4	; shift over to next nybble
FFFFFFFFFFFFE8C8	31FFFA3F		     call    toAsciiHex  ; convert LS nybble to ascii hex
FFFFFFFFFFFFE8CC	60508000		     sb      r1,[r5]     ; save in work area
FFFFFFFFFFFFE8D0	0E528001		     subui   r5,r5,#1
FFFFFFFFFFFFE8D4	12509100		     cmpui   r1,r5,#NUMWKA
FFFFFFFFFFFFE8D8	BE107F41		     bge     r1,r0,pword1
FFFFFFFFFFFFE8DC	           		 pword2:
FFFFFFFFFFFFE8DC	0A528001		     addui   r5,r5,#1
FFFFFFFFFFFFE8E0	40508000		     lb      r1,[r5]     ; get char to output
FFFFFFFFFFFFE8E4	31FFF7D7		 	call	GOAUXO		; send it
FFFFFFFFFFFFE8E8	1250910F		 	cmpui   r1,r5,#NUMWKA+15
FFFFFFFFFFFFE8EC	BE107F80		 	blt     r1,r0,pword2
FFFFFFFFFFFFE8F0	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFE8F4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE8F8	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; convert nybble in r2 to ascii hex char2
                  	           		 ; r2 = character to convert
                  	           		 
FFFFFFFFFFFFE8FC	           		 toAsciiHex:
FFFFFFFFFFFFE8FC	1410800F		 	andi	r1,r1,#15	; make sure it's a nybble
FFFFFFFFFFFFE900	A010020A		 	blti	r1,#10,tah1	; > 10 ?
FFFFFFFFFFFFE904	08108007		 	addi	r1,r1,#7	; bump it up to the letter 'A'
FFFFFFFFFFFFE908	           		 tah1:
FFFFFFFFFFFFE908	0A108030		 	addui	r1,r1,#'0'	; bump up to ascii '0'
FFFFFFFFFFFFE90C	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** POKE *** & SYSX ***
                  	           		 ;
                  	           		 ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                  	           		 ; address specified by 'expr1'.
                  	           		 ;
                  	           		 ; 'SYSX expr' jumps to the machine language subroutine whose
                  	           		 ; starting address is specified by 'expr'.  The subroutine can use
                  	           		 ; all registers but must leave the stack the way it found it.
                  	           		 ; The subroutine returns to the interpreter by executing an RET.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFE910	           		 POKE:
FFFFFFFFFFFFE910	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE914	31FFFA7C		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFE918	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFE91C	9A02693C		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFE920	31FFFD30		 	call	TSTC		; it must be followed by a comma
FFFFFFFFFFFFE924	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFE928	31FFFA7C		 	call	OREXPR		; get the byte to be POKE'd
FFFFFFFFFFFFE92C	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFE930	60208000		 	sb		r1,[r2]		; store the byte in memory
FFFFFFFFFFFFE934	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFE938	BE005F0A		 	bra		FINISH
FFFFFFFFFFFFE93C	           		 PKER:
FFFFFFFFFFFFE93C	9A00F778		 	lea		r1,msgComma
FFFFFFFFFFFFE940	BE00374A		 	bra		ERROR		; if no comma, say "What?"
                  	           		 
FFFFFFFFFFFFE944	           		 POKEC:
FFFFFFFFFFFFE944	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE948	31FFFA7C		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFE94C	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFE950	9A02693C		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFE954	31FFFD30		 	call	TSTC		; it must be followed by a comma
FFFFFFFFFFFFE958	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFE95C	31FFFA7C		 	call	OREXPR		; get the byte to be POKE'd
FFFFFFFFFFFFE960	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFE964	62208000		 	sc		r1,[r2]		; store the char in memory
FFFFFFFFFFFFE968	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFE96C	33FFF946		 	jmp		FINISH
                  	           		 
FFFFFFFFFFFFE970	           		 POKEH:
FFFFFFFFFFFFE970	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE974	31FFFA7C		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFE978	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFE97C	9A02693C		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFE980	31FFFD30		 	call	TSTC
FFFFFFFFFFFFE984	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFE988	31FFFA7C		 	call	OREXPR		; get the byte to be POKE'd
FFFFFFFFFFFFE98C	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFE990	64208000		 	sh		r1,[r2]		; store the word in memory
FFFFFFFFFFFFE994	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFE998	33FFF946		 	jmp		FINISH
                  	           		 
FFFFFFFFFFFFE99C	           		 POKEW:
FFFFFFFFFFFFE99C	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE9A0	31FFFA7C		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFE9A4	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFE9A8	9A02693C		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFE9AC	31FFFD30		 	call	TSTC
FFFFFFFFFFFFE9B0	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFE9B4	31FFFA7C		 	call	OREXPR		; get the word to be POKE'd
FFFFFFFFFFFFE9B8	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFE9BC	66208000		 	sw		r1,[r2]		; store the word in memory
FFFFFFFFFFFFE9C0	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFE9C4	33FFF946		 	jmp		FINISH
                  	           		 
FFFFFFFFFFFFE9C8	           		 SYSX:
FFFFFFFFFFFFE9C8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE9CC	31FFFA7C		 	call	OREXPR		; get the subroutine's address
FFFFFFFFFFFFE9D0	BE100069		 	bne		r1,r0,sysx1	; make sure we got a valid address
FFFFFFFFFFFFE9D4	9A00F7CD		 	lea		r1,msgSYSBad
FFFFFFFFFFFFE9D8	BE00328A		 	bra		ERROR
FFFFFFFFFFFFE9DC	           		 sysx1:
FFFFFFFFFFFFE9DC	67E40000		 	sw		r8,[sp]	    ; save the text pointer
FFFFFFFFFFFFE9E0	341F8000		 	jal		r31,[r1]	; jump to the subroutine
FFFFFFFFFFFFE9E4	47E40000		 	lw		r8,[sp]	    ; restore the text pointer
FFFFFFFFFFFFE9E8	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFE9EC	BE00596A		 	bra		FINISH
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** EXPR ***
                  	           		 ;
                  	           		 ; 'EXPR' evaluates arithmetical or logical expressions.
                  	           		 ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                  	           		 ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                  	           		 ; <EXPR>::=<EXPR2>
                  	           		 ;	   <EXPR2><rel.op.><EXPR2>
                  	           		 ; where <rel.op.> is one of the operators in TAB8 and the result
                  	           		 ; of these operations is 1 if true and 0 if false.
                  	           		 ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                  	           		 ; where () are optional and (... are optional repeats.
                  	           		 ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                  	           		 ; <EXPR4>::=<variable>
                  	           		 ;	    <function>
                  	           		 ;	    (<EXPR>)
                  	           		 ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                  	           		 ; as an index, functions can have an <EXPR> as arguments, and
                  	           		 ; <EXPR4> can be an <EXPR> in parenthesis.
                  	           		 ;
                  	           		 
                  	           		 ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                  	           		 ;
FFFFFFFFFFFFE9F0	           		 OREXPR:
FFFFFFFFFFFFE9F0	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFE9F4	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE9F8	31FFFA8A		 	call	ANDEXPR		; get first <ANDEXPR>
FFFFFFFFFFFFE9FC	           		 XP_OR1:
FFFFFFFFFFFFE9FC	67E08004		 	sw		r1,4[sp]	; save <ANDEXPR> value
FFFFFFFFFFFFEA00	9A04E185		 	lea		r9,TAB10	; look up a logical operator
FFFFFFFFFFFFEA04	9A056308		 	lea		r10,TAB10_1
FFFFFFFFFFFFEA08	33FFF8C8		 	jmp		EXEC		; go do it
FFFFFFFFFFFFEA0C	           		 XP_OR:
FFFFFFFFFFFFEA0C	31FFFA8A		     call    ANDEXPR
FFFFFFFFFFFFEA10	47E10008		     lw      r2,8[sp]
FFFFFFFFFFFFEA14	04110409		     or      r1,r1,r2
FFFFFFFFFFFFEA18	BE007F2A		     bra     XP_OR1
FFFFFFFFFFFFEA1C	           		 XP_ORX:
FFFFFFFFFFFFEA1C	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEA20	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFEA24	37EF8010		     ret		#16
                  	           		 
                  	           		 
                  	           		 ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                  	           		 ;
FFFFFFFFFFFFEA28	           		 ANDEXPR:
FFFFFFFFFFFFEA28	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFEA2C	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEA30	31FFFAAF		 	call	EXPR		; get first <EXPR>
FFFFFFFFFFFFEA34	           		 XP_AND1:
FFFFFFFFFFFFEA34	67E08008		 	sw		r1,8[sp]	; save <EXPR> value
FFFFFFFFFFFFEA38	9A04E181		 	lea		r9,TAB9		; look up a logical operator
FFFFFFFFFFFFEA3C	9A0562F8		 	lea		r10,TAB9_1
FFFFFFFFFFFFEA40	33FFF8C8		 	jmp		EXEC		; go do it
FFFFFFFFFFFFEA44	           		 XP_AND:
FFFFFFFFFFFFEA44	31FFFAAF		     call    EXPR
FFFFFFFFFFFFEA48	47E10008		     lw      r2,8[sp]
FFFFFFFFFFFFEA4C	04110408		     and     r1,r1,r2
FFFFFFFFFFFFEA50	BE007F2A		     bra     XP_AND1
FFFFFFFFFFFFEA54	           		 XP_ANDX:
FFFFFFFFFFFFEA54	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEA58	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFEA5C	37EF8010		     ret		#16
                  	           		 
                  	           		 
                  	           		 ; Determine if the character is a digit
                  	           		 ;   Parameters
                  	           		 ;       r1 = char to test
                  	           		 ;   Returns
                  	           		 ;       r1 = 1 if digit, otherwise 0
                  	           		 ;
FFFFFFFFFFFFEA60	           		 isDigit:
FFFFFFFFFFFFEA60	A0100430		     blt     r1,#'0',isDigitFalse
FFFFFFFFFFFFEA64	A6100339		     bgt     r1,#'9',isDigitFalse
FFFFFFFFFFFFEA68	E0400001		     setlo   r1,#1
FFFFFFFFFFFFEA6C	37EF8000		     ret
FFFFFFFFFFFFEA70	           		 isDigitFalse:
FFFFFFFFFFFFEA70	E0400000		     setlo   r1,#0
FFFFFFFFFFFFEA74	37EF8000		     ret
                  	           		 
                  	           		 
                  	           		 ; Determine if the character is a alphabetic
                  	           		 ;   Parameters
                  	           		 ;       r1 = char to test
                  	           		 ;   Returns
                  	           		 ;       r1 = 1 if alpha, otherwise 0
                  	           		 ;
FFFFFFFFFFFFEA78	           		 isAlpha:
FFFFFFFFFFFFEA78	A0100641		     blt     r1,#'A',isAlphaFalse
FFFFFFFFFFFFEA7C	A410035A		     ble     r1,#'Z',isAlphaTrue
FFFFFFFFFFFFEA80	A0100461		     blt     r1,#'a',isAlphaFalse
FFFFFFFFFFFFEA84	A610037A		     bgt     r1,#'z',isAlphaFalse
FFFFFFFFFFFFEA88	           		 isAlphaTrue:
FFFFFFFFFFFFEA88	E0400001		     setlo   r1,#1
FFFFFFFFFFFFEA8C	37EF8000		     ret
FFFFFFFFFFFFEA90	           		 isAlphaFalse:
FFFFFFFFFFFFEA90	E0400000		     setlo   r1,#0
FFFFFFFFFFFFEA94	37EF8000		     ret
                  	           		 
                  	           		 
                  	           		 ; Determine if the character is a alphanumeric
                  	           		 ;   Parameters
                  	           		 ;       r1 = char to test
                  	           		 ;   Returns
                  	           		 ;       r1 = 1 if alpha, otherwise 0
                  	           		 ;
FFFFFFFFFFFFEA98	           		 isAlnum:
FFFFFFFFFFFFEA98	0FEF0008		     subui   sp,sp,#8
FFFFFFFFFFFFEA9C	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFEAA0	04100809		     or      r2,r1,r0		; save test char
FFFFFFFFFFFFEAA4	31FFFA98		     call    isDigit
FFFFFFFFFFFFEAA8	BE100069		     bne		r1,r0,isDigitx	; if it is a digit
FFFFFFFFFFFFEAAC	04200409		     or      r1,r2,r0		; get back test char
FFFFFFFFFFFFEAB0	31FFFA9E		     call    isAlpha
FFFFFFFFFFFFEAB4	           		 isDigitx:
FFFFFFFFFFFFEAB4	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFEAB8	37EF8008		     ret		#8
                  	           		 
                  	           		 
FFFFFFFFFFFFEABC	           		 EXPR:
FFFFFFFFFFFFEABC	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFEAC0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEAC4	31FFFADE		 	call	EXPR2
FFFFFFFFFFFFEAC8	67E08008		 	sw		r1,8[sp]	; save <EXPR2> value
FFFFFFFFFFFFEACC	9A04E177		 	lea		r9,TAB8		; look up a relational operator
FFFFFFFFFFFFEAD0	9A0562C0		 	lea		r10,TAB8_1
FFFFFFFFFFFFEAD4	33FFF8C8		 	jmp		EXEC		; go do it
FFFFFFFFFFFFEAD8	           		 XP11:
FFFFFFFFFFFFEAD8	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEADC	31FFFAD7		 	call	XP18	; is it ">="?
FFFFFFFFFFFFEAE0	BE208321		 	bge		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFEAE4	BE0002AA		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFEAE8	           		 XP12:
FFFFFFFFFFFFEAE8	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEAEC	31FFFAD7		 	call	XP18	; is it "<>"?
FFFFFFFFFFFFEAF0	BE2082A9		 	bne		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFEAF4	BE00022A		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFEAF8	           		 XP13:
FFFFFFFFFFFFEAF8	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEAFC	31FFFAD7		 	call	XP18	; is it ">"?
FFFFFFFFFFFFEB00	BE208223		 	bgt		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFEB04	BE0001AA		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFEB08	           		 XP14:
FFFFFFFFFFFFEB08	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEB0C	31FFFAD7		 	call	XP18	; is it "<="?
FFFFFFFFFFFFEB10	BE2081A2		 	ble		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFEB14	BE00012A		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFEB18	           		 XP15:
FFFFFFFFFFFFEB18	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEB1C	31FFFAD7		 	call	XP18	; is it "="?
FFFFFFFFFFFFEB20	BE208128		 	beq		r2,r1,XPRT1	; if not, return r2=1
FFFFFFFFFFFFEB24	BE0000AA		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFEB28	           		 XP16:
FFFFFFFFFFFFEB28	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEB2C	31FFFAD7		 	call	XP18	; is it "<"?
FFFFFFFFFFFFEB30	BE2080A0		 	blt		r2,r1,XPRT1	; if not, return r2=1
FFFFFFFFFFFFEB34	BE00002A		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFEB38	           		 XPRT0:
FFFFFFFFFFFFEB38	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEB3C	E0400000		 	setlo	r1,#0   ; return r1=0 (false)
FFFFFFFFFFFFEB40	37EF8010		 	ret		#16
FFFFFFFFFFFFEB44	           		 XPRT1:
FFFFFFFFFFFFEB44	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEB48	E0400001		 	setlo	r1,#1	; return r1=1 (true)
FFFFFFFFFFFFEB4C	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFEB50	           		 XP17:				; it's not a rel. operator
FFFFFFFFFFFFEB50	47E08008		 	lw		r1,8[sp]	; return r2=<EXPR2>
FFFFFFFFFFFFEB54	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEB58	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFEB5C	           		 XP18:
FFFFFFFFFFFFEB5C	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFEB60	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEB64	67E08008		 	sw		r1,8[sp]
FFFFFFFFFFFFEB68	31FFFADE		 	call	EXPR2		; do a second <EXPR2>
FFFFFFFFFFFFEB6C	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFEB70	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEB74	37EF8010		 	ret		#16
                  	           		 
                  	           		 ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                  	           		 
FFFFFFFFFFFFEB78	           		 EXPR2:
FFFFFFFFFFFFEB78	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFEB7C	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEB80	E0C0002D		 	setlo	r3,#'-'
FFFFFFFFFFFFEB84	9A026B98		 	lea		r4,XP21
FFFFFFFFFFFFEB88	31FFFD30		 	call	TSTC		; negative sign?
FFFFFFFFFFFFEB8C	E0400000		 	setlo	r1,#0		; yes, fake '0-'
FFFFFFFFFFFFEB90	67E00008		 	sw		r0,8[sp]
FFFFFFFFFFFFEB94	BE00020A		 	bra		XP26
FFFFFFFFFFFFEB98	           		 XP21:
FFFFFFFFFFFFEB98	E0C0002B		 	setlo	r3,#'+'
FFFFFFFFFFFFEB9C	9A026BA4		 	lea		r4,XP22
FFFFFFFFFFFFEBA0	31FFFD30		 	call	TSTC		; positive sign? ignore it
FFFFFFFFFFFFEBA4	           		 XP22:
FFFFFFFFFFFFEBA4	31FFFAFB		 	call	EXPR3		; first <EXPR3>
FFFFFFFFFFFFEBA8	           		 XP23:
FFFFFFFFFFFFEBA8	67E08008		 	sw		r1,8[sp]	; yes, save the value
FFFFFFFFFFFFEBAC	E0C0002B		 	setlo	r3,#'+'
FFFFFFFFFFFFEBB0	9A026BC8		 	lea		r4,XP25
FFFFFFFFFFFFEBB4	31FFFD30		 	call	TSTC		; add?
FFFFFFFFFFFFEBB8	31FFFAFB		 	call	EXPR3		; get the second <EXPR3>
FFFFFFFFFFFFEBBC	           		 XP24:
FFFFFFFFFFFFEBBC	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFEBC0	04110402		 	add		r1,r1,r2	; add it to the first <EXPR3>
                  	           		 ;	BVS.L	QHOW		brnch if there's an overflow
FFFFFFFFFFFFEBC4	BE007F2A		 	bra		XP23		; else go back for more operations
FFFFFFFFFFFFEBC8	           		 XP25:
FFFFFFFFFFFFEBC8	E0C0002D		 	setlo	r3,#'-'
FFFFFFFFFFFFEBCC	9A026BE0		 	lea		r4,XP45
FFFFFFFFFFFFEBD0	31FFFD30		 	call	TSTC		; subtract?
FFFFFFFFFFFFEBD4	           		 XP26:
FFFFFFFFFFFFEBD4	31FFFAFB		 	call	EXPR3		; get second <EXPR3>
FFFFFFFFFFFFEBD8	02108006		 	neg		r1,r1		; change its sign
FFFFFFFFFFFFEBDC	BE007F0A		 	bra		XP24		; and do an addition
FFFFFFFFFFFFEBE0	           		 XP45:
FFFFFFFFFFFFEBE0	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEBE4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEBE8	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                  	           		 
FFFFFFFFFFFFEBEC	           		 EXPR3:
FFFFFFFFFFFFEBEC	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFEBF0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEBF4	31FFFB11		 	call	EXPR4		; get first <EXPR4>
FFFFFFFFFFFFEBF8	           		 XP31:
FFFFFFFFFFFFEBF8	67E08008		 	sw		r1,8[sp]	; yes, save that first result
FFFFFFFFFFFFEBFC	E0C0002A		 	setlo	r3,#'*'
FFFFFFFFFFFFEC00	9A026C18		 	lea		r4,XP34
FFFFFFFFFFFFEC04	31FFFD30		 	call	TSTC		; multiply?
FFFFFFFFFFFFEC08	31FFFB11		 	call	EXPR4		; get second <EXPR4>
FFFFFFFFFFFFEC0C	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFEC10	04110419		 	muls	r1,r1,r2	; multiply the two
FFFFFFFFFFFFEC14	BE007F2A		 	bra		XP31        ; then look for more terms
FFFFFFFFFFFFEC18	           		 XP34:
FFFFFFFFFFFFEC18	E0C0002F		 	setlo	r3,#'/'
FFFFFFFFFFFFEC1C	9A026C38		 	lea		r4,XP47
FFFFFFFFFFFFEC20	31FFFD30		 	call	TSTC		; divide?
FFFFFFFFFFFFEC24	31FFFB11		 	call	EXPR4		; get second <EXPR4>
FFFFFFFFFFFFEC28	04100809		 	or      r2,r1,r0
FFFFFFFFFFFFEC2C	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEC30	0411041B		 	divs	r1,r1,r2	; do the division
FFFFFFFFFFFFEC34	BE007E2A		 	bra		XP31		; go back for any more terms
FFFFFFFFFFFFEC38	           		 XP47:
FFFFFFFFFFFFEC38	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFEC3C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEC40	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; Functions are called through EXPR4
                  	           		 ; <EXPR4>::=<variable>
                  	           		 ;	    <function>
                  	           		 ;	    (<EXPR>)
                  	           		 
FFFFFFFFFFFFEC44	           		 EXPR4:
FFFFFFFFFFFFEC44	0FEF0018		     subui   sp,sp,#24
FFFFFFFFFFFFEC48	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFEC4C	9A04E14E		     lea		r9,TAB4		; find possible function
FFFFFFFFFFFFEC50	9A056258		     lea		r10,TAB4_1
FFFFFFFFFFFFEC54	33FFF8C8		 	jmp		EXEC        ; branch to function which does subsequent ret for EXPR4
FFFFFFFFFFFFEC58	           		 XP40:                   ; we get here if it wasn't a function
FFFFFFFFFFFFEC58	E0400000		 	setlo	r1,#0
FFFFFFFFFFFFEC5C	31FFFB2E		 	call	TSTV		
FFFFFFFFFFFFEC60	BE100088		 	beq     r1,r0,XP41  ; nor a variable
FFFFFFFFFFFFEC64	46108000		 	lw		r1,[r1]		; if a variable, return its value in r1
FFFFFFFFFFFFEC68	47EF8000		 	lw      lr,[sp]
FFFFFFFFFFFFEC6C	37EF8018		 	ret		#24
FFFFFFFFFFFFEC70	           		 XP41:
FFFFFFFFFFFFEC70	31FFFD3E		 	call	TSTNUM		; or is it a number?
FFFFFFFFFFFFEC74	BE200049		 	bne		r2,r0,XP46	; (if not, # of digits will be zero) if so, return it in r1
FFFFFFFFFFFFEC78	31FFFB21		 	call    PARN        ; check for (EXPR)
FFFFFFFFFFFFEC7C	           		 XP46:
FFFFFFFFFFFFEC7C	47EF8000		 	lw      lr,[sp]
FFFFFFFFFFFFEC80	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; Check for a parenthesized expression
FFFFFFFFFFFFEC84	           		 PARN:
FFFFFFFFFFFFEC84	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFEC88	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEC8C	E0C00028		 	setlo	r3,#'('
FFFFFFFFFFFFEC90	9A026CB0		 	lea		r4,XP43
FFFFFFFFFFFFEC94	31FFFD30		 	call	TSTC		; else look for ( OREXPR )
FFFFFFFFFFFFEC98	31FFFA7C		 	call	OREXPR
FFFFFFFFFFFFEC9C	E0C00029		 	setlo	r3,#')'
FFFFFFFFFFFFECA0	9A026CB0		 	lea		r4,XP43
FFFFFFFFFFFFECA4	31FFFD30		 	call	TSTC
FFFFFFFFFFFFECA8	           		 XP42:
FFFFFFFFFFFFECA8	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFECAC	37EF8008		 	ret		#8
FFFFFFFFFFFFECB0	           		 XP43:
FFFFFFFFFFFFECB0	9A00F6F5		 	lea		r1,msgWhat
FFFFFFFFFFFFECB4	BE001BAA		 	bra		ERROR
                  	           		 
                  	           		 
                  	           		 ; ===== Test for a valid variable name.  Returns Z=1 if not
                  	           		 ;	found, else returns Z=0 and the address of the
                  	           		 ;	variable in r1.
                  	           		 ; Parameters
                  	           		 ;	r1 = 1 = allocate if not found
                  	           		 ; Returns
                  	           		 ;	r1 = address of variable, zero if not found
                  	           		 
FFFFFFFFFFFFECB8	           		 TSTV:
FFFFFFFFFFFFECB8	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFECBC	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFECC0	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFECC4	04101409		 	or		r5,r1,r0	; allocate flag
FFFFFFFFFFFFECC8	31FFFD55		 	call	IGNBLK
FFFFFFFFFFFFECCC	4A808000		 	lbu		r1,[r8]		; look at the program text
FFFFFFFFFFFFECD0	A0101740		 	blt     r1,#'@',tstv_notfound   ; C=1: not a variable
FFFFFFFFFFFFECD4	B2100F40		 	bne		r1,#'@',TV1	; brnch if not "@" array
FFFFFFFFFFFFECD8	0A840001		 	addui	r8,r8,#1	; If it is, it should be
FFFFFFFFFFFFECDC	31FFFB21		 	call	PARN		; followed by (EXPR) as its index.
FFFFFFFFFFFFECE0	06108600		 	shli	r1,r1,#3
                  	           		 ;	BCS.L	QHOW		say "How?" if index is too big
FFFFFFFFFFFFECE4	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFECE8	67E08008		     sw      r1,8[sp]    ; save the index
FFFFFFFFFFFFECEC	67EF8000		     sw		lr,[sp]
FFFFFFFFFFFFECF0	31FFFBD5		 	call	SIZEX		; get amount of free memory
FFFFFFFFFFFFECF4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFECF8	47E10008		 	lw      r2,8[sp]    ; get back the index
FFFFFFFFFFFFECFC	BE208044		 	bltu	r2,r1,TV2	; see if there's enough memory
FFFFFFFFFFFFED00	33FFFC07		 	jmp    	QSORRY		; if not, say "Sorry"
FFFFFFFFFFFFED04	           		 TV2:
FFFFFFFFFFFFED04	9A0090D8		 	lea		r1,VARBGN   ; put address of array element...
FFFFFFFFFFFFED08	04110405		 	subu    r1,r1,r2       ; into r1 (neg. offset is used)
FFFFFFFFFFFFED0C	BE0000AA		 	bra     TSTVRT
FFFFFFFFFFFFED10	           		 TV1:	
FFFFFFFFFFFFED10	31FFFB4F		     call    getVarName      ; get variable name
FFFFFFFFFFFFED14	BE100068		     beq     r1,r0,TSTVRT    ; if not, return r1=0
FFFFFFFFFFFFED18	02510009		     mov		r2,r5
FFFFFFFFFFFFED1C	31FFFB75		     call    findVar     ; find or allocate
FFFFFFFFFFFFED20	           		 TSTVRT:
FFFFFFFFFFFFED20	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFED24	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFED28	37EF8018		 	ret		#24			; r1<>0 (found)
FFFFFFFFFFFFED2C	           		 tstv_notfound:
FFFFFFFFFFFFED2C	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFED30	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFED34	E0400000		     setlo   r1,#0       ; r1=0 if not found
FFFFFFFFFFFFED38	37EF8018		     ret		#24
                  	           		 
                  	           		 
                  	           		 ; Returns
                  	           		 ;   r1 = 6 character variable name + type
                  	           		 ;
FFFFFFFFFFFFED3C	           		 getVarName:
FFFFFFFFFFFFED3C	0FEF0018		     subui   sp,sp,#24
FFFFFFFFFFFFED40	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFED44	67E28010		     sw		r5,16[sp]
                  	           		 
FFFFFFFFFFFFED48	40808000		     lb      r1,[r8]     ; get first character
FFFFFFFFFFFFED4C	67E08008		     sw		r1,8[sp]	; save off current name
FFFFFFFFFFFFED50	31FFFA9E		     call    isAlpha
FFFFFFFFFFFFED54	BE100388		     beq     r1,r0,gvn1
FFFFFFFFFFFFED58	E1400005		     setlo   r5,#5       ; loop six more times
                  	           		 
                  	           		 	; check for second/third character
FFFFFFFFFFFFED5C	           		 gvn4:
FFFFFFFFFFFFED5C	0A840001		 	addui   r8,r8,#1
FFFFFFFFFFFFED60	40808000		 	lb      r1,[r8]     ; do we have another char ?
FFFFFFFFFFFFED64	31FFFAA6		 	call    isAlnum
FFFFFFFFFFFFED68	BE100168		 	beq     r1,r0,gvn2  ; nope
FFFFFFFFFFFFED6C	47E08008		 	lw      r1,8[sp]    ; get varname
FFFFFFFFFFFFED70	06109000		 	shli	r1,r1,#8
FFFFFFFFFFFFED74	40810000		 	lb      r2,[r8]
FFFFFFFFFFFFED78	04110409		 	or      r1,r1,r2   ; add in new char
FFFFFFFFFFFFED7C	67E08008		     sw      r1,8[sp]   ; save off name again
FFFFFFFFFFFFED80	BE02FEEF		     loop	r5,gvn4
                  	           		 
                  	           		     ; now ignore extra variable name characters
FFFFFFFFFFFFED84	           		 gvn6:
FFFFFFFFFFFFED84	0A840001		     addui   r8,r8,#1
FFFFFFFFFFFFED88	40808000		     lb      r1,[r8]
FFFFFFFFFFFFED8C	31FFFAA6		     call    isAlnum
FFFFFFFFFFFFED90	BE107FA9		     bne     r1,r0,gvn6	; keep looping as long as we have identifier chars
                  	           		 
                  	           		     ; check for a variable type
FFFFFFFFFFFFED94	           		 gvn2:
FFFFFFFFFFFFED94	40808000		 	lb		r1,[r8]
FFFFFFFFFFFFED98	B0100425		     beq     r1,#'%',gvn3
FFFFFFFFFFFFED9C	B0100324		     beq     r1,#'$',gvn3
FFFFFFFFFFFFEDA0	E0400000		     setlo   r1,#0
FFFFFFFFFFFFEDA4	0E840001		     subui   r8,r8,#1
                  	           		 
                  	           		     ; insert variable type indicator and return
FFFFFFFFFFFFEDA8	           		 gvn3:
FFFFFFFFFFFFEDA8	0A840001		     addui   r8,r8,#1
FFFFFFFFFFFFEDAC	47E10008		     lw      r2,8[sp]
FFFFFFFFFFFFEDB0	06211000		     shli	r2,r2,#8
FFFFFFFFFFFFEDB4	04110409		     or      r1,r1,r2    ; add in variable type
FFFFFFFFFFFFEDB8	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFEDBC	47E28010		     lw		r5,16[sp]
FFFFFFFFFFFFEDC0	37EF8018		     ret		#24			; return Z = 0, r1 = varname
                  	           		 
                  	           		     ; not a variable name
FFFFFFFFFFFFEDC4	           		 gvn1:
FFFFFFFFFFFFEDC4	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFEDC8	47E28010		     lw		r5,16[sp]
FFFFFFFFFFFFEDCC	E0400000		     setlo   r1,#0       ; return Z = 1 if not a varname
FFFFFFFFFFFFEDD0	37EF8018		     ret		#24
                  	           		 
                  	           		 
                  	           		 ; Find variable
                  	           		 ;   r1 = varname
                  	           		 ;	r2 = allocate flag
                  	           		 ; Returns
                  	           		 ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                  	           		 
FFFFFFFFFFFFEDD4	           		 findVar:
FFFFFFFFFFFFEDD4	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFEDD8	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFEDDC	67E38008		     sw      r7,8[sp]
FFFFFFFFFFFFEDE0	460190D8		     lw      r3,VARBGN
FFFFFFFFFFFFEDE4	           		 fv4:
FFFFFFFFFFFFEDE4	46338000		     lw      r7,[r3]     ; get varname / type
FFFFFFFFFFFFEDE8	BE700108		     beq     r7,r0,fv3   ; no more vars ?
FFFFFFFFFFFFEDEC	BE138128		     beq     r1,r7,fv1	; match ?
FFFFFFFFFFFFEDF0	08318008		     add     r3,r3,#8    ; move to next var
FFFFFFFFFFFFEDF4	460390F8		     lw      r7,STKBOT
FFFFFFFFFFFFEDF8	BE33FF60		     blt     r3,r7,fv4   ; loop back to look at next var
                  	           		 
                  	           		     ; variable not found
                  	           		     ; no more memory
FFFFFFFFFFFFEDFC	E07FF748		     setlo	r1,#<msgVarSpace
FFFFFFFFFFFFEE00	F04FFFFF		     sethi	r1,#>msgVarSpace
FFFFFFFFFFFFEE04	BE00112A		     bra     ERROR
                  	           		 ;    lw      lr,[sp]
                  	           		 ;    lw      r7,4[sp]
                  	           		 ;    add     sp,sp,#8
                  	           		 ;    lw      r1,#0
                  	           		 ;    ret
                  	           		 
                  	           		     ; variable not found
                  	           		     ; allocate new ?
FFFFFFFFFFFFEE08	           		 fv3:
FFFFFFFFFFFFEE08	BE2000C8		 	beq		r2,r0,fv2
FFFFFFFFFFFFEE0C	66308000		     sw      r1,[r3]     ; save varname / type
                  	           		     ; found variable
                  	           		     ; return address
FFFFFFFFFFFFEE10	           		 fv1:
FFFFFFFFFFFFEE10	0A308008		     addui   r1,r3,#8
FFFFFFFFFFFFEE14	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFEE18	47E38008		     lw      r7,8[sp]
FFFFFFFFFFFFEE1C	37EF8010		     ret		#16    ; Z = 0, r1 = address
                  	           		 
                  	           		     ; didn't find var and not allocating
FFFFFFFFFFFFEE20	           		 fv2:
FFFFFFFFFFFFEE20	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFEE24	47E38008		     lw      r7,8[sp]
FFFFFFFFFFFFEE28	0BEF0010		     addui   sp,sp,#16   ; Z = 0, r1 = address
FFFFFFFFFFFFEE2C	E0400000		 	setlo	r1,#0		; Z = 1, r1 = 0
FFFFFFFFFFFFEE30	37EF8000		     ret
                  	           		 
                  	           		 
                  	           		 ; ===== Multiplies the 32 bit values in r1 and r2, returning
                  	           		 ;	the 32 bit result in r1.
                  	           		 ;
                  	           		 
                  	           		 ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                  	           		 ;	Returns the 32 bit quotient in r1, remainder in r2
                  	           		 ;
                  	           		 ; r2 = a
                  	           		 ; r3 = b
                  	           		 ; r6 = remainder
                  	           		 ; r7 = iteration count
                  	           		 ; r8 = sign
                  	           		 ;
                  	           		 
                  	           		 ; q = a / b
                  	           		 ; a = r1
                  	           		 ; b = r2
                  	           		 ; q = r2
                  	           		 
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFEE34	           		 PEEK:
FFFFFFFFFFFFEE34	31FFFB21		 	call	PARN		; get the memory address
FFFFFFFFFFFFEE38	4A108000		 	lbu		r1,[r1]		; get the addressed byte
FFFFFFFFFFFFEE3C	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFEE40	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFEE44	           		 PEEKC:
FFFFFFFFFFFFEE44	31FFFB21		 	call	PARN		; get the memory address
FFFFFFFFFFFFEE48	1410FFFE		 	andi	r1,r1,#-2	; align to char address
FFFFFFFFFFFFEE4C	4C108000		 	lcu		r1,[r1]		; get the addressed char
FFFFFFFFFFFFEE50	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFEE54	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFEE58	           		 PEEKH:
FFFFFFFFFFFFEE58	31FFFB21		 	call	PARN		; get the memory address
FFFFFFFFFFFFEE5C	1410FFFC		 	andi	r1,r1,#-4	; align to half-word address
FFFFFFFFFFFFEE60	4E108000		 	lhu		r1,[r1]		; get the addressed char
FFFFFFFFFFFFEE64	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFEE68	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFEE6C	           		 PEEKW:
FFFFFFFFFFFFEE6C	31FFFB21		 	call	PARN		; get the memory address
FFFFFFFFFFFFEE70	1410FFF8		 	andi	r1,r1,#-8		; align to word address
FFFFFFFFFFFFEE74	46108000		 	lw		r1,[r1]		; get the addressed word
FFFFFFFFFFFFEE78	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFEE7C	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; user function call
                  	           		 ; call the user function with argument in r1
FFFFFFFFFFFFEE80	           		 USRX:
FFFFFFFFFFFFEE80	31FFFB21		 	call	PARN		; get expression value
FFFFFFFFFFFFEE84	67E40008		 	sw		r8,8[sp]	; save the text pointer
FFFFFFFFFFFFEE88	46011028		 	lw      r2,usrJmp   ; get usr vector
FFFFFFFFFFFFEE8C	342F8000		 	jal		r31,[r2]	; jump to the subroutine
FFFFFFFFFFFFEE90	47E40008		 	lw		r8,8[sp]	; restore the text pointer
FFFFFFFFFFFFEE94	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEE98	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; ===== The RND function returns a random number from 1 to
                  	           		 ;	the value of the following expression in D0.
                  	           		 ;
FFFFFFFFFFFFEE9C	           		 RND:
FFFFFFFFFFFFEE9C	31FFFB21		 	call	PARN		; get the upper limit
FFFFFFFFFFFFEEA0	BE100168		 	beq		r1,r0,rnd2	; it must be positive and non-zero
FFFFFFFFFFFFEEA4	BE100100		 	blt		r1,r0,rnd1
FFFFFFFFFFFFEEA8	04100809		 	lw		r2,r1
FFFFFFFFFFFFEEAC	00000050		 	gran				; generate a random number
FFFFFFFFFFFFEEB0	020088A8		 	mfspr	r1,rand		; get the number
FFFFFFFFFFFFEEB4	31FFFBB7		 	call	modu4		; RND(n)=MOD(number,n)+1
FFFFFFFFFFFFEEB8	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFEEBC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEEC0	37EF8018		 	ret		#24
FFFFFFFFFFFFEEC4	           		 rnd1:
FFFFFFFFFFFFEEC4	9A00F7B9		 	lea		r1,msgRNDBad
FFFFFFFFFFFFEEC8	BE000B0A		 	bra		ERROR
FFFFFFFFFFFFEECC	           		 rnd2:
FFFFFFFFFFFFEECC	00000050		 	gran
FFFFFFFFFFFFEED0	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFEED4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEED8	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; r = a mod b
                  	           		 ; a = r1
                  	           		 ; b = r2 
                  	           		 ; r = r6
FFFFFFFFFFFFEEDC	           		 modu4:
FFFFFFFFFFFFEEDC	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFEEE0	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFEEE4	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFEEE8	67E30010		 	sw		r6,16[sp]
FFFFFFFFFFFFEEEC	67E38018		 	sw		r7,24[sp]
FFFFFFFFFFFFEEF0	1603803F		 	lw      r7,#63		; n = 64
FFFFFFFFFFFFEEF4	0452940A		 	xor		r5,r5,r5	; w = 0
FFFFFFFFFFFFEEF8	0463180A		 	xor		r6,r6,r6	; r = 0
FFFFFFFFFFFFEEFC	           		 mod2:
FFFFFFFFFFFFEEFC	06108202		 	roli	r1,r1,#1	; a <<= 1
FFFFFFFFFFFFEF00	14118001		 	andi	r3,r1,#1
FFFFFFFFFFFFEF04	06630200		 	shli	r6,r6,#1	; r <<= 1
FFFFFFFFFFFFEF08	04619809		 	or		r6,r6,r3
FFFFFFFFFFFFEF0C	1410FFFE		 	andi	r1,r1,#-2
FFFFFFFFFFFFEF10	BE230047		 	bgtu	r2,r6,mod1	; b < r ?
FFFFFFFFFFFFEF14	04611805		 	subu	r6,r6,r2	; r -= b
FFFFFFFFFFFFEF18	           		 mod1:
FFFFFFFFFFFFEF18	BE03FF2F		     loop	r7,mod2		; n--
FFFFFFFFFFFFEF1C	02608009		 	mov		r1,r6
FFFFFFFFFFFFEF20	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFEF24	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFEF28	47E30010		 	lw		r6,16[sp]
FFFFFFFFFFFFEF2C	47E38018		 	lw		r7,24[sp]
FFFFFFFFFFFFEF30	37EF8020		 	ret		#32
                  	           		 
                  	           		 
                  	           		 ; ===== The ABS function returns an absolute value in r2.
                  	           		 ;
FFFFFFFFFFFFEF34	           		 ABS:
FFFFFFFFFFFFEF34	31FFFB21		 	call	PARN		; get the following expr.'s value
FFFFFFFFFFFFEF38	02108007		 	abs		r1,r1
FFFFFFFFFFFFEF3C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEF40	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The SGN function returns the sign in r1. +1,0, or -1
                  	           		 ;
FFFFFFFFFFFFEF44	           		 SGN:
FFFFFFFFFFFFEF44	31FFFB21		 	call	PARN		; get the following expr.'s value
FFFFFFFFFFFFEF48	02108008		 	sgn		r1,r1
FFFFFFFFFFFFEF4C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEF50	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The SIZE function returns the size of free memory in r1.
                  	           		 ;
FFFFFFFFFFFFEF54	           		 SIZEX:
FFFFFFFFFFFFEF54	460090D8		 	lw		r1,VARBGN	; get the number of free bytes...
FFFFFFFFFFFFEF58	460110D0		 	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFFFFFFFFFFEF5C	04110405		 	subu	r1,r1,r2
FFFFFFFFFFFFEF60	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFEF64	37EF8018		 	ret		#24			; return the number in r2
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                  	           		 ;
                  	           		 ; 'SETVAL' expects a variable, followed by an equal sign and then
                  	           		 ; an expression.  It evaluates the expression and sets the variable
                  	           		 ; to that value.
                  	           		 ;
                  	           		 ; 'FIN' checks the end of a command.  If it ended with ":",
                  	           		 ; execution continues.	If it ended with a CR, it finds the
                  	           		 ; the next line and continues from there.
                  	           		 ;
                  	           		 ; 'ENDCHK' checks if a command is ended with a CR. This is
                  	           		 ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                  	           		 ;
                  	           		 ; 'ERROR' prints the string pointed to by r1. It then prints the
                  	           		 ; line pointed to by CURRNT with a "?" inserted at where the
                  	           		 ; old text pointer (should be on top of the stack) points to.
                  	           		 ; Execution of Tiny BASIC is stopped and a warm start is done.
                  	           		 ; If CURRNT is zero (indicating a direct command), the direct
                  	           		 ; command is not printed. If CURRNT is -1 (indicating
                  	           		 ; 'INPUT' command in progress), the input line is not printed
                  	           		 ; and execution is not terminated but continues at 'INPERR'.
                  	           		 ;
                  	           		 ; Related to 'ERROR' are the following:
                  	           		 ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                  	           		 ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                  	           		 ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                  	           		 ; 'QHOW' and 'AHOW' also do this for "How?".
                  	           		 ;
                  	           		 
                  	           		 ; returns
                  	           		 ; r2 = variable's address
                  	           		 ;
FFFFFFFFFFFFEF68	           		 SETVAL:
FFFFFFFFFFFFEF68	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFEF6C	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFEF70	E0400001		     setlo	r1,#1		; allocate var
FFFFFFFFFFFFEF74	31FFFB2E		     call	TSTV		; variable name?
FFFFFFFFFFFFEF78	BE100069		     bne		r1,r0,sv2
FFFFFFFFFFFFEF7C	9A00F7A2		    	lea		r1,msgVar
FFFFFFFFFFFFEF80	BE00054A		    	bra		ERROR 
FFFFFFFFFFFFEF84	           		 sv2:
FFFFFFFFFFFFEF84	67E08008		 	sw      r1,8[sp]    ; save the variable's address
FFFFFFFFFFFFEF88	E0C0003D		 	setlo	r3,#'='
FFFFFFFFFFFFEF8C	9A026FAC		 	lea		r4,SV1
FFFFFFFFFFFFEF90	31FFFD30		 	call	TSTC		; get past the "=" sign
FFFFFFFFFFFFEF94	31FFFA7C		 	call	OREXPR		; evaluate the expression
FFFFFFFFFFFFEF98	47E10008		 	lw      r2,8[sp]    ; get back the variable's address
FFFFFFFFFFFFEF9C	66208000		 	sw      r1,[r2]     ; and save value in the variable
FFFFFFFFFFFFEFA0	04200409		 	lw		r1,r2		; return r1 = variable address
FFFFFFFFFFFFEFA4	47EF8000		 	lw      lr,[sp]
FFFFFFFFFFFFEFA8	37EF8010		 	ret		#16
FFFFFFFFFFFFEFAC	           		 SV1:
FFFFFFFFFFFFEFAC	BE0003CA		     bra	    QWHAT		; if no "=" sign
                  	           		 
                  	           		 
FFFFFFFFFFFFEFB0	           		 FIN:
FFFFFFFFFFFFEFB0	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFEFB4	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEFB8	E0C0003A		 	setlo	r3,#':'
FFFFFFFFFFFFEFBC	9A026FCC		 	lea		r4,FI1
FFFFFFFFFFFFEFC0	31FFFD30		 	call	TSTC		; *** FIN ***
FFFFFFFFFFFFEFC4	0BEF0008		 	addui	sp,sp,#8	; if ":", discard return address
FFFFFFFFFFFFEFC8	BE0020AA		 	bra		RUNSML		; continue on the same line
FFFFFFFFFFFFEFCC	           		 FI1:
FFFFFFFFFFFFEFCC	E0C0000D		 	setlo	r3,#CR
FFFFFFFFFFFFEFD0	9A026FE4		 	lea		r4,FI2
FFFFFFFFFFFFEFD4	31FFFD30		 	call	TSTC		; not ":", is it a CR?
FFFFFFFFFFFFEFD8	47EF8000		 	lw		lr,[sp]	; else return to the caller
FFFFFFFFFFFFEFDC	0BEF0008		 	addui	sp,sp,#8	; yes, purge return address
FFFFFFFFFFFFEFE0	BE001EAA		 	bra		RUNNXL		; execute the next line
FFFFFFFFFFFFEFE4	           		 FI2:
FFFFFFFFFFFFEFE4	47EF8000		 	lw		lr,[sp]	; else return to the caller
FFFFFFFFFFFFEFE8	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; Check that there is nothing else on the line
                  	           		 ; Registers Affected
                  	           		 ;   r1
                  	           		 ;
FFFFFFFFFFFFEFEC	           		 ENDCHK:
FFFFFFFFFFFFEFEC	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFEFF0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFEFF4	31FFFD55		 	call	IGNBLK
FFFFFFFFFFFFEFF8	40808000		 	lb		r1,[r8]
FFFFFFFFFFFFEFFC	B010040D		 	beq		r1,#CR,ec1	; does it end with a CR?
FFFFFFFFFFFFF000	E07FF87C		 	setlo	r1,#<msgExtraChars
FFFFFFFFFFFFF004	F04FFFFF		 	sethi	r1,#>msgExtraChars
FFFFFFFFFFFFF008	33FFFC0A		 	jmp		ERROR
FFFFFFFFFFFFF00C	           		 ec1:
FFFFFFFFFFFFF00C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF010	37EF8008		 	ret		#8
                  	           		 
                  	           		 
FFFFFFFFFFFFF014	           		 TOOBIG:
FFFFFFFFFFFFF014	9A00F867		 	lea		r1,msgTooBig
FFFFFFFFFFFFF018	BE00008A		 	bra		ERROR
FFFFFFFFFFFFF01C	           		 QSORRY:
FFFFFFFFFFFFF01C	9A00F6FD		     lea		r1,SRYMSG
FFFFFFFFFFFFF020	BE00004A		 	bra	    ERROR
FFFFFFFFFFFFF024	           		 QWHAT:
FFFFFFFFFFFFF024	9A00F6F5		 	lea		r1,msgWhat
FFFFFFFFFFFFF028	           		 ERROR:
FFFFFFFFFFFFF028	31FFFD81		 	call	PRMESG		; display the error message
FFFFFFFFFFFFF02C	46009090		 	lw		r1,CURRNT	; get the current line number
FFFFFFFFFFFFF030	BE107EA8		 	beq		r1,r0,WSTART	; if zero, do a warm start
FFFFFFFFFFFFF034	B01D9AFF		 	beq		r1,#-1,INPERR		; is the line no. pointer = -1? if so, redo input
FFFFFFFFFFFFF038	40828000		 	lb		r5,[r8]		; save the char. pointed to
FFFFFFFFFFFFF03C	60800000		 	sb		r0,[r8]		; put a zero where the error is
FFFFFFFFFFFFF040	46009090		 	lw		r1,CURRNT	; point to start of current line
FFFFFFFFFFFFF044	31FFFD1E		 	call	PRTLN		; display the line in error up to the 0
FFFFFFFFFFFFF048	04101809		 	or      r6,r1,r0    ; save off end pointer
FFFFFFFFFFFFF04C	60828000		 	sb		r5,[r8]		; restore the character
FFFFFFFFFFFFF050	E040003F		 	setlo	r1,#'?'		; display a "?"
FFFFFFFFFFFFF054	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF058	E0800000		 	setlo   r2,#0       ; stop char = 0
FFFFFFFFFFFFF05C	0E608001		 	subui	r1,r6,#1	; point back to the error char.
FFFFFFFFFFFFF060	31FFFC93		 	call	PRTSTG		; display the rest of the line
FFFFFFFFFFFFF064	33FFF801		 	jmp	    WSTART		; and do a warm start
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** GETLN *** FNDLN (& friends) ***
                  	           		 ;
                  	           		 ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                  	           		 ; the character in r3 (given by the caller), then it fills the
                  	           		 ; buffer and echos. It ignores LF's but still echos
                  	           		 ; them back. Control-H is used to delete the last character
                  	           		 ; entered (if there is one), and control-X is used to delete the
                  	           		 ; whole line and start over again. CR signals the end of a line,
                  	           		 ; and causes 'GETLN' to return.
                  	           		 ;
                  	           		 ;
FFFFFFFFFFFFF068	           		 GETLN:
FFFFFFFFFFFFF068	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFF06C	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFF070	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFF074	31FFF7D5		 	call	GOOUT		; display the prompt
FFFFFFFFFFFFF078	E0400001		 	setlo	r1,#1		; turn on cursor flash
FFFFFFFFFFFFF07C	60009052		 	sb		r1,cursFlash
FFFFFFFFFFFFF080	E0400020		 	setlo	r1,#' '		; and a space
FFFFFFFFFFFFF084	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF088	E200111B		 	setlo	r8,#<BUFFER	; r8 is the buffer pointer
FFFFFFFFFFFFF08C	F2000000		 	sethi	r8,#>BUFFER
FFFFFFFFFFFFF090	           		 GL1:
FFFFFFFFFFFFF090	31FFFD77		 	call	CHKIO		; check keyboard
FFFFFFFFFFFFF094	BE107FE8		 	beq		r1,r0,GL1	; wait for a char. to come in
FFFFFFFFFFFFF098	B0100B08		 	beq		r1,#CTRLH,GL3	; delete last character? if so
FFFFFFFFFFFFF09C	B0101418		 	beq		r1,#CTRLX,GL4	; delete the whole line?
FFFFFFFFFFFFF0A0	B010020D		 	beq		r1,#CR,GL2	; accept a CR
FFFFFFFFFFFFF0A4	A81FFB20		 	bltu	r1,#' ',GL1	; if other control char., discard it
FFFFFFFFFFFFF0A8	           		 GL2:
FFFFFFFFFFFFF0A8	60808000		 	sb		r1,[r8]		; save the char.
FFFFFFFFFFFFF0AC	08840001		 	add		r8,r8,#1
FFFFFFFFFFFFF0B0	31FFF7D5		 	call	GOOUT		; echo the char back out
FFFFFFFFFFFFF0B4	4080FFFF		 	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
FFFFFFFFFFFFF0B8	B010190D		 	beq		r1,#CR,GL7	; if it's a CR, end the line
FFFFFFFFFFFFF0BC	1280916A		 	cmpui	r1,r8,#BUFFER+BUFLEN-1	; any more room?
FFFFFFFFFFFFF0C0	BE107E80		 	blt		r1,r0,GL1	; yes: get some more, else delete last char.
FFFFFFFFFFFFF0C4	           		 GL3:
FFFFFFFFFFFFF0C4	E0400008		 	setlo	r1,#CTRLH	; delete a char. if possible
FFFFFFFFFFFFF0C8	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF0CC	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFF0D0	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF0D4	1280911B		 	cmpui	r1,r8,#BUFFER	; any char.'s left?
FFFFFFFFFFFFF0D8	BE107DC2		 	ble		r1,r0,GL1		; if not
FFFFFFFFFFFFF0DC	E0400008		 	setlo	r1,#CTRLH	; if so, finish the BS-space-BS sequence
FFFFFFFFFFFFF0E0	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF0E4	0C840001		 	sub		r8,r8,#1	; decrement the text pointer
FFFFFFFFFFFFF0E8	BE007D4A		 	bra		GL1			; back for more
FFFFFFFFFFFFF0EC	           		 GL4:
FFFFFFFFFFFFF0EC	04800409		 	or		r1,r8,r0		; delete the whole line
FFFFFFFFFFFFF0F0	0E12911B		 	subui	r5,r1,#BUFFER   ; figure out how many backspaces we need
FFFFFFFFFFFFF0F4	BE500108		 	beq		r5,r0,GL6		; if none needed, brnch
FFFFFFFFFFFFF0F8	           		 GL5:
FFFFFFFFFFFFF0F8	E0400008		 	setlo	r1,#CTRLH	; and display BS-space-BS sequences
FFFFFFFFFFFFF0FC	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF100	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFF104	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF108	E0400008		 	setlo	r1,#CTRLH
FFFFFFFFFFFFF10C	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF110	BE02FF4F		 	loop	r5,GL5
FFFFFFFFFFFFF114	           		 GL6:
FFFFFFFFFFFFF114	9A04111B		 	lea		r8,BUFFER	; reinitialize the text pointer
FFFFFFFFFFFFF118	BE007BCA		 	bra		GL1			; and go back for more
FFFFFFFFFFFFF11C	           		 GL7:
FFFFFFFFFFFFF11C	E0400000		 	setlo	r1,#0		; turn off cursor flash
FFFFFFFFFFFFF120	60009052		 	sb		r1,cursFlash
FFFFFFFFFFFFF124	E040000A		 	setlo	r1,#LF		; echo a LF for the CR
FFFFFFFFFFFFF128	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF12C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF130	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFF134	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; 'FNDLN' finds a line with a given line no. (in r1) in the
                  	           		 ; text save area.  r9 is used as the text pointer. If the line
                  	           		 ; is found, r9 will point to the beginning of that line
                  	           		 ; (i.e. the high byte of the line no.), and flags are Z.
                  	           		 ; If that line is not there and a line with a higher line no.
                  	           		 ; is found, r9 points there and flags are NC & NZ. If we reached
                  	           		 ; the end of the text save area and cannot find the line, flags
                  	           		 ; are C & NZ.
                  	           		 ; Z=1 if line found
                  	           		 ; N=1 if end of text save area
                  	           		 ; Z=0 & N=0 if higher line found
                  	           		 ; r0 = 1	<= line is found
                  	           		 ;	r9 = pointer to line
                  	           		 ; r0 = 0    <= line is not found
                  	           		 ;	r9 = zero, if end of text area
                  	           		 ;	r9 = otherwise higher line number
                  	           		 ;
                  	           		 ; 'FNDLN' will initialize r9 to the beginning of the text save
                  	           		 ; area to start the search. Some other entries of this routine
                  	           		 ; will not initialize r9 and do the search.
                  	           		 ; 'FNDLNP' will start with r9 and search for the line no.
                  	           		 ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                  	           		 ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                  	           		 ; return Z=1 if line is found, r9 = pointer to line
                  	           		 ;
                  	           		 ; Parameters
                  	           		 ;	r1 = line number to find
                  	           		 ;
FFFFFFFFFFFFF138	           		 FNDLN:
FFFFFFFFFFFFF138	AC1003FF		 	bleui	r1,#0xFFFF,fl1	; line no. must be < 65535
FFFFFFFFFFFFF13C	9A00F78C		 	lea		r1,msgLineRange
FFFFFFFFFFFFF140	BE00774A		 	bra		ERROR
FFFFFFFFFFFFF144	           		 fl1:
FFFFFFFFFFFFF144	4604DF68		 	lw		r9,TXTBGN	; init. the text save pointer
                  	           		 
FFFFFFFFFFFFF148	           		 FNDLNP:
FFFFFFFFFFFFF148	460510D0		 	lw		r10,TXTUNF	; check if we passed the end
FFFFFFFFFFFFF14C	0EA50001		 	subui	r10,r10,#1
FFFFFFFFFFFFF150	BE950127		 	bgtu	r9,r10,FNDRET1		; if so, return with r9=0,r1=0
FFFFFFFFFFFFF154	4A918000		 	lbu		r3,[r9]		; get low order byte of line number
FFFFFFFFFFFFF158	4A910001		 	lbu		r2,1[r9]	; get high order byte
FFFFFFFFFFFFF15C	06211000		 	shli	r2,r2,#8
FFFFFFFFFFFFF160	04218809		 	or		r2,r2,r3	; build whole line number
FFFFFFFFFFFFF164	BE110127		 	bgtu	r1,r2,FNDNXT	; is this the line we want? no, not there yet
FFFFFFFFFFFFF168	BE1100C8		 	beq		r1,r2,FNDRET2
FFFFFFFFFFFFF16C	           		 FNDRET:
FFFFFFFFFFFFF16C	0410840A		 	xor		r1,r1,r1	; line not found, but r9=next line pointer
FFFFFFFFFFFFF170	37EF8000		 	ret			; return the cond. codes
FFFFFFFFFFFFF174	           		 FNDRET1:
FFFFFFFFFFFFF174	0494A40A		 	xor		r9,r9,r9	; no higher line
FFFFFFFFFFFFF178	0410840A		 	xor		r1,r1,r1	; line not found
FFFFFFFFFFFFF17C	37EF8000		 	ret
FFFFFFFFFFFFF180	           		 FNDRET2:
FFFFFFFFFFFFF180	E0400001		 	setlo	r1,#1		; line found
FFFFFFFFFFFFF184	37EF8000		 	ret
                  	           		 
FFFFFFFFFFFFF188	           		 FNDNXT:
FFFFFFFFFFFFF188	0A948002		 	addui	r9,r9,#2	; find the next line
                  	           		 
FFFFFFFFFFFFF18C	           		 FNDSKP:
FFFFFFFFFFFFF18C	4A910000		 	lbu		r2,[r9]
FFFFFFFFFFFFF190	0A948001		 	addui	r9,r9,#1
FFFFFFFFFFFFF194	B22FFE0D		 	bnei	r2,#CR,FNDSKP		; try to find a CR, keep looking
FFFFFFFFFFFFF198	BE007D8A		 	bra		FNDLNP		; check if end of text
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'MVUP' moves a block up from where r1 points to where r2 points
                  	           		 ; until r1=r3
                  	           		 ;
FFFFFFFFFFFFF19C	           		 MVUP1:
FFFFFFFFFFFFF19C	40120000		 	lb		r4,[r1]
FFFFFFFFFFFFF1A0	60220000		 	sb		r4,[r2]
FFFFFFFFFFFFF1A4	08108001		 	add		r1,r1,#1
FFFFFFFFFFFFF1A8	08210001		 	add		r2,r2,#1
FFFFFFFFFFFFF1AC	           		 MVUP:
FFFFFFFFFFFFF1AC	BE11FF89		 	bne		r1,r3,MVUP1
FFFFFFFFFFFFF1B0	           		 MVRET:
FFFFFFFFFFFFF1B0	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ; 'MVDOWN' moves a block down from where r1 points to where r2
                  	           		 ; points until r1=r3
                  	           		 ;
FFFFFFFFFFFFF1B4	           		 MVDOWN1:
FFFFFFFFFFFFF1B4	0C108001		 	sub		r1,r1,#1
FFFFFFFFFFFFF1B8	0C210001		 	sub		r2,r2,#1
FFFFFFFFFFFFF1BC	40120000		 	lb		r4,[r1]
FFFFFFFFFFFFF1C0	60220000		 	sb		r4,[r2]
FFFFFFFFFFFFF1C4	           		 MVDOWN:
FFFFFFFFFFFFF1C4	BE11FF89		 	bne		r1,r3,MVDOWN1
FFFFFFFFFFFFF1C8	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ; 'POPA' restores the 'FOR' loop variable save area from the stack
                  	           		 ;
                  	           		 ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                  	           		 ;
                  	           		 ; Note: a single zero word is stored on the stack in the
                  	           		 ; case that no FOR loops need to be saved. This needs to be
                  	           		 ; done because PUSHA / POPA is called all the time.
                  	           		 
FFFFFFFFFFFFF1CC	           		 POPA:
FFFFFFFFFFFFF1CC	47E08000		 	lw		r1,[sp]		; restore LOPVAR, but zero means no more
FFFFFFFFFFFFF1D0	660090A8		 	sw		r1,LOPVAR
FFFFFFFFFFFFF1D4	BE100148		 	beq		r1,r0,PP1
FFFFFFFFFFFFF1D8	47E08020		 	lw		r1,32[sp]	; if not zero, restore the rest
FFFFFFFFFFFFF1DC	660090C8		 	sw		r1,LOPPT
FFFFFFFFFFFFF1E0	47E08018		 	lw		r1,24[sp]
FFFFFFFFFFFFF1E4	660090C0		 	sw		r1,LOPLN
FFFFFFFFFFFFF1E8	47E08010		 	lw		r1,16[sp]
FFFFFFFFFFFFF1EC	660090B8		 	sw		r1,LOPLMT
FFFFFFFFFFFFF1F0	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFF1F4	660090B0		 	sw		r1,LOPINC
FFFFFFFFFFFFF1F8	37EF8028		 	ret		#40
FFFFFFFFFFFFF1FC	           		 PP1:
FFFFFFFFFFFFF1FC	37EF8008		 	ret		#8
                  	           		 
                  	           		 
FFFFFFFFFFFFF200	           		 PUSHA:
FFFFFFFFFFFFF200	460090F8		 	lw		r1,STKBOT	; Are we running out of stack room?
FFFFFFFFFFFFF204	0A108028		 	addui	r1,r1,#40	; we might need this many bytes
FFFFFFFFFFFFF208	BFE0F0A4		 	bltu	sp,r1,QSORRY	; out of stack space
FFFFFFFFFFFFF20C	460090A8		 	lw		r1,LOPVAR	; save loop variables
FFFFFFFFFFFFF210	BE100188		 	beq		r1,r0,PU1	; if LOPVAR is zero, that's all
FFFFFFFFFFFFF214	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFF218	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFF21C	460090C8		 	lw		r1,LOPPT
FFFFFFFFFFFFF220	67E08020		 	sw		r1,32[sp]	; else save all the others
FFFFFFFFFFFFF224	460090C0		 	lw		r1,LOPLN
FFFFFFFFFFFFF228	67E08018		 	sw		r1,24[sp]
FFFFFFFFFFFFF22C	460090B8		 	lw		r1,LOPLMT
FFFFFFFFFFFFF230	67E08010		 	sw		r1,16[sp]
FFFFFFFFFFFFF234	460090B0		 	lw		r1,LOPINC
FFFFFFFFFFFFF238	67E08008		 	sw		r1,8[sp]
FFFFFFFFFFFFF23C	37EF8000		 	ret
FFFFFFFFFFFFF240	           		 PU1:
FFFFFFFFFFFFF240	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFF244	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFF248	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                  	           		 ;
                  	           		 ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                  	           		 ; and returns to the caller when either a CR is printed or when
                  	           		 ; the next byte is the same as what was passed in r4 by the
                  	           		 ; caller.
                  	           		 ;
                  	           		 ; 'QTSTG' looks for an underline (back-arrow on some systems),
                  	           		 ; single-quote, or double-quote.  If none of these are found, returns
                  	           		 ; to the caller.  If underline, outputs a CR without a LF.  If single
                  	           		 ; or double quote, prints the quoted string and demands a matching
                  	           		 ; end quote.  After the printing, the next i-word of the caller is
                  	           		 ; skipped over (usually a branch instruction).
                  	           		 ;
                  	           		 ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                  	           		 ; needed to pad the number of spaces to the number in r4.
                  	           		 ; However, if the number of digits is larger than the no. in
                  	           		 ; r4, all digits are printed anyway. Negative sign is also
                  	           		 ; printed and counted in, positive sign is not.
                  	           		 ;
                  	           		 ; 'PRTLN' prints the saved text line pointed to by r3
                  	           		 ; with line no. and all.
                  	           		 ;
                  	           		 
                  	           		 ; r1 = pointer to string
                  	           		 ; r2 = stop character
                  	           		 ; return r1 = pointer to end of line + 1
                  	           		 
FFFFFFFFFFFFF24C	           		 PRTSTG:
FFFFFFFFFFFFF24C	0FEF0020		     subui   sp,sp,#32
FFFFFFFFFFFFF250	67E28000		     sw		r5,[sp]
FFFFFFFFFFFFF254	67E28008		     sw		r5,8[sp]
FFFFFFFFFFFFF258	67E38010		     sw		r7,16[sp]
FFFFFFFFFFFFF25C	67EF8018		     sw		lr,24[sp]
FFFFFFFFFFFFF260	02128009		     mov     r5,r1       ; r5 = pointer
FFFFFFFFFFFFF264	02230009		     mov     r6,r2       ; r6 = stop char
FFFFFFFFFFFFF268	           		 PS1:
FFFFFFFFFFFFF268	4A538000		     lbu     r7,[r5]     ; get a text character
FFFFFFFFFFFFF26C	0A528001		     addui   r5,r5,#1
FFFFFFFFFFFFF270	BE7300C8		 	beq	    r7,r6,PRTRET		; same as stop character? if so, return
FFFFFFFFFFFFF274	02708009		 	mov     r1,r7
FFFFFFFFFFFFF278	31FFF7D5		 	call	GOOUT		; display the char.
FFFFFFFFFFFFF27C	B27FFB0D		 	bnei    r7,#CR,PS1  ; is it a C.R.? no, go back for more
FFFFFFFFFFFFF280	E040000A		 	setlo   r1,#LF      ; yes, add a L.F.
FFFFFFFFFFFFF284	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF288	           		 PRTRET:
FFFFFFFFFFFFF288	02710009		     mov     r2,r7       ; return r2 = stop char
FFFFFFFFFFFFF28C	02508009		 	mov		r1,r5		; return r1 = line pointer
FFFFFFFFFFFFF290	47EF8018		     lw		lr,24[sp]
FFFFFFFFFFFFF294	47E38010		     lw		r7,16[sp]
FFFFFFFFFFFFF298	47E28008		     lw		r5,8[sp]
FFFFFFFFFFFFF29C	47E28000		     lw		r5,[sp]
FFFFFFFFFFFFF2A0	37EF8020		     ret		#32	        ; then return
                  	           		 
                  	           		 
FFFFFFFFFFFFF2A4	           		 QTSTG:
FFFFFFFFFFFFF2A4	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFF2A8	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFF2AC	E0C00022		 	setlo	r3,#'"'
FFFFFFFFFFFFF2B0	9A0272D4		 	lea		r4,QT3
FFFFFFFFFFFFF2B4	31FFFD30		 	call	TSTC		; *** QTSTG ***
FFFFFFFFFFFFF2B8	E0800022		 	setlo	r2,#'"'		; it is a "
FFFFFFFFFFFFF2BC	           		 QT1:
FFFFFFFFFFFFF2BC	04800409		 	or		r1,r8,r0
FFFFFFFFFFFFF2C0	31FFFC93		 	call	PRTSTG		; print until another
FFFFFFFFFFFFF2C4	04102009		 	lw		r8,r1
FFFFFFFFFFFFF2C8	B2200D0A		 	bne		r2,#LF,QT2	; was last one a CR?
FFFFFFFFFFFFF2CC	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFF2D0	BE00072A		 	bra		RUNNXL		; if so, run next line
FFFFFFFFFFFFF2D4	           		 QT3:
FFFFFFFFFFFFF2D4	E0C00027		 	setlo	r3,#''''
FFFFFFFFFFFFF2D8	9A0272E8		 	lea		r4,QT4
FFFFFFFFFFFFF2DC	31FFFD30		 	call	TSTC		; is it a single quote?
FFFFFFFFFFFFF2E0	E0800027		 	setlo	r2,#''''	; if so, do same as above
FFFFFFFFFFFFF2E4	BE007ECA		 	bra		QT1
FFFFFFFFFFFFF2E8	           		 QT4:
FFFFFFFFFFFFF2E8	E0C0005F		 	setlo	r3,#'_'
FFFFFFFFFFFFF2EC	9A027308		 	lea		r4,QT5
FFFFFFFFFFFFF2F0	31FFFD30		 	call	TSTC		; is it an underline?
FFFFFFFFFFFFF2F4	E040000D		 	setlo	r1,#CR		; if so, output a CR without LF
FFFFFFFFFFFFF2F8	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF2FC	           		 QT2:
FFFFFFFFFFFFF2FC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF300	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFF304	35F00004		 	jal		r0,4[lr]		; skip over next i-word when returning
FFFFFFFFFFFFF308	           		 QT5:						; not " ' or _
FFFFFFFFFFFFF308	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF30C	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; Output a CR LF sequence
                  	           		 ;
FFFFFFFFFFFFF310	           		 prCRLF:
FFFFFFFFFFFFF310	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFF314	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFF318	E040000D		 	setlo	r1,#CR
FFFFFFFFFFFFF31C	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF320	E040000A		 	setlo	r1,#LF
FFFFFFFFFFFFF324	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF328	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF32C	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; r1 = number to print
                  	           		 ; r2 = number of digits
                  	           		 ; Register Usage
                  	           		 ;	r5 = number of padding spaces
FFFFFFFFFFFFF330	           		 PRTNUM:
FFFFFFFFFFFFF330	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFF334	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFF338	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFF33C	67E30010		 	sw		r6,16[sp]
FFFFFFFFFFFFF340	67E38018		 	sw		r7,24[sp]
FFFFFFFFFFFFF344	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFF348	9A039100		 	lea		r7,NUMWKA	; r7 = pointer to numeric work area
FFFFFFFFFFFFF34C	02130009		 	mov		r6,r1		; save number for later
FFFFFFFFFFFFF350	02228009		 	mov		r5,r2		; r5 = min number of chars
FFFFFFFFFFFFF354	BE100063		 	bgt		r1,r0,PN2	; is it negative? if not
FFFFFFFFFFFFF358	02108006		 	neg		r1,r1		; else make it positive
FFFFFFFFFFFFF35C	0E528001		 	subui	r5,r5,#1	; one less for width count
FFFFFFFFFFFFF360	           		 PN2:
FFFFFFFFFFFFF360	1601800A		 	lw		r3,#10
FFFFFFFFFFFFF364	           		 PN1:
FFFFFFFFFFFFF364	0411881C		 	modu	r2,r1,r3	; r2 = r1 mod 10
FFFFFFFFFFFFF368	1E10800A		 	divui	r1,r1,#10	; r1 /= 10 divide by 10
FFFFFFFFFFFFF36C	0A210030		 	addui	r2,r2,#'0'	; convert remainder to ascii
FFFFFFFFFFFFF370	60710000		 	sb		r2,[r7]		; and store in buffer
FFFFFFFFFFFFF374	0A738001		 	addui	r7,r7,#1
FFFFFFFFFFFFF378	0E528001		 	subui	r5,r5,#1	; decrement width
FFFFFFFFFFFFF37C	BE107F49		 	bne		r1,r0,PN1
FFFFFFFFFFFFF380	           		 PN6:
FFFFFFFFFFFFF380	BE500082		 	ble		r5,r0,PN4	; test pad count, skip padding if not needed
FFFFFFFFFFFFF384	           		 PN3:
FFFFFFFFFFFFF384	E0400020		 	setlo	r1,#' '		; display the required leading spaces
FFFFFFFFFFFFF388	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF38C	BE02FFCF		 	loop	r5,PN3
FFFFFFFFFFFFF390	           		 PN4:
FFFFFFFFFFFFF390	BE600061		 	bge		r6,r0,PN5	; is number negative?
FFFFFFFFFFFFF394	E040002D		 	setlo	r1,#'-'		; if so, display the sign
FFFFFFFFFFFFF398	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF39C	           		 PN5:
FFFFFFFFFFFFF39C	0E738001		 	subui	r7,r7,#1
FFFFFFFFFFFFF3A0	40708000		 	lb		r1,[r7]		; now unstack the digits and display
FFFFFFFFFFFFF3A4	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF3A8	12709100		 	cmpui	r1,r7,#NUMWKA
FFFFFFFFFFFFF3AC	BE107F87		 	bgtu	r1,r0,PN5
FFFFFFFFFFFFF3B0	           		 PNRET:
FFFFFFFFFFFFF3B0	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFF3B4	47E38018		 	lw		r7,24[sp]
FFFFFFFFFFFFF3B8	47E30010		 	lw		r6,16[sp]
FFFFFFFFFFFFF3BC	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFF3C0	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFF3C4	37EF8028		 	ret		#40
                  	           		 
                  	           		 
                  	           		 ; r1 = number to print
                  	           		 ; r2 = number of digits
FFFFFFFFFFFFF3C8	           		 PRTHEXNUM:
FFFFFFFFFFFFF3C8	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFF3CC	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFF3D0	67E30008		 	sw		r6,8[sp]
FFFFFFFFFFFFF3D4	67E38010		 	sw		r7,16[sp]
FFFFFFFFFFFFF3D8	67E40018		 	sw		r8,24[sp]
FFFFFFFFFFFFF3DC	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFF3E0	9A039100		 	lea		r7,NUMWKA	; r7 = pointer to numeric work area
FFFFFFFFFFFFF3E4	04101809		 	or		r6,r1,r0	; save number for later
FFFFFFFFFFFFF3E8	E1400014		 	setlo	r5,#20		; r5 = min number of chars
FFFFFFFFFFFFF3EC	02120009		 	mov		r4,r1
FFFFFFFFFFFFF3F0	BE400083		 	bgt		r4,r0,PHN1		; is it negative? if not
FFFFFFFFFFFFF3F4	02420006		 	neg		r4,r4			; else make it positive
FFFFFFFFFFFFF3F8	0E528001		 	subui	r5,r5,#1	; one less for width count
FFFFFFFFFFFFF3FC	E2000014		 	setlo	r8,#20		; maximum of 10 digits
FFFFFFFFFFFFF400	           		 PHN1:
FFFFFFFFFFFFF400	02408009		 	mov		r1,r4
FFFFFFFFFFFFF404	1410800F		 	andi	r1,r1,#15
FFFFFFFFFFFFF408	A010030A		 	blt		r1,#10,PHN7
FFFFFFFFFFFFF40C	0A108037		 	addui	r1,r1,#'A'-10
FFFFFFFFFFFFF410	BE00004A		 	bra		PHN8
FFFFFFFFFFFFF414	           		 PHN7:
FFFFFFFFFFFFF414	08108030		 	add		r1,r1,#'0'		; convert remainder to ascii
FFFFFFFFFFFFF418	           		 PHN8:
FFFFFFFFFFFFF418	60708000		 	sb		r1,[r7]		; and store in buffer
FFFFFFFFFFFFF41C	0A738001		 	addui	r7,r7,#1
FFFFFFFFFFFFF420	0E528001		 	subui	r5,r5,#1	; decrement width
FFFFFFFFFFFFF424	06420801		 	shrui	r4,r4,#4
FFFFFFFFFFFFF428	BE400048		 	beq		r4,r0,PHN6			; is it zero yet ?
FFFFFFFFFFFFF42C	BE047EAF		 	loop	r8,PHN1		; safety
FFFFFFFFFFFFF430	           		 PHN6:	; test pad count
FFFFFFFFFFFFF430	BE500082		 	ble		r5,r0,PHN4	; skip padding if not needed
FFFFFFFFFFFFF434	           		 PHN3:
FFFFFFFFFFFFF434	E0400020		 	setlo	r1,#' '		; display the required leading spaces
FFFFFFFFFFFFF438	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF43C	BE02FFCF		 	loop	r5,PHN3
FFFFFFFFFFFFF440	           		 PHN4:
FFFFFFFFFFFFF440	BE600063		 	bgt		r6,r0,PHN5	; is number negative?
FFFFFFFFFFFFF444	E040002D		 	setlo	r1,#'-'		; if so, display the sign
FFFFFFFFFFFFF448	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF44C	           		 PHN5:
FFFFFFFFFFFFF44C	0E738001		 	subui	r7,r7,#1
FFFFFFFFFFFFF450	40708000		 	lb		r1,[r7]		; now unstack the digits and display
FFFFFFFFFFFFF454	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF458	12709100		 	cmpui	r1,r7,#NUMWKA
FFFFFFFFFFFFF45C	BE107F83		 	bgt		r1,r0,PHN5
FFFFFFFFFFFFF460	           		 PHNRET:
FFFFFFFFFFFFF460	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFF464	47E40018		 	lw		r8,24[sp]
FFFFFFFFFFFFF468	47E38010		 	lw		r7,16[sp]
FFFFFFFFFFFFF46C	47E30008		 	lw		r6,8[sp]
FFFFFFFFFFFFF470	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFF474	37EF8028		 	ret		#40
                  	           		 
                  	           		 
                  	           		 ; r1 = pointer to line
                  	           		 ; returns r1 = pointer to end of line + 1
FFFFFFFFFFFFF478	           		 PRTLN:
FFFFFFFFFFFFF478	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFF47C	67E28000		     sw		r5,[sp]
FFFFFFFFFFFFF480	67EF8008		     sw		lr,8[sp]
FFFFFFFFFFFFF484	08128002		     addi    r5,r1,#2
FFFFFFFFFFFFF488	4A50FFFE		     lbu		r1,-2[r5]	; get the binary line number
FFFFFFFFFFFFF48C	4A517FFF		     lbu		r2,-1[r5]
FFFFFFFFFFFFF490	06211000		     shli	r2,r2,#8
FFFFFFFFFFFFF494	04110409		     or		r1,r1,r2
FFFFFFFFFFFFF498	E0800000		     setlo   r2,#0       ; display a 0 or more digit line no.
FFFFFFFFFFFFF49C	31FFFCCC		 	call	PRTNUM
FFFFFFFFFFFFF4A0	E0400020		 	setlo   r1,#' '     ; followed by a blank
FFFFFFFFFFFFF4A4	31FFF7D5		 	call	GOOUT
FFFFFFFFFFFFF4A8	E0800000		 	setlo   r2,#0       ; stop char. is a zero
FFFFFFFFFFFFF4AC	04500409		 	or      r1,r5,r0
FFFFFFFFFFFFF4B0	31FFFC93		 	call    PRTSTG		; display the rest of the line
FFFFFFFFFFFFF4B4	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFF4B8	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFF4BC	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; ===== Test text byte following the call to this subroutine. If it
                  	           		 ;	equals the byte pointed to by r8, return to the code following
                  	           		 ;	the call. If they are not equal, brnch to the point
                  	           		 ;	indicated in r4.
                  	           		 ;
                  	           		 ; Registers Affected
                  	           		 ;   r3,r8
                  	           		 ; Returns
                  	           		 ;	r8 = updated text pointer
                  	           		 ;
FFFFFFFFFFFFF4C0	           		 TSTC
FFFFFFFFFFFFF4C0	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFF4C4	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFF4C8	67E08008		 	sw		r1,8[sp]
FFFFFFFFFFFFF4CC	31FFFD55		 	call	IGNBLK		; ignore leading blanks
FFFFFFFFFFFFF4D0	40808000		 	lb		r1,[r8]
FFFFFFFFFFFFF4D4	BE3080A8		 	beq		r3,r1,TC1	; is it = to what r8 points to? if so
FFFFFFFFFFFFF4D8	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFF4DC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF4E0	0BEF0010		 	addui	sp,sp,#16
FFFFFFFFFFFFF4E4	34400000		 	jal		r0,[r4]		; jump to the routine
FFFFFFFFFFFFF4E8	           		 TC1:
FFFFFFFFFFFFF4E8	0A840001		 	addui	r8,r8,#1	; if equal, bump text pointer
FFFFFFFFFFFFF4EC	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFF4F0	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF4F4	37EF8010		 	ret		#16
                  	           		 
                  	           		 ; ===== See if the text pointed to by r8 is a number. If so,
                  	           		 ;	return the number in r2 and the number of digits in r3,
                  	           		 ;	else return zero in r2 and r3.
                  	           		 ; Registers Affected
                  	           		 ;   r1,r2,r3,r4
                  	           		 ; Returns
                  	           		 ; 	r1 = number
                  	           		 ;	r2 = number of digits in number
                  	           		 ;	r8 = updated text pointer
                  	           		 ;
FFFFFFFFFFFFF4F8	           		 TSTNUM:
FFFFFFFFFFFFF4F8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFF4FC	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFF500	31FFFD55		 	call	IGNBLK		; skip over blanks
FFFFFFFFFFFFF504	E0400000		 	setlo	r1,#0		; initialize return parameters
FFFFFFFFFFFFF508	E0800000		 	setlo	r2,#0
FFFFFFFFFFFFF50C	           		 TN1:
FFFFFFFFFFFFF50C	40818000		 	lb		r3,[r8]
FFFFFFFFFFFFF510	A8300F30		 	bltui	r3,#'0',TSNMRET	; is it less than zero?
FFFFFFFFFFFFF514	AE300E39		 	bgtui	r3,#'9',TSNMRET	; is it greater than nine?
FFFFFFFFFFFFF518	E6BFFFFF		; SETLO
FFFFFFFFFFFFF51C	EEBFFFFF		; SETMID
FFFFFFFFFFFFF520	F6807FFF		; SETHI
FFFFFFFFFFFFF524	040D1009		 	lw		r4,#0x07FFFFFF_FFFFFFFF
FFFFFFFFFFFFF528	BE120066		 	bleu	r1,r4,TN2	; see if there's room for new digit
FFFFFFFFFFFFF52C	9A00F721		 	lea		r1,msgNumTooBig
FFFFFFFFFFFFF530	BE0057CA		 	bra		ERROR		; if not, we've overflowd
FFFFFFFFFFFFF534	           		 TN2:
FFFFFFFFFFFFF534	1A10800A		 	mului	r1,r1,#10	; quickly multiply result by 10
FFFFFFFFFFFFF538	0A840001		 	addui	r8,r8,#1	; adjust text pointer
FFFFFFFFFFFFF53C	1431800F		 	andi	r3,r3,#0x0F	; add in the new digit
FFFFFFFFFFFFF540	04118403		 	addu	r1,r1,r3
FFFFFFFFFFFFF544	0A210001		 	addui	r2,r2,#1	; increment the no. of digits
FFFFFFFFFFFFF548	BE007E2A		 	bra		TN1
FFFFFFFFFFFFF54C	           		 TSNMRET:
FFFFFFFFFFFFF54C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF550	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ;===== Skip over blanks in the text pointed to by r8.
                  	           		 ;
                  	           		 ; Registers Affected:
                  	           		 ;	r8
                  	           		 ; Returns
                  	           		 ;	r8 = pointer updateded past any spaces or tabs
                  	           		 ;
FFFFFFFFFFFFF554	           		 IGNBLK:
FFFFFFFFFFFFF554	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFF558	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFF55C	           		 IGB2:
FFFFFFFFFFFFF55C	40808000		 	lb		r1,[r8]			; get char
FFFFFFFFFFFFF560	B0100220		 	beqi	r1,#' ',IGB1	; see if it's a space
FFFFFFFFFFFFF564	B2100300		 	bnei	r1,#'\t',IGBRET	; or a tab
FFFFFFFFFFFFF568	           		 IGB1:
FFFFFFFFFFFFF568	0A840001		 	addui	r8,r8,#1		; increment the text pointer
FFFFFFFFFFFFF56C	BE007F8A		 	bra		IGB2
FFFFFFFFFFFFF570	           		 IGBRET:
FFFFFFFFFFFFF570	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFF574	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; ===== Convert the line of text in the input buffer to upper
                  	           		 ;	case (except for stuff between quotes).
                  	           		 ;
                  	           		 ; Registers Affected
                  	           		 ;   r1,r3
                  	           		 ; Returns
                  	           		 ;	r8 = pointing to end of text in buffer
                  	           		 ;
FFFFFFFFFFFFF578	           		 TOUPBUF:
FFFFFFFFFFFFF578	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFF57C	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFF580	9A04111B		 	lea		r8,BUFFER	; set up text pointer
FFFFFFFFFFFFF584	E0C00000		 	setlo	r3,#0		; clear quote flag
FFFFFFFFFFFFF588	           		 TOUPB1:
FFFFFFFFFFFFF588	40808000		 	lb		r1,[r8]		; get the next text char.
FFFFFFFFFFFFF58C	0A840001		 	addui	r8,r8,#1
FFFFFFFFFFFFF590	B0100D0D		 	beqi	r1,#CR,TOUPBRT		; is it end of line?
FFFFFFFFFFFFF594	B0100622		 	beqi	r1,#'"',DOQUO	; a double quote?
FFFFFFFFFFFFF598	B0100527		 	beqi	r1,#'''',DOQUO	; or a single quote?
FFFFFFFFFFFFF59C	BE307F69		 	bne		r3,r0,TOUPB1	; inside quotes?
FFFFFFFFFFFFF5A0	31FFFD73		 	call	toUpper 	; convert to upper case
FFFFFFFFFFFFF5A4	6080FFFF		 	sb		r1,-1[r8]	; store it
FFFFFFFFFFFFF5A8	BE007F0A		 	bra		TOUPB1		; and go back for more
FFFFFFFFFFFFF5AC	           		 DOQUO:
FFFFFFFFFFFFF5AC	BE300069		 	bne		r3,r0,DOQUO1; are we inside quotes?
FFFFFFFFFFFFF5B0	02118009		 	mov		r3,r1		; if not, toggle inside-quotes flag
FFFFFFFFFFFFF5B4	BE007EAA		 	bra		TOUPB1
FFFFFFFFFFFFF5B8	           		 DOQUO1:
FFFFFFFFFFFFF5B8	BE30FE89		 	bne		r3,r1,TOUPB1		; make sure we're ending proper quote
FFFFFFFFFFFFF5BC	E0C00000		 	setlo	r3,#0		; else clear quote flag
FFFFFFFFFFFFF5C0	BE007E4A		 	bra		TOUPB1
FFFFFFFFFFFFF5C4	           		 TOUPBRT:
FFFFFFFFFFFFF5C4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFF5C8	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; ===== Convert the character in r1 to upper case
                  	           		 ;
FFFFFFFFFFFFF5CC	           		 toUpper
FFFFFFFFFFFFF5CC	A0100361		 	blti	r1,#'a',TOUPRET	; is it < 'a'?
FFFFFFFFFFFFF5D0	A610027A		 	bgti	r1,#'z',TOUPRET	; or > 'z'?
FFFFFFFFFFFFF5D4	0E108020		 	subui	r1,r1,#32	; if not, make it upper case
FFFFFFFFFFFFF5D8	           		 TOUPRET
FFFFFFFFFFFFF5D8	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ; 'CHKIO' checks the input. If there's no input, it will return
                  	           		 ; to the caller with the r1=0. If there is input, the input byte is in r1.
                  	           		 ; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                  	           		 ; not return to the caller.
                  	           		 ;
FFFFFFFFFFFFF5DC	           		 CHKIO:
FFFFFFFFFFFFF5DC	0FEF0008		 	subui	sp,sp,#8	; save link reg
FFFFFFFFFFFFF5E0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFF5E4	31FFF7D6		 	call	GOIN		; get input if possible
FFFFFFFFFFFFF5E8	B01003FF		 	beqi	r1,#-1,CHKRET2		; if Zero, no input
FFFFFFFFFFFFF5EC	B2100303		 	bnei	r1,#CTRLC,CHKRET	; is it control-C?
FFFFFFFFFFFFF5F0	33FFF801		 	jmp		WSTART		; if so, do a warm start
FFFFFFFFFFFFF5F4	           		 CHKRET2:
FFFFFFFFFFFFF5F4	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFF5F8	           		 CHKRET:
FFFFFFFFFFFFF5F8	47EF8000		 	lw		lr,[sp]		;r1=0
FFFFFFFFFFFFF5FC	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; ===== Display a CR-LF sequence
                  	           		 ;
FFFFFFFFFFFFF600	           		 CRLF:
FFFFFFFFFFFFF600	E07FF703		 	setlo	r1,CLMSG
                  	           		 
                  	           		 
                  	           		 ; ===== Display a zero-ended string pointed to by register r1
                  	           		 ; Registers Affected
                  	           		 ;   r1,r2,r4
                  	           		 ;
FFFFFFFFFFFFF604	           		 PRMESG:
FFFFFFFFFFFFF604	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFF608	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFF60C	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFF610	02128009		 	mov     r5,r1       ; r5 = pointer to message
FFFFFFFFFFFFF614	           		 PRMESG1:
FFFFFFFFFFFFF614	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFF618	4A50FFFF		 	lbu		r1,-1[r5]	; 	get the char.
FFFFFFFFFFFFF61C	BE100068		 	beq		r1,r0,PRMRET
FFFFFFFFFFFFF620	31FFF7D5		 	call	GOOUT		;else display it trashes r4
FFFFFFFFFFFFF624	BE007F8A		 	bra		PRMESG1
FFFFFFFFFFFFF628	           		 PRMRET:
FFFFFFFFFFFFF628	02508009		 	mov		r1,r5
FFFFFFFFFFFFF62C	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFF630	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFF634	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; ===== Display a zero-ended string pointed to by register r1
                  	           		 ; Registers Affected
                  	           		 ;   r1,r2,r3
                  	           		 ;
FFFFFFFFFFFFF638	           		 PRMESGAUX:
FFFFFFFFFFFFF638	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFF63C	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFF640	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFF644	02128009		 	mov     r5,r1       ; r3 = pointer
FFFFFFFFFFFFF648	           		 PRMESGA1:
FFFFFFFFFFFFF648	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFF64C	4050FFFF		 	lb		r1,-1[r5]	; 	get the char.
FFFFFFFFFFFFF650	BE100068		 	beq		r1,r0,PRMRETA
FFFFFFFFFFFFF654	31FFF7D7		 	call	GOAUXO		;else display it
FFFFFFFFFFFFF658	BE007F8A		 	bra		PRMESGA1
FFFFFFFFFFFFF65C	           		 PRMRETA:
FFFFFFFFFFFFF65C	02508009		 	mov		r1,r5
FFFFFFFFFFFFF660	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFF664	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFF668	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;*****************************************************
                  	           		 ; The following routines are the only ones that need *
                  	           		 ; to be changed for a different I/O environment.     *
                  	           		 ;*****************************************************
                  	           		 
                  	           		 
                  	           		 ; ===== Output character to the console (Port 1) from register r1
                  	           		 ;	(Preserves all registers.)
                  	           		 ;
FFFFFFFFFFFFF66C	           		 OUTC:
FFFFFFFFFFFFF66C	33FFF07F		 	jmp		DisplayChar
                  	           		 
                  	           		 
                  	           		 ; ===== Input a character from the console into register R1 (or
                  	           		 ;	return Zero status if there's no character available).
                  	           		 ;
FFFFFFFFFFFFF670	           		 INC:
FFFFFFFFFFFFF670	33FFEF07		 	jmp		KeybdGetChar
                  	           		 
                  	           		 
                  	           		 ;*
                  	           		 ;* ===== Input a character from the host into register r1 (or
                  	           		 ;*	return Zero status if there's no character available).
                  	           		 ;*
FFFFFFFFFFFFF674	           		 AUXIN:
FFFFFFFFFFFFF674	31FFEDA4		 	call	SerialGetChar
FFFFFFFFFFFFF678	B01003FF		 	beqi	r1,#-1,AXIRET_ZERO
FFFFFFFFFFFFF67C	1410807F		 	andi	r1,r1,#0x7f		;zero out the high bit
FFFFFFFFFFFFF680	           		 AXIRET:
FFFFFFFFFFFFF680	37EF8000		 	ret
FFFFFFFFFFFFF684	           		 AXIRET_ZERO:
FFFFFFFFFFFFF684	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFF688	37EF8000		 	ret
                  	           		 
                  	           		 ; ===== Output character to the host (Port 2) from register r1
                  	           		 ;	(Preserves all registers.)
                  	           		 ;
FFFFFFFFFFFFF68C	           		 AUXOUT
FFFFFFFFFFFFF68C	33FFED5C		 	jmp		SerialPutChar	; call boot rom routine
                  	           		 
                  	           		 
FFFFFFFFFFFFF690	           		 _cls
FFFFFFFFFFFFF690	31FFF011		 	call	clearScreen
FFFFFFFFFFFFF694	BE00742A		 	bra		FINISH
                  	           		 
FFFFFFFFFFFFF698	           		 _wait10
FFFFFFFFFFFFF698	37EF8000		 	ret
FFFFFFFFFFFFF69C	           		 _getATAStatus
FFFFFFFFFFFFF69C	37EF8000		 	ret
FFFFFFFFFFFFF6A0	           		 _waitCFNotBusy
FFFFFFFFFFFFF6A0	37EF8000		 	ret
FFFFFFFFFFFFF6A4	           		 _rdcf
FFFFFFFFFFFFF6A4	BE0073AA		 	br		FINISH
FFFFFFFFFFFFF6A8	           		 rdcf6
FFFFFFFFFFFFF6A8	BE004C0A		 	br		ERROR
                  	           		 
                  	           		 
                  	           		 ; ===== Return to the resident monitor, operating system, etc.
                  	           		 ;
FFFFFFFFFFFFF6AC	           		 BYEBYE:
FFFFFFFFFFFFF6AC	460F1088		 	lw		sp,OSSP
FFFFFFFFFFFFF6B0	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFF6B4	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;	MOVE.B	#228,D7 	return to Tutor
                  	           		 ;	TRAP	#14
                  	           		 
FFFFFFFFFFFFF6B8 726F747061520A0D	 msgInit db	CR,LF,"Raptor64 Tiny BASIC v1.0",CR,LF,"(C) 2013  Robert Finch",CR,LF,LF,0
FFFFFFFFFFFFF6C0 20796E6954203436
FFFFFFFFFFFFF6C8 3176204349534142
FFFFFFFFFFFFF6D0 202943280A0D302E
FFFFFFFFFFFFF6D8 6F52202033313032
FFFFFFFFFFFFF6E0 6E69462074726562
FFFFFFFFFFFFF6E8 0A0D000A0A0D6863	 OKMSG	db	CR,LF,"OK",CR,LF,0
FFFFFFFFFFFFF6F0 616857000A0D4B4F	 msgWhat	db	"What?",CR,LF,0
FFFFFFFFFFFFF6F8 726F53000A0D3F74	 SRYMSG	db	"Sorry."
FFFFFFFFFFFFF700 6F43000A0D2E7972	 msgReadError	db	"Compact FLASH read error",CR,LF,0
FFFFFFFFFFFFF708 4C4620746361706D
FFFFFFFFFFFFF710 6461657220485341
FFFFFFFFFFFFF718 0A0D726F72726520
FFFFFFFFFFFFF720 207265626D754E00	 msgNumTooBig	db	"Number is too big",CR,LF,0
FFFFFFFFFFFFF728 62206F6F74207369
FFFFFFFFFFFFF730 766944000A0D6769	 msgDivZero		db	"Division by zero",CR,LF,0
FFFFFFFFFFFFF738 7962206E6F697369
FFFFFFFFFFFFF740 000A0D6F72657A20
FFFFFFFFFFFFF748 7620666F2074754F	 msgVarSpace     db  "Out of variable space",CR,LF,0
FFFFFFFFFFFFF750 20656C6261697261
FFFFFFFFFFFFF758 000A0D6563617073
FFFFFFFFFFFFF760 6620736574796220	 msgBytesFree	db	" bytes free",CR,LF,0
FFFFFFFFFFFFF768 0A0D000A0D656572	 msgReady		db	CR,LF,"Ready",CR,LF,0
FFFFFFFFFFFFF770 000A0D7964616552
FFFFFFFFFFFFF778 6E69746365707845	 msgComma		db	"Expecting a comma",CR,LF,0
FFFFFFFFFFFFF780 6D6D6F6320612067
FFFFFFFFFFFFF788 656E694C000A0D61	 msgLineRange	db	"Line number too big",CR,LF,0
FFFFFFFFFFFFF790 207265626D756E20
FFFFFFFFFFFFF798 0D676962206F6F74
FFFFFFFFFFFFF7A0 746365707845000A	 msgVar			db	"Expecting a variable",CR,LF,0
FFFFFFFFFFFFF7A8 6176206120676E69
FFFFFFFFFFFFF7B0 0A0D656C62616972
FFFFFFFFFFFFF7B8 64616220444E5200	 msgRNDBad		db	"RND bad parameter",CR,LF,0
FFFFFFFFFFFFF7C0 74656D6172617020
FFFFFFFFFFFFF7C8 535953000A0D7265	 msgSYSBad		db	"SYS bad address",CR,LF,0
FFFFFFFFFFFFF7D0 6464612064616220
FFFFFFFFFFFFF7D8 49000A0D73736572	 msgInputVar		db	"INPUT expecting a variable",CR,LF,0
FFFFFFFFFFFFF7E0 707865205455504E
FFFFFFFFFFFFF7E8 6120676E69746365
FFFFFFFFFFFFF7F0 6C62616972617620
FFFFFFFFFFFFF7F8 5458454E000A0D65	 msgNextFor		db	"NEXT without FOR",CR,LF,0
FFFFFFFFFFFFF800 74756F6874697720
FFFFFFFFFFFFF808 4E000A0D524F4620	 msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
FFFFFFFFFFFFF810 6570786520545845
FFFFFFFFFFFFF818 206120676E697463
FFFFFFFFFFFFF820 2064656E69666564
FFFFFFFFFFFFF828 656C626169726176
FFFFFFFFFFFFF830 2F4F544F47000A0D	 msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
FFFFFFFFFFFFF838 6162204255534F47
FFFFFFFFFFFFF840 6E20656E696C2064
FFFFFFFFFFFFF848 000A0D7265626D75
FFFFFFFFFFFFF850 77204E5255544552	 msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
FFFFFFFFFFFFF858 472074756F687469
FFFFFFFFFFFFF860 50000A0D4255534F	 msgTooBig		db	"Program is too big",CR,LF,0
FFFFFFFFFFFFF868 69206D6172676F72
FFFFFFFFFFFFF870 6962206F6F742073
FFFFFFFFFFFFF878 72747845000A0D67	 msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
FFFFFFFFFFFFF880 6361726168632061
FFFFFFFFFFFFF888 206E6F2073726574
FFFFFFFFFFFFF890 6E676920656E696C
                  	           		 
FFFFFFFFFFFFF898 00000A0D6465726F	 	align	8
FFFFFFFFFFFFF8A0	           		 	align	8
                  	           		 LSTROM	equ	*		; end of possible ROM area
                  	           		 ;	END
                  	           		 
                  	           		 ;*
                  	           		 ;* ===== Return to the resident monitor, operating system, etc.
                  	           		 ;*
FFFFFFFFFFFFF8A0	           		 BYEBYE:
FFFFFFFFFFFFF8A0	33FFF20A		 	jmp		Monitor
                  	           		 ;    MOVE.B	#228,D7 	;return to Tutor
                  	           		 ;	TRAP	#14
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Checkerboard RAM tester
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFF8A4	           		 	code
FFFFFFFFFFFFF8A0 0000000033FFF20A	 	align	16
FFFFFFFFFFFFF8A8 0000000000000000
FFFFFFFFFFFFF8B0	           		 	align	16
FFFFFFFFFFFFF8B0	           		 ramtest:
FFFFFFFFFFFFF8B0	04002009		 	or		r8,r0,r0		; r8 = 0
FFFFFFFFFFFFF8B4	E6AA5555		; SETLO
FFFFFFFFFFFFF8B8	EE9556AA		; SETMID
FFFFFFFFFFFFF8BC	F68AAAA5		; SETHI
FFFFFFFFFFFFF8C0	040D0409		 	ori		r1,r0,#0xAAAA5555AAAA5555	; checkerboard pattern
FFFFFFFFFFFFF8C4	           		 ramtest2:
FFFFFFFFFFFFF8C4	66808000		 	sw		r1,[r8]			; save the checkerboard to memory
FFFFFFFFFFFFF8C8	46810000		 	lw		r2,[r8]			; read it back
FFFFFFFFFFFFF8CC	04110C06		 	cmp		r3,r1,r2		; is it the same ?
FFFFFFFFFFFFF8D0	BE3000C9		 	bne 	r3,r0,ramtest1
FFFFFFFFFFFFF8D4	0A840008		 	addui	r8,r8,#8		; increment RAM pointer
FFFFFFFFFFFFF8D8	E6800000		; SETLO
FFFFFFFFFFFFF8DC	EE800010		; SETMID
FFFFFFFFFFFFF8E0	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0400_0000
FFFFFFFFFFFFF8E4	BE307F00		 	blt		r3,r0,ramtest2
FFFFFFFFFFFFF8E8	           		 ramtest1:
FFFFFFFFFFFFF8E8	04802809		 	or		r10,r8,r0		; r10 = max ram address
                  	           		 	; readback the checkerboard pattern
FFFFFFFFFFFFF8EC	04002009		 	or		r8,r0,r0		; r8 = 0
FFFFFFFFFFFFF8F0	           		 ramtest4:
FFFFFFFFFFFFF8F0	46810000		 	lw		r2,[r8]
FFFFFFFFFFFFF8F4	E6AA5555		; SETLO
FFFFFFFFFFFFF8F8	EE9556AA		; SETMID
FFFFFFFFFFFFF8FC	F68AAAA5		; SETHI
FFFFFFFFFFFFF900	042D0C06		 	cmpi	r3,r2,#0xAAAA5555AAAA5555
FFFFFFFFFFFFF904	BE3000C9		 	bne		r3,r0,ramtest3
FFFFFFFFFFFFF908	08840008		 	addi	r8,r8,#8
FFFFFFFFFFFFF90C	E6800000		; SETLO
FFFFFFFFFFFFF910	EE800004		; SETMID
FFFFFFFFFFFFF914	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0100_0000
FFFFFFFFFFFFF918	BE307EC0		 	blt 	r3,r0,ramtest4
FFFFFFFFFFFFF91C	           		 ramtest3:
FFFFFFFFFFFFF91C	BE850389		 	bne		r8,r10,ramtest8	; check for equal maximum address
                  	           		 
                  	           		 	; perform ramtest again with inverted checkerboard
FFFFFFFFFFFFF920	04002009		 	or		r8,r0,r0		; r8 = 0
FFFFFFFFFFFFF924	E695AAAA		; SETLO
FFFFFFFFFFFFF928	EEAAA955		; SETMID
FFFFFFFFFFFFF92C	F685555A		; SETHI
FFFFFFFFFFFFF930	040D0409		 	ori		r1,r0,#0x5555AAAA5555AAAA
FFFFFFFFFFFFF934	           		 ramtest5:
FFFFFFFFFFFFF934	66808000		 	sw		r1,[r8]
FFFFFFFFFFFFF938	46810000		 	lw		r2,[r8]
FFFFFFFFFFFFF93C	04110C06		 	cmp		r3,r1,r2
FFFFFFFFFFFFF940	BE3000C9		 	bne		r3,r0,ramtest6
FFFFFFFFFFFFF944	08840008		 	addi	r8,r8,#8
FFFFFFFFFFFFF948	E6800000		; SETLO
FFFFFFFFFFFFF94C	EE800004		; SETMID
FFFFFFFFFFFFF950	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0100_0000
FFFFFFFFFFFFF954	BE307F00		 	blt		r3,r0,ramtest5
FFFFFFFFFFFFF958	           		 ramtest6:
FFFFFFFFFFFFF958	04802C09		 	or		r11,r8,r0		; r11 = max ram address
                  	           		 	; readback checkerboard
FFFFFFFFFFFFF95C	04002009		 	or		r8,r0,r0
FFFFFFFFFFFFF960	           		 ramtest7:
FFFFFFFFFFFFF960	46810000		 	lw		r2,[r8]
FFFFFFFFFFFFF964	E695AAAA		; SETLO
FFFFFFFFFFFFF968	EEAAA955		; SETMID
FFFFFFFFFFFFF96C	F685555A		; SETHI
FFFFFFFFFFFFF970	042D0C06		 	cmpi	r3,r2,#0x5555AAAA5555AAAA
FFFFFFFFFFFFF974	BE3000C9		 	bne		r3,r0,ramtest8
FFFFFFFFFFFFF978	08840008		 	addi	r8,r8,#8
FFFFFFFFFFFFF97C	E6800000		; SETLO
FFFFFFFFFFFFF980	EE800004		; SETMID
FFFFFFFFFFFFF984	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0100_0000
FFFFFFFFFFFFF988	BE307EC0		 	blt		r3,r0,ramtest7
FFFFFFFFFFFFF98C	           		 ramtest8:
FFFFFFFFFFFFF98C	BE858048		 	beq		r8,r11,ramtest9
FFFFFFFFFFFFF990	0485A014		 	min		r8,r8,r11
FFFFFFFFFFFFF994	           		 ramtest9:
FFFFFFFFFFFFF994	BE850048		 	beq		r8,r10,ramtest10
FFFFFFFFFFFFF998	04852014		 	min		r8,r8,r10
FFFFFFFFFFFFF99C	           		 ramtest10:
FFFFFFFFFFFFF99C	66040400		 	sw		r8,0x00000400	;memend
FFFFFFFFFFFFF9A0	37EF8000		 	ret
                  	           		 
                  	           		 ;-------------------------------------------
                  	           		 ;-------------------------------------------
                  	           		 ;
FFFFFFFFFFFFF9A4	           		 iberr_rout:
FFFFFFFFFFFFF9A4	9A00FA3B		 	lea		r1,msgiberr
FFFFFFFFFFFFF9A8	31FFF122		 	call	DisplayString
FFFFFFFFFFFFF9AC	020085E8		 	mfspr	r1,EPC
FFFFFFFFFFFFF9B0	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFF9B4	00000028		 	wait
FFFFFFFFFFFFF9B8	33FFEC0B		 	jmp		start
FFFFFFFFFFFFF9BC	           		 dberr_rout:
FFFFFFFFFFFFF9BC	E6A00100		; SETLO
FFFFFFFFFFFFF9C0	EE800400		; SETMID
FFFFFFFFFFFFF9C4	040D7809		 	lw		sp,#0x100200100
FFFFFFFFFFFFF9C8	9A00FA20		 	lea		r1,msgdberr
FFFFFFFFFFFFF9CC	31FFF122		 	call	DisplayString
FFFFFFFFFFFFF9D0	02008628		 	mfspr	r1,ERRADR
FFFFFFFFFFFFF9D4	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFF9D8	9A00FA34		 	lea		r1,msgEPC
FFFFFFFFFFFFF9DC	31FFF122		 	call	DisplayString
FFFFFFFFFFFFF9E0	020085E8		 	mfspr	r1,EPC
FFFFFFFFFFFFF9E4	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFF9E8	31FFFD80		 	call	CRLF
FFFFFFFFFFFFF9EC	1601001F		 	lw		r2,#31
FFFFFFFFFFFFF9F0	           		 dberr1:
FFFFFFFFFFFFF9F0	02200FA9		 	mtspr	PCHI,r2
FFFFFFFFFFFFF9F4	DE000000		 	nop
FFFFFFFFFFFFF9F8	DE000000		 	nop
FFFFFFFFFFFFF9FC	DE000000		 	nop
FFFFFFFFFFFFFA00	02008FE8		 	mfspr	r1,PCHISTORIC
FFFFFFFFFFFFFA04	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFFA08	31FFFD80		 	call	CRLF
FFFFFFFFFFFFFA0C	BE017F2F		 	loop	r2,dberr1
FFFFFFFFFFFFFA10	00000028		 	wait
FFFFFFFFFFFFFA14	33FFEC0B		 	jmp		start
FFFFFFFFFFFFFA18 0000000000000000	 	.align	16
FFFFFFFFFFFFFA20	           		 	.align	16
FFFFFFFFFFFFFA20	           		 msgdberr:
FFFFFFFFFFFFFA20 7375622061746144	 	db	"Data bus error at: ",0
FFFFFFFFFFFFFA28 6120726F72726520
FFFFFFFFFFFFFA34	           		 msgEPC:
FFFFFFFFFFFFFA30 4350452000203A74	 	db	" EPC: ",0
FFFFFFFFFFFFFA3B	           		 msgiberr:
FFFFFFFFFFFFFA38 662072724500203A	 	db	"Err fetching instruction at: ",0
FFFFFFFFFFFFFA40 20676E6968637465
FFFFFFFFFFFFFA48 7463757274736E69
FFFFFFFFFFFFFA50 203A7461206E6F69
FFFFFFFFFFFFFA5C	           		 	.align	4
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; IRQ routine
                  	           		 ;
                  	           		 ; Interrupts are automatically disabled at the time of the interrupt in order
                  	           		 ; to prevent nested interrupts from occuring. Interrupts are re-enabled by
                  	           		 ; the IRET instruction at the end of the interrupt routine. If the interrupt
                  	           		 ; turns out to not match a hardware interrupt, then a software context
                  	           		 ; switching interrupt is assumed.
                  	           		 ;
                  	           		 ; This routine uses it's own private interrupt stack; the stack of the
                  	           		 ; interrupted context is not used at all. A couple of working registers are
                  	           		 ; saved off not on the stack. We can get away with this because nested
                  	           		 ; interrupts are not allowed.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFFA5C	           		 irqrout:
FFFFFFFFFFFFFA5C	660F1460		 	sw		sp,sp_save				; use our own private stack for interrupt processing
FFFFFFFFFFFFFA60	660F9468		 	sw		lr,lr_save				; so, save off the sp and working registers
FFFFFFFFFFFFFA64	660D1480		 	sw		r26,r26_save
FFFFFFFFFFFFFA68	66009470		 	sw		r1,r1_save
FFFFFFFFFFFFFA6C	66011478		 	sw		r2,r2_save
                  	           		 
FFFFFFFFFFFFFA70	E6801000		; SETLO
FFFFFFFFFFFFFA74	EE800400		; SETMID
FFFFFFFFFFFFFA78	040D7809		 	lw		sp,#0x1_00001000		; the second two kbytes
FFFFFFFFFFFFFA7C	E69C0FF0		; SETLO
FFFFFFFFFFFFFA80	EE800003		; SETMID
FFFFFFFFFFFFFA84	6A0D0421		 	inch	r1,PIC					; r1= which IRQ line is active
                  	           		 
                  	           		 ; Dispatch fork, in order of required timeliness
                  	           		 
FFFFFFFFFFFFFA88	B0100D02		 	beqi	r1,#2,irq1000Hz
FFFFFFFFFFFFFA8C	B0101903		 	beqi	r1,#3,irq100Hz
FFFFFFFFFFFFFA90	B0102008		 	beqi	r1,#8,irqSerial
FFFFFFFFFFFFFA94	B010220D		 	beqi	r1,#13,irqRaster
FFFFFFFFFFFFFA98	B010240F		 	beqi	r1,#15,irqKeybd
FFFFFFFFFFFFFA9C	B0102601		 	beqi	r1,#1,irqColdStart		; CTRL-ALT-DEL interrupt
                  	           		 
                  	           		 ; Here, none of the hardware interrupts were active so
                  	           		 ; assume software context switch interrupt
                  	           		 ;
FFFFFFFFFFFFFAA0	460F1460		 	lw		sp,sp_save
FFFFFFFFFFFFFAA4	460F9468		 	lw		lr,lr_save
FFFFFFFFFFFFFAA8	460D1480		 	lw		r26,r26_save
FFFFFFFFFFFFFAAC	46009470		 	lw		r1,r1_save
FFFFFFFFFFFFFAB0	46011478		 	lw		r2,r2_save
FFFFFFFFFFFFFAB4	0000000F		 	iepp
FFFFFFFFFFFFFAB8	01900020		 	iret
                  	           		 	
                  	           		 ; 1000 Hz interrupt
                  	           		 ; This IRQ must be fast, so it's placed inline. It's also the first
                  	           		 ; IRQ checked for in the interrupt dispatch.
                  	           		 ; Increments the millisecond counter, and switches to the next context
                  	           		 ;
FFFFFFFFFFFFFABC	           		 irq1000Hz:
FFFFFFFFFFFFFABC	E69CFFFD		; SETLO
FFFFFFFFFFFFFAC0	EE800003		; SETMID
FFFFFFFFFFFFFAC4	6A0D0028		 	outb	r0,0xDCFFFD				; acknowledge interrupt
FFFFFFFFFFFFFAC8	46009400		 	lw		r1,Milliseconds			; increment milliseconds count
FFFFFFFFFFFFFACC	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFFAD0	66009400		 	sw		r1,Milliseconds
FFFFFFFFFFFFFAD4	460F1460		 	lw		sp,sp_save
FFFFFFFFFFFFFAD8	460F9468		 	lw		lr,lr_save
FFFFFFFFFFFFFADC	460D1480		 	lw		r26,r26_save
FFFFFFFFFFFFFAE0	46009470		 	lw		r1,r1_save
FFFFFFFFFFFFFAE4	46011478		 	lw		r2,r2_save
FFFFFFFFFFFFFAE8	0000000F		 	iepp							; move to the next context
FFFFFFFFFFFFFAEC	01900020		 	iret							; return to the next context
                  	           		 
                  	           		 ; 100 Hz interrupt
                  	           		 ; This IRQ could have some work to do, including flashing a cursor. So
                  	           		 ; we call a subroutine.
                  	           		 ;
FFFFFFFFFFFFFAF0	           		 irq100Hz:
FFFFFFFFFFFFFAF0	4600B000		 	lw		r1,p100IRQvec
                  	           		 ;	jal		lr,[r1]
FFFFFFFFFFFFFAF4	31FFEF73		 	call	Pulse100
FFFFFFFFFFFFFAF8	           		 irqret:
FFFFFFFFFFFFFAF8	460F1460		 	lw		sp,sp_save
FFFFFFFFFFFFFAFC	460F9468		 	lw		lr,lr_save
FFFFFFFFFFFFFB00	460D1480		 	lw		r26,r26_save
FFFFFFFFFFFFFB04	46009470		 	lw		r1,r1_save
FFFFFFFFFFFFFB08	46011478		 	lw		r2,r2_save
FFFFFFFFFFFFFB0C	01900020		 	iret
                  	           		 
FFFFFFFFFFFFFB10	           		 irqSerial:
FFFFFFFFFFFFFB10	4600B010		 	lw		r1,serialIRQvec
FFFFFFFFFFFFFB14	341F8000		 	jal		lr,[r1]
FFFFFFFFFFFFFB18	BE007F0A		 	bra		irqret
                  	           		 
FFFFFFFFFFFFFB1C	           		 irqRaster:
FFFFFFFFFFFFFB1C	4600B018		 	lw		r1,rasterIRQvec
                  	           		 ;	jal		lr,[r1]
FFFFFFFFFFFFFB20	31FFF46B		 	call	RasterIRQfn
FFFFFFFFFFFFFB24	BE007EAA		 	bra		irqret
                  	           		 
FFFFFFFFFFFFFB28	           		 irqKeybd:
FFFFFFFFFFFFFB28	4600B008		 	lw		r1,keybdIRQvec
FFFFFFFFFFFFFB2C	31FFEEF0		 	call	KeybdIRQ
                  	           		 ;	jal		lr,[r1]
FFFFFFFFFFFFFB30	BE007E4A		 	bra		irqret
                  	           		 
FFFFFFFFFFFFFB34	           		 irqColdStart:
FFFFFFFFFFFFFB34	33FFEC0B		 	jmp		ColdStart
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; NMI routine
                  	           		 ;
                  	           		 ; The NMI line is tied to the parity error signal. But also any non-initialized
                  	           		 ; interrupts get sent here.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFFB38	           		 nmirout:
FFFFFFFFFFFFFB38	660F1460		 	sw		sp,sp_save
FFFFFFFFFFFFFB3C	66009470		 	sw		r1,r1_save
FFFFFFFFFFFFFB40	660D1480		 	sw		r26,r26_save
FFFFFFFFFFFFFB44	E6801000		; SETLO
FFFFFFFFFFFFFB48	EE800400		; SETMID
FFFFFFFFFFFFFB4C	040D7809		 	lw		sp,#0x100001000
FFFFFFFFFFFFFB50	E69CFFFE		; SETLO
FFFFFFFFFFFFFB54	EE800003		; SETMID
FFFFFFFFFFFFFB58	6A0D0028		 	outb	r0,0xDCFFFE		; acknowledge interrupt
FFFFFFFFFFFFFB5C	9A00FB80		 	lea		r1,msgPerr
FFFFFFFFFFFFFB60	31FFF122		 	call	DisplayString
FFFFFFFFFFFFFB64	02008868		 	mfspr	r1,IPC
FFFFFFFFFFFFFB68	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFFB6C	31FFFD80		 	call	CRLF
FFFFFFFFFFFFFB70	460F1460		 	lw		sp,sp_save
FFFFFFFFFFFFFB74	46009470		 	lw		r1,r1_save
FFFFFFFFFFFFFB78	460D1480		 	lw		r26,r26_save
FFFFFFFFFFFFFB7C	01900020		 	iret
                  	           		 
FFFFFFFFFFFFFB80	           		 msgPerr:
FFFFFFFFFFFFFB80 6520797469726150	 	db	"Parity error at: ",0
FFFFFFFFFFFFFB88 3A746120726F7272
                  	           		 
                  	           		 
                  	           		 ;-------------------------------------------
                  	           		 ; Unimplemented instructions end up here
                  	           		 ;-------------------------------------------
FFFFFFFFFFFFFB94	           		 	.align 4
FFFFFFFFFFFFFB94	           		 ui_irout:
FFFFFFFFFFFFFB94	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFFB98	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFFB9C	9A00FBC0		 	lea		r1,msgUnimp
FFFFFFFFFFFFFBA0	31FFF122		 	call	DisplayString
FFFFFFFFFFFFFBA4	02008868		 	mfspr	r1,IPC
FFFFFFFFFFFFFBA8	31FFF169		 	call	DisplayWord
FFFFFFFFFFFFFBAC	31FFFD80		 	call	CRLF
FFFFFFFFFFFFFBB0	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFFBB4	0BEF0008		 	addui	sp,sp,#8
                  	           		 	; hang the context
FFFFFFFFFFFFFBB8	           		 ui_irout1:
FFFFFFFFFFFFFBB8	BE00000A		 	bra		ui_irout1
FFFFFFFFFFFFFBBC	01900020		 	iret
                  	           		 
FFFFFFFFFFFFFBC0	           		 msgUnimp:
FFFFFFFFFFFFFBC0 6D656C706D696E55	 	db	"Unimplemented instruction at: ",0
FFFFFFFFFFFFFBC8 6E69206465746E65
FFFFFFFFFFFFFBD0 6F69746375727473
                  	           		 
                  	           		 ;-------------------------------------------
                  	           		 ; Handle miss on Data TLB
                  	           		 ;-------------------------------------------
FFFFFFFFFFFFFBD8 0000203A7461206E	 	.align	4
FFFFFFFFFFFFFBE0	           		 	.align	4
FFFFFFFFFFFFFBE0	           		 DTLBHandler:
FFFFFFFFFFFFFBE0	E6BF0000		; SETLO
FFFFFFFFFFFFFBE4	6A0D0413		 	sw		r1,0xFFFF_FFFF_FFFF_0000
FFFFFFFFFFFFFBE8	E6BF0008		; SETLO
FFFFFFFFFFFFFBEC	6A0D0813		 	sw		r2,0xFFFF_FFFF_FFFF_0008
FFFFFFFFFFFFFBF0	           		 dh1:
FFFFFFFFFFFFFBF0	02008034		 	omgi	r1,#0		; try open mutex gate #0 (TLB protector)
FFFFFFFFFFFFFBF4	BE107FE9		 	bne		r1,r0,dh1	; spinlock if gate is closed
FFFFFFFFFFFFFBF8	02008128		 	mfspr	r1,PTA		; get the page table address
FFFFFFFFFFFFFBFC	02010228		 	mfspr	r2,BadVAddr	; get the bad virtual address
FFFFFFFFFFFFFC00	022002E9		 	mtspr	TLBVirtPage,r2	; which virtual address to update
FFFFFFFFFFFFFC04	06211A01		 	shrui	r2,r2,#13	; turn va into index
FFFFFFFFFFFFFC08	04110403		 	addu	r1,r1,r2
FFFFFFFFFFFFFC0C	46110000		 	lw		r2,[r1]		; get the physical address from the table
FFFFFFFFFFFFFC10	14210000		 	and		r2,r2,#FFFF_FFFF_FFFF_E000	; mask off lower bits
FFFFFFFFFFFFFC14	022002A9		 	mtspr	TLBPhysPage0,r2	;
FFFFFFFFFFFFFC18	46110008		 	lw		r2,8[r1]	; get the physical address from the table
FFFFFFFFFFFFFC1C	14210000		 	and		r2,r2,#FFFF_FFFF_FFFF_E000	; mask off lower bits
FFFFFFFFFFFFFC20	022002E9		 	mtspr	TLBPhysPage1,r2	;
FFFFFFFFFFFFFC24	02000034		 	tlbwr				; update a random entry in the TLB
FFFFFFFFFFFFFC28	02000035		 	cmgi	#0			; close the mutex gate
FFFFFFFFFFFFFC2C	E6BF0000		; SETLO
FFFFFFFFFFFFFC30	6A0D0403		 	lw		r1,0xFFFF_FFFF_FFFF_0000
FFFFFFFFFFFFFC34	E6BF0008		; SETLO
FFFFFFFFFFFFFC38	6A0D0803		 	lw		r2,0xFFFF_FFFF_FFFF_0008
FFFFFFFFFFFFFC3C	01900020		 	iret
FFFFFFFFFFFFFC40	           		 	.align	32
                  	           		 
FFFFFFFFFFFFFFB0	           		 	org		0xFFFF_FFFF_FFFF_FFB0
FFFFFFFFFFFFFFB0	33FFFEF8		 	jmp		DTLBHandler
FFFFFFFFFFFFFFB4	DE000000		 	nop
FFFFFFFFFFFFFFB8	DE000000		 	nop
FFFFFFFFFFFFFFC0	           		 	org		0xFFFF_FFFF_FFFF_FFC0
FFFFFFFFFFFFFFC0	33FFFEF8		 	jmp		DTLBHandler
FFFFFFFFFFFFFFC4	DE000000		 	nop
FFFFFFFFFFFFFFC8	DE000000		 	nop
                  	           		 
FFFFFFFFFFFFFFE0	           		 	org     0xFFFF_FFFF_FFFF_FFE0
FFFFFFFFFFFFFFE0 0000000000000000	 	dw		0		; 
FFFFFFFFFFFFFFE8 0000000000000000	 	dw		0		;
                  	           		 	
                  	           		 ; RST vector
FFFFFFFFFFFFFFF0	           		 	org		0xFFFF_FFFF_FFFF_FFF0
FFFFFFFFFFFFFFF0	33FFEC0B		 	jmp		start
                  	           		 
                  	           		 ; ROM checksum goes here
                  	           		 
FFFFFFFFFFFFFFF8	           		 	org		0xFFFF_FFFF_FFFF_FFF8
FFFFFFFFFFFFFFF8 0000000000000000	 	dw		0
                  	           		 
0000000000000000	00000000		 
0000000000000004	00000000		 
 
 
Symbol Table:
==========================================================
Name                   Typ  Segment     Address/Value
----------------------------------------------------------
CR                  	C	constant	000000000000000D
LF                  	C	constant	000000000000000A
TAB                 	C	constant	0000000000000009
CTRLC               	C	constant	0000000000000003
CTRLH               	C	constant	0000000000000008
CTRLI               	C	constant	0000000000000009
CTRLJ               	C	constant	000000000000000A
CTRLK               	C	constant	000000000000000B
CTRLM               	C	constant	000000000000000D
CTRLS               	C	constant	0000000000000013
CTRLX               	C	constant	0000000000000018
XON                 	C	constant	0000000000000011
XOFF                	C	constant	0000000000000013
EX_IRQ              	C	constant	00000000000001C1
DATA_PRESENT        	C	constant	0000000000000001
XMIT_NOT_FULL       	C	constant	0000000000000020
BUFLEN              	C	constant	0000000000000050
STACKTOP0           	C	constant	FFFFFFFFFFFEFFF8
STACKTOP1           	C	constant	FFFFFFFFFFFEFBF8
STACKTOP2           	C	constant	FFFFFFFFFFFEF7F8
STACKTOP3           	C	constant	FFFFFFFFFFFEF3F8
STACKTOP4           	C	constant	FFFFFFFFFFFEEFF8
STACKTOP5           	C	constant	FFFFFFFFFFFEEBF8
STACKTOP6           	C	constant	FFFFFFFFFFFEE7F8
STACKTOP7           	C	constant	FFFFFFFFFFFEE3F8
STACKTOP8           	C	constant	FFFFFFFFFFFEDFF8
STACKTOP9           	C	constant	FFFFFFFFFFFEDBF8
STACKTOP10          	C	constant	FFFFFFFFFFFED7F8
STACKTOP11          	C	constant	FFFFFFFFFFFED3F8
STACKTOP12          	C	constant	FFFFFFFFFFFECFF8
STACKTOP13          	C	constant	FFFFFFFFFFFECBF8
STACKTOP14          	C	constant	FFFFFFFFFFFEC7F8
STACKTOP15          	C	constant	FFFFFFFFFFFEC3F8
TCBSize             	C	constant	0000000000000200
TCBBase             	C	constant	0000000100000000
TCBr1               	C	constant	0000000000000000
TCBr2               	C	constant	0000000000000008
TCBr3               	C	constant	0000000000000010
TCBr4               	C	constant	0000000000000018
TCBr5               	C	constant	0000000000000020
TCBr6               	C	constant	0000000000000028
TCBr7               	C	constant	0000000000000030
TCBr8               	C	constant	0000000000000038
TCBr9               	C	constant	0000000000000040
TCBr10              	C	constant	0000000000000048
TCBr11              	C	constant	0000000000000050
TCBr12              	C	constant	0000000000000058
TCBr13              	C	constant	0000000000000060
TCBr14              	C	constant	0000000000000068
TCBr15              	C	constant	0000000000000070
TCBr16              	C	constant	0000000000000078
TCBr17              	C	constant	0000000000000080
TCBr18              	C	constant	0000000000000088
TCBr19              	C	constant	0000000000000090
TCBr20              	C	constant	0000000000000098
TCBr21              	C	constant	00000000000000A0
TCBr22              	C	constant	00000000000000A8
TCBr23              	C	constant	00000000000000B0
TCBr24              	C	constant	00000000000000B8
TCBr25              	C	constant	00000000000000C0
TCBr26              	C	constant	00000000000000C8
TCBr27              	C	constant	00000000000000D0
TCBr28              	C	constant	00000000000000D8
TCBr29              	C	constant	00000000000000E0
TCBr30              	C	constant	00000000000000E8
TCBr31              	C	constant	00000000000000F0
SCREENGATE          	C	constant	0000000000000000
KEYBDGATE           	C	constant	0000000000000001
VIDEOGATE           	C	constant	0000000000000002
CARDGATE            	C	constant	0000000000000003
warmStart           	C	constant	0000000000001020
usrJmp              	C	constant	0000000000001028
TickIRQAddr         	C	constant	0000000000001030
TaskBlock           	C	constant	0000000000001038
Milliseconds        	C	constant	0000000000001400
Lastloc             	C	constant	0000000000001408
CharColor           	C	constant	0000000000001410
ScreenColor         	C	constant	0000000000001414
CursorRow           	C	constant	0000000000001417
CursorCol           	C	constant	0000000000001418
CursorFlash         	C	constant	000000000000141A
KeybdEcho           	C	constant	000000000000141C
KeybdBuffer         	C	constant	0000000000001440
KeybdHead           	C	constant	0000000000001450
KeybdTail           	C	constant	0000000000001451
sp_save             	C	constant	0000000000001460
lr_save             	C	constant	0000000000001468
r1_save             	C	constant	0000000000001470
r2_save             	C	constant	0000000000001478
r26_save            	C	constant	0000000000001480
Score               	C	constant	0000000000001500
Manpos              	C	constant	0000000000001508
MissileActive       	C	constant	0000000000001510
MissileX            	C	constant	0000000000001512
MissileY            	C	constant	0000000000001514
InvadersRow1        	C	constant	0000000000001520
InvadersRow2        	C	constant	0000000000001530
InvadersRow3        	C	constant	0000000000001540
InvadersRow4        	C	constant	0000000000001550
InvadersRow5        	C	constant	0000000000001560
InvadersColpos      	C	constant	0000000000001570
InvadersRowpos      	C	constant	0000000000001571
Uart_rxfifo         	C	constant	0000000000001600
Uart_rxhead         	C	constant	0000000000001800
Uart_rxtail         	C	constant	0000000000001802
Uart_ms             	C	constant	0000000000001808
Uart_rxrts          	C	constant	0000000000001809
Uart_rxdtr          	C	constant	000000000000180A
Uart_rxxon          	C	constant	000000000000180B
Uart_rxflow         	C	constant	000000000000180C
Uart_fon            	C	constant	000000000000180E
Uart_foff           	C	constant	0000000000001810
Uart_txrts          	C	constant	0000000000001812
Uart_txdtr          	C	constant	0000000000001813
Uart_txxon          	C	constant	0000000000001814
Uart_txxonoff       	C	constant	0000000000001815
TaskList            	C	constant	0000000000002000
ReadyList1          	C	constant	0000000000002000
ReadyList2          	C	constant	0000000000002020
ReadyList3          	C	constant	0000000000002040
ReadyList4          	C	constant	0000000000002060
ReadyList5          	C	constant	0000000000002080
ReadyNdx1           	C	constant	00000000000020A0
ReadyNdx2           	C	constant	00000000000020A1
ReadyNdx3           	C	constant	00000000000020A2
ReadyNdx4           	C	constant	00000000000020A3
ReadyNdx5           	C	constant	00000000000020A4
RunningTCB          	C	constant	00000000000020A6
NextToRunTCB        	C	constant	00000000000020A8
r1save              	C	constant	00000000000020B0
r2save              	C	constant	00000000000020B8
AXCstart            	C	constant	00000000000020C0
ctx0start           	C	constant	00000000000020D0
ctx1start           	C	constant	00000000000020D8
ctx2start           	C	constant	00000000000020E0
ctx3start           	C	constant	00000000000020E8
ctx4start           	C	constant	00000000000020F0
ctx5start           	C	constant	00000000000020F8
ctx6start           	C	constant	0000000000002100
ctx7start           	C	constant	0000000000002108
ctx8start           	C	constant	0000000000002110
ctx9start           	C	constant	0000000000002118
ctx10start          	C	constant	0000000000002120
ctx11start          	C	constant	0000000000002128
ctx12start          	C	constant	0000000000002130
ctx13start          	C	constant	0000000000002138
ctx14start          	C	constant	0000000000002140
ctx15start          	C	constant	0000000000002148
sp_saves            	C	constant	0000000000002200
sp_saves_end        	C	constant	0000000000002280
p100IRQvec          	C	constant	0000000000003000
keybdIRQvec         	C	constant	0000000000003008
serialIRQvec        	C	constant	0000000000003010
rasterIRQvec        	C	constant	0000000000003018
startSector         	C	constant	00000000000030F8
BPB                 	C	constant	0000000000003100
TEXTSCR             	C	constant	0000000000D00000
COLORSCR            	C	constant	0000000000D10000
TEXTREG             	C	constant	0000000000DA0000
TEXT_COLS           	C	constant	0000000000000000
TEXT_ROWS           	C	constant	0000000000000002
TEXT_CURPOS         	C	constant	0000000000000016
KEYBD               	C	constant	0000000000DC0000
KEYBDCLR            	C	constant	0000000000DC0002
UART                	C	constant	0000000000DC0A00
UART_LS             	C	constant	0000000000DC0A01
UART_IS             	C	constant	0000000000DC0A03
UART_IE             	C	constant	0000000000DC0A04
UART_MC             	C	constant	0000000000DC0A06
DATETIME            	C	constant	0000000000DC0400
SPIMASTER           	C	constant	0000000000DC0500
SPI_MASTER_VERSION_REG	C	constant	0000000000000000
SPI_MASTER_CONTROL_REG	C	constant	0000000000000001
SPI_TRANS_TYPE_REG  	C	constant	0000000000000002
SPI_TRANS_CTRL_REG  	C	constant	0000000000000003
SPI_TRANS_STATUS_REG	C	constant	0000000000000004
SPI_TRANS_ERROR_REG 	C	constant	0000000000000005
SPI_DIRECT_ACCESS_DATA_REG	C	constant	0000000000000006
SPI_SD_ADDR_7_0_REG 	C	constant	0000000000000007
SPI_SD_ADDR_15_8_REG	C	constant	0000000000000008
SPI_SD_ADDR_23_16_REG	C	constant	0000000000000009
SPI_SD_ADDR_31_24_REG	C	constant	000000000000000A
SPI_RX_FIFO_DATA_REG	C	constant	0000000000000010
SPI_RX_FIFO_DATA_COUNT_MSB	C	constant	0000000000000012
SPI_RX_FIFO_DATA_COUNT_LSB	C	constant	0000000000000013
SPI_RX_FIFO_CTRL_REG	C	constant	0000000000000014
SPI_TX_FIFO_DATA_REG	C	constant	0000000000000020
SPI_TX_FIFO_CTRL_REG	C	constant	0000000000000024
SPI_INIT_SD         	C	constant	0000000000000001
SPI_TRANS_START     	C	constant	0000000000000001
SPI_TRANS_BUSY      	C	constant	0000000000000001
SPI_INIT_NO_ERROR   	C	constant	0000000000000000
SPI_READ_NO_ERROR   	C	constant	0000000000000000
RW_READ_SD_BLOCK    	C	constant	0000000000000002
RW_WRITE_SD_BLOCK   	C	constant	0000000000000003
PIC                 	C	constant	0000000000DC0FF0
PIC_IE              	C	constant	0000000000DC0FF2
PSG                 	C	constant	0000000000D50000
PSGFREQ0            	C	constant	0000000000D50000
PSGPW0              	C	constant	0000000000D50002
PSGCTRL0            	C	constant	0000000000D50004
PSGADSR0            	C	constant	0000000000D50006
SPRRAM              	C	constant	0000000000D80000
AC97                	C	constant	0000000000DC1000
TMP                 	C	constant	0000000000DC0300
LED                 	C	constant	0000000000DC0600
ETHMAC              	C	constant	0000000000DC2000
CONFIGREC           	C	constant	0000000000DCFFFF
MIIMODER            	C	constant	0000000000000028
MIIADDRESS          	C	constant	0000000000000030
GACCEL              	C	constant	0000000000DAE000
RASTERIRQ           	C	constant	0000000000DA0100
BOOT_STACK          	C	constant	FFFFFFFFFFFEFFF8
SPRITEREGS          	C	constant	0000000000DAD000
BITMAPSCR           	C	constant	0000000100200000
BOOTJMP             	C	constant	0000000100800204
txempty             	C	constant	0000000000000040
rxfull              	C	constant	0000000000000001
txtWidth            	L	bss     	0000000000001048
txtHeight           	L	bss     	0000000000001049
cursx               	L	bss     	000000000000104A
cursy               	L	bss     	000000000000104B
pos                 	L	bss     	000000000000104C
dh                  	L	bss     	000000000000104C
0                   	L	bss     	000000000000104C
charToPrint         	L	bss     	000000000000104C
fgColor             	L	bss     	000000000000104E
bkColor             	L	bss     	0000000000001051
cursFlash           	L	bss     	0000000000001052
lineLinkTbl         	L	bss     	0000000000001053
typef               	L	bss     	0000000000001085
OSSP                	L	bss     	0000000000001088
CURRNT              	L	bss     	0000000000001090
STKGOS              	L	bss     	0000000000001098
STKINP              	L	bss     	00000000000010A0
LOPVAR              	L	bss     	00000000000010A8
LOPINC              	L	bss     	00000000000010B0
LOPLMT              	L	bss     	00000000000010B8
LOPLN               	L	bss     	00000000000010C0
LOPPT               	L	bss     	00000000000010C8
TXTUNF              	L	bss     	00000000000010D0
VARBGN              	L	bss     	00000000000010D8
IVARBGN             	L	bss     	00000000000010E0
SVARBGN             	L	bss     	00000000000010E8
FVARBGN             	L	bss     	00000000000010F0
STKBOT              	L	bss     	00000000000010F8
NUMWKA              	L	bss     	0000000000001100
BUFFER              	L	bss     	000000000000111B
TXT                 	C	constant	0000000100600000
start               	L	code    	FFFFFFFFFFFFB02C
ColdStart           	L	code    	FFFFFFFFFFFFB02C
ict1                	L	code    	FFFFFFFFFFFFB084
ctxstart3           	L	code    	FFFFFFFFFFFFB214
ctxstart2           	L	code    	FFFFFFFFFFFFB224
ctxstart            	L	code    	FFFFFFFFFFFFB228
ctxstart1           	L	code    	FFFFFFFFFFFFB3FC
csj5                	L	code    	FFFFFFFFFFFFB240
skip5               	L	code    	FFFFFFFFFFFFB2E4
skip4               	L	code    	FFFFFFFFFFFFB2FC
dcokay              	L	code    	FFFFFFFFFFFFB330
skip1               	L	code    	FFFFFFFFFFFFB368
skip2               	L	code    	FFFFFFFFFFFFB3B0
skip3               	L	code    	FFFFFFFFFFFFB3D8
skip_spi_read       	L	code    	FFFFFFFFFFFFB3F0
j4                  	L	code    	FFFFFFFFFFFFB3F4
ctx12               	L	code    	FFFFFFFFFFFFB410
context1disp        	L	code    	FFFFFFFFFFFFB428
ctx11               	L	code    	FFFFFFFFFFFFB448
HelloWorld          	L	code    	FFFFFFFFFFFFB460
j3                  	L	code    	FFFFFFFFFFFFB478
j2                  	L	code    	FFFFFFFFFFFFB48C
MSG                 	L	code    	FFFFFFFFFFFFB4A0
MSGSTART            	L	code    	FFFFFFFFFFFFB4AD
PICInit             	L	code    	FFFFFFFFFFFFB4D0
PICret              	L	code    	FFFFFFFFFFFFB4EC
SerialInit          	L	code    	FFFFFFFFFFFFB4F0
SerialGetCharDirect 	L	code    	FFFFFFFFFFFFB534
sgc1                	L	code    	FFFFFFFFFFFFCDC0
SerialCheckForCharDirect	L	code    	FFFFFFFFFFFFB558
SerialPutChar       	L	code    	FFFFFFFFFFFFB570
spcb1               	L	code    	FFFFFFFFFFFFB5D0
spcb3               	L	code    	FFFFFFFFFFFFB5B0
spcabort            	L	code    	FFFFFFFFFFFFB658
spcb2               	L	code    	FFFFFFFFFFFFB600
spcb4               	L	code    	FFFFFFFFFFFFB5E0
spcb5               	L	code    	FFFFFFFFFFFFB61C
spcb6               	L	code    	FFFFFFFFFFFFB608
spcb8               	L	code    	FFFFFFFFFFFFB624
spcb7               	L	code    	FFFFFFFFFFFFB64C
CharsInRxBuf        	L	code    	FFFFFFFFFFFFB66C
cirxb1              	L	code    	FFFFFFFFFFFFB68C
SerialGetChar       	L	code    	FFFFFFFFFFFFB690
sgcfifo1            	L	code    	FFFFFFFFFFFFB750
sgcfifo2            	L	code    	FFFFFFFFFFFFB73C
sgcfifo3            	L	code    	FFFFFFFFFFFFB700
sgcfifo4            	L	code    	FFFFFFFFFFFFB724
sgcfifo5            	L	code    	FFFFFFFFFFFFB73C
SerialIRQ           	L	code    	FFFFFFFFFFFFB768
sirq1               	L	code    	FFFFFFFFFFFFB7A0
srxirq              	L	code    	FFFFFFFFFFFFB7C8
stxirq              	L	code    	FFFFFFFFFFFFB7C4
smsirq              	L	code    	FFFFFFFFFFFFB7B8
srxirq1             	L	code    	FFFFFFFFFFFFB7C8
srxirq3             	L	code    	FFFFFFFFFFFFB7F8
srxirq2             	L	code    	FFFFFFFFFFFFB7EC
srxirq5             	L	code    	FFFFFFFFFFFFB814
srxirq8             	L	code    	FFFFFFFFFFFFB8A4
srxirq6             	L	code    	FFFFFFFFFFFFB868
srxirq7             	L	code    	FFFFFFFFFFFFB88C
VideoSC             	L	code    	FFFFFFFFFFFFB8A8
Video1              	L	code    	FFFFFFFFFFFFB8D0
Video_x02           	L	code    	FFFFFFFFFFFFB90C
Video_x03           	L	code    	FFFFFFFFFFFFB91C
Video_x06           	L	code    	FFFFFFFFFFFFB928
Video_x09           	L	code    	FFFFFFFFFFFFB930
Video_x0A           	L	code    	FFFFFFFFFFFFB944
Video_x0C           	L	code    	FFFFFFFFFFFFB954
Video_x0D           	L	code    	FFFFFFFFFFFFB98C
Video_x14           	L	code    	FFFFFFFFFFFFB9E0
Video_x15           	L	code    	FFFFFFFFFFFFB9EC
Video_x16           	L	code    	FFFFFFFFFFFFB9FC
Video_x17           	L	code    	FFFFFFFFFFFFBA08
Video_x1A           	L	code    	FFFFFFFFFFFFBA14
VideoRet            	L	code    	FFFFFFFFFFFFBA20
Video_x09a          	L	code    	FFFFFFFFFFFFB938
Video_x0Aa          	L	code    	FFFFFFFFFFFFB948
vxd1                	L	code    	FFFFFFFFFFFFB9C0
SDCARDSC            	L	code    	FFFFFFFFFFFFBA38
SDC_1               	L	code    	FFFFFFFFFFFFBA60
SDC_x00             	L	code    	FFFFFFFFFFFFBA78
SDC_x01             	L	code    	FFFFFFFFFFFFBA80
SDC_x02             	L	code    	FFFFFFFFFFFFBA90
SDCRet              	L	code    	FFFFFFFFFFFFBA90
RTCSC               	L	code    	FFFFFFFFFFFFBAA8
RTC_x00             	L	code    	FFFFFFFFFFFFBAD8
RTC_x01             	L	code    	FFFFFFFFFFFFBAE0
RTCRet              	L	code    	FFFFFFFFFFFFBB00
KeybdSC             	L	code    	FFFFFFFFFFFFBB14
kbdsc5              	L	code    	FFFFFFFFFFFFBB3C
kbd_x00             	L	code    	FFFFFFFFFFFFBB60
kbd_x01             	L	code    	FFFFFFFFFFFFBB68
kbd_x02             	L	code    	FFFFFFFFFFFFBB74
kbd_x03             	L	code    	FFFFFFFFFFFFBB7C
kbd_x04             	L	code    	FFFFFFFFFFFFBB84
kbd_x05             	L	code    	FFFFFFFFFFFFBB8C
kbdscRet            	L	code    	FFFFFFFFFFFFBB94
KeybdInit           	L	code    	FFFFFFFFFFFFBBAC
KeybdIRQ            	L	code    	FFFFFFFFFFFFBBC0
KeybdIRQa           	L	code    	FFFFFFFFFFFFBBD0
KeybdIRQb           	L	code    	FFFFFFFFFFFFBBF8
KeybdIRQc           	L	code    	FFFFFFFFFFFFBC0C
SetKeyboardEcho     	L	code    	FFFFFFFFFFFFBC14
KeybdGetChar        	L	code    	FFFFFFFFFFFFBC1C
nochar              	L	code    	FFFFFFFFFFFFBC60
kgc3                	L	code    	FFFFFFFFFFFFBC64
kgc2                	L	code    	FFFFFFFFFFFFBC58
KeybdCheckForKey    	L	code    	FFFFFFFFFFFFBC70
KeybdCheckForKeyDirect	L	code    	FFFFFFFFFFFFBC80
KeybdGetCharDirect  	L	code    	FFFFFFFFFFFFBC94
kgc1                	L	code    	FFFFFFFFFFFFBCA4
gk1                 	L	code    	FFFFFFFFFFFFBCDC
gk2                 	L	code    	FFFFFFFFFFFFBCD8
tmp_init            	L	code    	FFFFFFFFFFFFBCE8
tmp_init4           	L	code    	FFFFFFFFFFFFBCF4
tmp_init5           	L	code    	FFFFFFFFFFFFBD0C
tmp_init1           	L	code    	FFFFFFFFFFFFBD20
tmp_init2           	L	code    	FFFFFFFFFFFFBD30
tmp_init3           	L	code    	FFFFFFFFFFFFBD48
tmp_read            	L	code    	FFFFFFFFFFFFBD4C
tmp_read1           	L	code    	FFFFFFFFFFFFBD68
tmp_read3           	L	code    	FFFFFFFFFFFFBD80
tmp_read2           	L	code    	FFFFFFFFFFFFBD90
tmp_read4           	L	code    	FFFFFFFFFFFFBDA8
Pulse100            	L	code    	FFFFFFFFFFFFBDCC
p1001               	L	code    	FFFFFFFFFFFFBE00
SelectNextToRunTCB  	L	code    	FFFFFFFFFFFFBE08
SwitchTask          	L	code    	FFFFFFFFFFFFBE10
swtsk1              	L	code    	FFFFFFFFFFFFBE30
FlashCursor         	L	code    	FFFFFFFFFFFFBF60
flshcrsr2           	L	code    	FFFFFFFFFFFFBFBC
flshcrsr3           	L	code    	FFFFFFFFFFFFBF94
flshcrsr1           	L	code    	FFFFFFFFFFFFBFA8
CursorOff           	L	code    	FFFFFFFFFFFFBFC8
CursorOn            	L	code    	FFFFFFFFFFFFBFDC
ClearBmpScreen      	L	code    	FFFFFFFFFFFFBFF0
csj4                	L	code    	FFFFFFFFFFFFC08C
ClearScreen         	L	code    	FFFFFFFFFFFFC044
ScrollUp            	L	code    	FFFFFFFFFFFFC0B8
scrup1              	L	code    	FFFFFFFFFFFFC0F8
BlankLine           	L	code    	FFFFFFFFFFFFC138
blnkln1             	L	code    	FFFFFFFFFFFFC170
AsciiToScreen       	L	code    	FFFFFFFFFFFFC18C
atoscr1             	L	code    	FFFFFFFFFFFFC1A4
ScreenToAscii       	L	code    	FFFFFFFFFFFFC1AC
stasc1              	L	code    	FFFFFFFFFFFFC1B8
CalcScreenLoc       	L	code    	FFFFFFFFFFFFC1BC
DisplayChar         	L	code    	FFFFFFFFFFFFC1FC
dccr                	L	code    	FFFFFFFFFFFFC21C
dcx7                	L	code    	FFFFFFFFFFFFC248
dcx6                	L	code    	FFFFFFFFFFFFC260
dccr1               	L	code    	FFFFFFFFFFFFC224
dcx8                	L	code    	FFFFFFFFFFFFC290
dccu1               	L	code    	FFFFFFFFFFFFC268
dcx9                	L	code    	FFFFFFFFFFFFC2C0
dccl1               	L	code    	FFFFFFFFFFFFC298
dcx10               	L	code    	FFFFFFFFFFFFC2F0
dccd1               	L	code    	FFFFFFFFFFFFC2C8
dcx11               	L	code    	FFFFFFFFFFFFC324
dcx12               	L	code    	FFFFFFFFFFFFC31C
dcx13               	L	code    	FFFFFFFFFFFFC358
dcx5                	L	code    	FFFFFFFFFFFFC378
dcx3                	L	code    	FFFFFFFFFFFFC3AC
dcx4                	L	code    	FFFFFFFFFFFFC3E0
dclf                	L	code    	FFFFFFFFFFFFC3DC
IncCursorPos        	L	code    	FFFFFFFFFFFFC3FC
icc1                	L	code    	FFFFFFFFFFFFC470
icr1                	L	code    	FFFFFFFFFFFFC448
IncCursorRow        	L	code    	FFFFFFFFFFFFC434
DisplayString       	L	code    	FFFFFFFFFFFFC488
dspj1               	L	code    	FFFFFFFFFFFFC49C
dsret               	L	code    	FFFFFFFFFFFFC4B0
DisplayStringCRLF   	L	code    	FFFFFFFFFFFFC4C0
CRLF                	L	code    	FFFFFFFFFFFFF600
DisplayNum          	L	code    	FFFFFFFFFFFFC4FC
DisplayNybble       	L	code    	FFFFFFFFFFFFC500
dispnyb1            	L	code    	FFFFFFFFFFFFC51C
DisplayByte         	L	code    	FFFFFFFFFFFFC52C
DisplayCharr        	L	code    	FFFFFFFFFFFFC554
DisplayHalf         	L	code    	FFFFFFFFFFFFC57C
DisplayWord         	L	code    	FFFFFFFFFFFFC5A4
dspwd1              	L	code    	FFFFFFFFFFFFC5B8
DisplayMemB         	L	code    	FFFFFFFFFFFFC5D4
dspmem1             	L	code    	FFFFFFFFFFFFC5F8
DisplayMemC         	L	code    	FFFFFFFFFFFFC624
dspmemc1            	L	code    	FFFFFFFFFFFFC648
DisplayMemW         	L	code    	FFFFFFFFFFFFC674
BinToBCD            	L	code    	FFFFFFFFFFFFC6B4
bta1                	L	code    	FFFFFFFFFFFFC6D8
BCDToAscii          	L	code    	FFFFFFFFFFFFC730
bta2                	L	code    	FFFFFFFFFFFFC748
BinToStr            	L	code    	FFFFFFFFFFFFC78C
btos3               	L	code    	FFFFFFFFFFFFC7C0
btos1               	L	code    	FFFFFFFFFFFFC7C4
btos2               	L	code    	FFFFFFFFFFFFC7F4
Monitor             	L	code    	FFFFFFFFFFFFC828
PromptLn            	L	code    	FFFFFFFFFFFFC834
Prompt3             	L	code    	FFFFFFFFFFFFC840
Prompt1             	L	code    	FFFFFFFFFFFFC854
Prompt2             	L	code    	FFFFFFFFFFFFC87C
Editmem             	L	code    	FFFFFFFFFFFFCA24
Dumpmem             	L	code    	FFFFFFFFFFFFCA70
Fillmem             	L	code    	FFFFFFFFFFFFCAD4
Prompt7             	L	code    	FFFFFFFFFFFFC888
Prompt4             	L	code    	FFFFFFFFFFFFC890
ExecuteCode         	L	code    	FFFFFFFFFFFFCA4C
Prompt9             	L	code    	FFFFFFFFFFFFC89C
Prompt10            	L	code    	FFFFFFFFFFFFC8AC
TestCLS             	L	code    	FFFFFFFFFFFFC8DC
Prompt12            	L	code    	FFFFFFFFFFFFC8B8
Prompt13            	L	code    	FFFFFFFFFFFFC8C0
Prompt14            	L	code    	FFFFFFFFFFFFC8C8
Prompt15            	L	code    	FFFFFFFFFFFFC8D0
RandomLinesCall     	L	code    	FFFFFFFFFFFFC8D4
HelpMsg             	L	code    	FFFFFFFFFFFFC910
ignBlanks           	L	code    	FFFFFFFFFFFFCA00
ignBlanks1          	L	code    	FFFFFFFFFFFFCA08
edtmem1             	L	code    	FFFFFFFFFFFFCA34
LoadSector          	L	code    	FFFFFFFFFFFFCA5C
Dumpmem2            	L	code    	FFFFFFFFFFFFCAA0
DumpmemW            	L	code    	FFFFFFFFFFFFCAC4
DumpmemC            	L	code    	FFFFFFFFFFFFCAB8
DumpmemB            	L	code    	FFFFFFFFFFFFCAAC
FillmemC            	L	code    	FFFFFFFFFFFFCB20
FillmemH            	L	code    	FFFFFFFFFFFFCB30
FillmemW            	L	code    	FFFFFFFFFFFFCB40
FillmemB            	L	code    	FFFFFFFFFFFFCB10
GetHexNumber        	L	code    	FFFFFFFFFFFFCB50
gthxn2              	L	code    	FFFFFFFFFFFFCB68
gthxn1              	L	code    	FFFFFFFFFFFFCB8C
AsciiToHexNybble    	L	code    	FFFFFFFFFFFFCBA0
gthx3               	L	code    	FFFFFFFFFFFFCBD8
gthx5               	L	code    	FFFFFFFFFFFFCBB0
gthx6               	L	code    	FFFFFFFFFFFFCBC4
LoadS19             	L	code    	FFFFFFFFFFFFCBE0
ProcessRec          	L	code    	FFFFFFFFFFFFCBEC
NextRec             	L	code    	FFFFFFFFFFFFCBE4
ProcessS1           	L	code    	FFFFFFFFFFFFCCA4
ProcessS2           	L	code    	FFFFFFFFFFFFCCAC
ProcessS3           	L	code    	FFFFFFFFFFFFCCB4
ProcessS7           	L	code    	FFFFFFFFFFFFCCBC
ProcessS8           	L	code    	FFFFFFFFFFFFCCC8
ProcessS9           	L	code    	FFFFFFFFFFFFCCD4
pcssxa              	L	code    	FFFFFFFFFFFFCC4C
pcss1a              	L	code    	FFFFFFFFFFFFCC54
S19Get16BitAddress  	L	code    	FFFFFFFFFFFFCCE0
S1932b              	L	code    	FFFFFFFFFFFFCD64
S19Get24BitAddress  	L	code    	FFFFFFFFFFFFCCF8
S1932a              	L	code    	FFFFFFFFFFFFCD44
S19Get32BitAddress  	L	code    	FFFFFFFFFFFFCD10
sGetChar            	L	code    	FFFFFFFFFFFFCDA8
sgc2                	L	code    	FFFFFFFFFFFFCDB0
RandomLines         	L	code    	FFFFFFFFFFFFCDD0
rl5                 	L	code    	FFFFFFFFFFFFCDE4
rl1                 	L	code    	FFFFFFFFFFFFCDF8
rl2                 	L	code    	FFFFFFFFFFFFCE14
rl3                 	L	code    	FFFFFFFFFFFFCE30
rl4                 	L	code    	FFFFFFFFFFFFCE4C
rl8                 	L	code    	FFFFFFFFFFFFCE78
rl7                 	L	code    	FFFFFFFFFFFFCE8C
RandomizeSprram     	L	code    	FFFFFFFFFFFFCE9C
rsr1                	L	code    	FFFFFFFFFFFFCEAC
SetupAC97           	L	code    	FFFFFFFFFFFFCEC4
sac974              	L	code    	FFFFFFFFFFFFCED0
sac971              	L	code    	FFFFFFFFFFFFCEDC
sac973              	L	code    	FFFFFFFFFFFFCF08
sac972              	L	code    	FFFFFFFFFFFFCF48
sac975              	L	code    	FFFFFFFFFFFFCF60
Beep                	L	code    	FFFFFFFFFFFFCF6C
beep1               	L	code    	FFFFFFFFFFFFCFE4
beep2               	L	code    	FFFFFFFFFFFFD014
Piano               	L	code    	FFFFFFFFFFFFD044
playnt              	L	code    	FFFFFFFFFFFFD054
playnt1a            	L	code    	FFFFFFFFFFFFD07C
playnt1b            	L	code    	FFFFFFFFFFFFD088
playnt1c            	L	code    	FFFFFFFFFFFFD094
playnt1d            	L	code    	FFFFFFFFFFFFD0A0
playnt1e            	L	code    	FFFFFFFFFFFFD0AC
playnt1f            	L	code    	FFFFFFFFFFFFD0B8
playnt1g            	L	code    	FFFFFFFFFFFFD0C4
Tone                	L	code    	FFFFFFFFFFFFD0D0
tone1               	L	code    	FFFFFFFFFFFFD110
tone2               	L	code    	FFFFFFFFFFFFD12C
SetupRasterIRQ      	L	code    	FFFFFFFFFFFFD14C
RasterIRQfn         	L	code    	FFFFFFFFFFFFD1AC
rirq1               	L	code    	FFFFFFFFFFFFD1DC
rirq2               	L	code    	FFFFFFFFFFFFD1DC
rirq3               	L	code    	FFFFFFFFFFFFD1DC
rirq4               	L	code    	FFFFFFFFFFFFD1DC
rirq5               	L	code    	FFFFFFFFFFFFD1DC
rirq6               	L	code    	FFFFFFFFFFFFD1DC
rirq7               	L	code    	FFFFFFFFFFFFD1DC
rirq8               	L	code    	FFFFFFFFFFFFD1DC
DisplayDatetime     	L	code    	FFFFFFFFFFFFD248
InitializeGame      	L	code    	FFFFFFFFFFFFD2C4
DrawScore           	L	code    	FFFFFFFFFFFFD2EC
DrawMissile         	L	code    	FFFFFFFFFFFFD31C
MissileOff          	L	code    	FFFFFFFFFFFFD378
DrawMan             	L	code    	FFFFFFFFFFFFD3A0
DrawInvader         	L	code    	FFFFFFFFFFFFD3EC
DrawInvaders        	L	code    	FFFFFFFFFFFFD40C
dinv1               	L	code    	FFFFFFFFFFFFD494
DrawBombs           	L	code    	FFFFFFFFFFFFD49C
Invaders            	L	code    	FFFFFFFFFFFFD4A0
InvadersLoop        	L	code    	FFFFFFFFFFFFD4AC
TestMoveMan         	L	code    	FFFFFFFFFFFFD4C0
MoveManRight        	L	code    	FFFFFFFFFFFFD4D4
MoveManLeft         	L	code    	FFFFFFFFFFFFD4EC
FireMissile         	L	code    	FFFFFFFFFFFFD500
Invaders1           	L	code    	FFFFFFFFFFFFD524
InvadersEnd         	L	code    	FFFFFFFFFFFFD52C
spi_init            	L	code    	FFFFFFFFFFFFD538
spi_init1           	L	code    	FFFFFFFFFFFFD568
spi_error           	L	code    	FFFFFFFFFFFFD594
spi_init_exit       	L	code    	FFFFFFFFFFFFD5A4
spi_read_sector     	L	code    	FFFFFFFFFFFFD5B4
spi_read_sect1      	L	code    	FFFFFFFFFFFFD614
spi_read_error      	L	code    	FFFFFFFFFFFFD64C
spi_read_sect2      	L	code    	FFFFFFFFFFFFD634
spi_read_ret        	L	code    	FFFFFFFFFFFFD65C
spi_read_boot       	L	code    	FFFFFFFFFFFFD674
spi_read_boot1      	L	code    	FFFFFFFFFFFFD694
spi_read_boot2      	L	code    	FFFFFFFFFFFFD6DC
spi_read_boot3      	L	code    	FFFFFFFFFFFFD6D0
spi_read_boot4      	L	code    	FFFFFFFFFFFFD714
msgFoundEB          	L	code    	FFFFFFFFFFFFD728
loadFAT             	L	code    	FFFFFFFFFFFFD73C
loadFAT1            	L	code    	FFFFFFFFFFFFD780
loadRootDirectory   	L	code    	FFFFFFFFFFFFD79C
loadRootDir1        	L	code    	FFFFFFFFFFFFD800
loadBootFile        	L	code    	FFFFFFFFFFFFD814
loadBootFileTmp     	L	code    	FFFFFFFFFFFFD8A8
loadBootFile4       	L	code    	FFFFFFFFFFFFD870
loadBootFile5       	L	code    	FFFFFFFFFFFFD890
loadBootFile3       	L	code    	FFFFFFFFFFFFD888
loadBootFile1       	L	code    	FFFFFFFFFFFFD8C8
loadBootFile2       	L	code    	FFFFFFFFFFFFD914
msgJumpingToBoot    	L	code    	FFFFFFFFFFFFD920
msgNotBootable      	L	code    	FFFFFFFFFFFFD930
spi_init_ok_msg     	L	code    	FFFFFFFFFFFFD946
spi_init_error_msg  	L	code    	FFFFFFFFFFFFD960
spi_boot_error_msg  	L	code    	FFFFFFFFFFFFD98B
spi_read_error_msg  	L	code    	FFFFFFFFFFFFD99E
my_MAC1             	C	constant	0000000000000000
my_MAC2             	C	constant	00000000000000FF
my_MAC3             	C	constant	00000000000000EE
my_MAC4             	C	constant	00000000000000F0
my_MAC5             	C	constant	00000000000000DA
my_MAC6             	C	constant	0000000000000042
.bss                	L	code    	FFFFFFFFFFFFD9B4
eth_unique_id       	L	code    	FFFFFFFFFFFFD9B4
.code               	L	code    	FFFFFFFFFFFFD9BC
eth_init            	L	code    	FFFFFFFFFFFFD9BC
eth_request_packet  	L	code    	FFFFFFFFFFFFD9F4
eth1                	L	code    	FFFFFFFFFFFFDA24
eth20               	L	code    	FFFFFFFFFFFFDA4C
eth_interpret_packet	L	code    	FFFFFFFFFFFFDA70
eth2                	L	code    	FFFFFFFFFFFFDA9C
eth5                	L	code    	FFFFFFFFFFFFDA90
eth3                	L	code    	FFFFFFFFFFFFDACC
eth4                	L	code    	FFFFFFFFFFFFDAB4
eth6                	L	code    	FFFFFFFFFFFFDAC0
eth7                	L	code    	FFFFFFFFFFFFDACC
eth_send_packet     	L	code    	FFFFFFFFFFFFDADC
eth8                	L	code    	FFFFFFFFFFFFDAF4
eth_build_packet    	L	code    	FFFFFFFFFFFFDB24
eth16               	L	code    	FFFFFFFFFFFFDBEC
eth_checksum        	L	code    	FFFFFFFFFFFFDC38
eth15               	L	code    	FFFFFFFFFFFFDC58
eth14               	L	code    	FFFFFFFFFFFFDC80
eth_verifyIP        	L	code    	FFFFFFFFFFFFDCB0
eth11               	L	code    	FFFFFFFFFFFFDD0C
eth12               	L	code    	FFFFFFFFFFFFDCF4
eth13               	L	code    	FFFFFFFFFFFFDCF8
eth_main            	L	code    	FFFFFFFFFFFFDD3C
eth_loop            	L	code    	FFFFFFFFFFFFDD40
eth10               	L	code    	FFFFFFFFFFFFDDF8
GOSTART             	L	code    	FFFFFFFFFFFFDF4C
GOWARM              	L	code    	FFFFFFFFFFFFDF50
GOOUT               	L	code    	FFFFFFFFFFFFDF54
GOIN                	L	code    	FFFFFFFFFFFFDF58
GOAUXO              	L	code    	FFFFFFFFFFFFDF5C
GOAUXI              	L	code    	FFFFFFFFFFFFDF60
GOBYE               	L	code    	FFFFFFFFFFFFDF64
TXTBGN              	L	code    	FFFFFFFFFFFFDF68
ENDMEM              	L	code    	FFFFFFFFFFFFDF70
CSTART              	L	code    	FFFFFFFFFFFFDF80
WSTART              	L	code    	FFFFFFFFFFFFE004
ST3                 	L	code    	FFFFFFFFFFFFE01C
DIRECT              	L	code    	FFFFFFFFFFFFE318
ST2                 	L	code    	FFFFFFFFFFFFE048
ERROR               	L	code    	FFFFFFFFFFFFF028
ST4                 	L	code    	FFFFFFFFFFFFE09C
ST7                 	L	code    	FFFFFFFFFFFFE078
ST6                 	L	code    	FFFFFFFFFFFFE094
ST5                 	L	code    	FFFFFFFFFFFFE0C4
TAB1                	L	code    	FFFFFFFFFFFFE0EC
TAB2                	L	code    	FFFFFFFFFFFFE0FE
TAB4                	L	code    	FFFFFFFFFFFFE14E
TAB5                	L	code    	FFFFFFFFFFFFE16F
TAB6                	L	code    	FFFFFFFFFFFFE172
TAB8                	L	code    	FFFFFFFFFFFFE177
TAB9                	L	code    	FFFFFFFFFFFFE181
TAB10               	L	code    	FFFFFFFFFFFFE185
TAB1_1              	L	code    	FFFFFFFFFFFFE188
TAB2_1              	L	code    	FFFFFFFFFFFFE1B0
TAB4_1              	L	code    	FFFFFFFFFFFFE258
TAB5_1              	L	code    	FFFFFFFFFFFFE2A0
TAB6_1              	L	code    	FFFFFFFFFFFFE2B0
TAB8_1              	L	code    	FFFFFFFFFFFFE2C0
TAB9_1              	L	code    	FFFFFFFFFFFFE2F8
TAB10_1             	L	code    	FFFFFFFFFFFFE308
EXEC                	L	code    	FFFFFFFFFFFFE320
EXLP                	L	code    	FFFFFFFFFFFFE334
EXNGO               	L	code    	FFFFFFFFFFFFE34C
EXGO                	L	code    	FFFFFFFFFFFFE384
EXMAT               	L	code    	FFFFFFFFFFFFE374
EX1                 	L	code    	FFFFFFFFFFFFE364
NEW                 	L	code    	FFFFFFFFFFFFE38C
STOP                	L	code    	FFFFFFFFFFFFE39C
RUN                 	L	code    	FFFFFFFFFFFFE3A4
RUNNXL              	L	code    	FFFFFFFFFFFFE3B4
RUNTSL              	L	code    	FFFFFFFFFFFFE3D4
RUNSML              	L	code    	FFFFFFFFFFFFE3DC
GOTO                	L	code    	FFFFFFFFFFFFE3EC
_clr                	L	code    	FFFFFFFFFFFFE40C
FINISH              	L	code    	FFFFFFFFFFFFE518
clearVars           	L	code    	FFFFFFFFFFFFE414
cv1                 	L	code    	FFFFFFFFFFFFE428
LISTX               	L	code    	FFFFFFFFFFFFE440
LS1                 	L	code    	FFFFFFFFFFFFE454
LS4                 	L	code    	FFFFFFFFFFFFE45C
LS3                 	L	code    	FFFFFFFFFFFFE47C
LS2                 	L	code    	FFFFFFFFFFFFE474
PRINT               	L	code    	FFFFFFFFFFFFE488
PR2                 	L	code    	FFFFFFFFFFFFE4A0
PR0                 	L	code    	FFFFFFFFFFFFE4B4
PR3                 	L	code    	FFFFFFFFFFFFE4EC
PR1                 	L	code    	FFFFFFFFFFFFE4CC
PR4                 	L	code    	FFFFFFFFFFFFE4E4
PR8                 	L	code    	FFFFFFFFFFFFE508
PR6                 	L	code    	FFFFFFFFFFFFE500
GOSUB               	L	code    	FFFFFFFFFFFFE520
gosub1              	L	code    	FFFFFFFFFFFFE538
RETURN              	L	code    	FFFFFFFFFFFFE55C
return1             	L	code    	FFFFFFFFFFFFE570
FOR                 	L	code    	FFFFFFFFFFFFE594
FR1                 	L	code    	FFFFFFFFFFFFE5AC
FR2                 	L	code    	FFFFFFFFFFFFE5C0
FR4                 	L	code    	FFFFFFFFFFFFE5CC
FR3                 	L	code    	FFFFFFFFFFFFE5C8
FR5                 	L	code    	FFFFFFFFFFFFE5D0
FR7                 	L	code    	FFFFFFFFFFFFE5EC
FR6                 	L	code    	FFFFFFFFFFFFE5E8
FR8                 	L	code    	FFFFFFFFFFFFE60C
NEXT                	L	code    	FFFFFFFFFFFFE610
NX4                 	L	code    	FFFFFFFFFFFFE624
NX0                 	L	code    	FFFFFFFFFFFFE628
NX5                 	L	code    	FFFFFFFFFFFFE638
NX2                 	L	code    	FFFFFFFFFFFFE644
NX1                 	L	code    	FFFFFFFFFFFFE664
NXPurge             	L	code    	FFFFFFFFFFFFE678
NX3                 	L	code    	FFFFFFFFFFFFE668
IF                  	L	code    	FFFFFFFFFFFFE680
IF1                 	L	code    	FFFFFFFFFFFFE684
IF2                 	L	code    	FFFFFFFFFFFFE688
IF3                 	L	code    	FFFFFFFFFFFFE698
INPERR              	L	code    	FFFFFFFFFFFFE69C
INPUT               	L	code    	FFFFFFFFFFFFE6B0
IP6                 	L	code    	FFFFFFFFFFFFE6B8
IP2                 	L	code    	FFFFFFFFFFFFE6D8
IP4                 	L	code    	FFFFFFFFFFFFE748
IP3                 	L	code    	FFFFFFFFFFFFE708
IP7                 	L	code    	FFFFFFFFFFFFE6F0
IP5                 	L	code    	FFFFFFFFFFFFE758
DEFLT               	L	code    	FFFFFFFFFFFFE764
LET                 	L	code    	FFFFFFFFFFFFE76C
LT1                 	L	code    	FFFFFFFFFFFFE780
LOAD                	L	code    	FFFFFFFFFFFFE784
LOD1                	L	code    	FFFFFFFFFFFFE790
LODEND              	L	code    	FFFFFFFFFFFFE7D0
LOD2                	L	code    	FFFFFFFFFFFFE7B8
GCHAR               	L	code    	FFFFFFFFFFFFE7D8
GCHAR1              	L	code    	FFFFFFFFFFFFE7F0
asciiToHex          	L	code    	FFFFFFFFFFFFE81C
a2h1                	L	code    	FFFFFFFFFFFFE824
SAVE                	L	code    	FFFFFFFFFFFFE830
SAVE1               	L	code    	FFFFFFFFFFFFE838
SAVEND              	L	code    	FFFFFFFFFFFFE874
SAVE2               	L	code    	FFFFFFFFFFFFE860
AUXOCRLF            	L	code    	FFFFFFFFFFFFE88C
PWORD               	L	code    	FFFFFFFFFFFFE8AC
pword1              	L	code    	FFFFFFFFFFFFE8C0
pword2              	L	code    	FFFFFFFFFFFFE8DC
toAsciiHex          	L	code    	FFFFFFFFFFFFE8FC
tah1                	L	code    	FFFFFFFFFFFFE908
POKE                	L	code    	FFFFFFFFFFFFE910
PKER                	L	code    	FFFFFFFFFFFFE93C
POKEC               	L	code    	FFFFFFFFFFFFE944
POKEH               	L	code    	FFFFFFFFFFFFE970
POKEW               	L	code    	FFFFFFFFFFFFE99C
SYSX                	L	code    	FFFFFFFFFFFFE9C8
sysx1               	L	code    	FFFFFFFFFFFFE9DC
OREXPR              	L	code    	FFFFFFFFFFFFE9F0
XP_OR1              	L	code    	FFFFFFFFFFFFE9FC
XP_OR               	L	code    	FFFFFFFFFFFFEA0C
XP_ORX              	L	code    	FFFFFFFFFFFFEA1C
ANDEXPR             	L	code    	FFFFFFFFFFFFEA28
XP_AND1             	L	code    	FFFFFFFFFFFFEA34
XP_AND              	L	code    	FFFFFFFFFFFFEA44
XP_ANDX             	L	code    	FFFFFFFFFFFFEA54
isDigit             	L	code    	FFFFFFFFFFFFEA60
isDigitFalse        	L	code    	FFFFFFFFFFFFEA70
isAlpha             	L	code    	FFFFFFFFFFFFEA78
isAlphaFalse        	L	code    	FFFFFFFFFFFFEA90
isAlphaTrue         	L	code    	FFFFFFFFFFFFEA88
isAlnum             	L	code    	FFFFFFFFFFFFEA98
isDigitx            	L	code    	FFFFFFFFFFFFEAB4
EXPR                	L	code    	FFFFFFFFFFFFEABC
XP11                	L	code    	FFFFFFFFFFFFEAD8
XPRT1               	L	code    	FFFFFFFFFFFFEB44
XPRT0               	L	code    	FFFFFFFFFFFFEB38
XP12                	L	code    	FFFFFFFFFFFFEAE8
XP13                	L	code    	FFFFFFFFFFFFEAF8
XP14                	L	code    	FFFFFFFFFFFFEB08
XP15                	L	code    	FFFFFFFFFFFFEB18
XP16                	L	code    	FFFFFFFFFFFFEB28
XP17                	L	code    	FFFFFFFFFFFFEB50
XP18                	L	code    	FFFFFFFFFFFFEB5C
EXPR2               	L	code    	FFFFFFFFFFFFEB78
XP26                	L	code    	FFFFFFFFFFFFEBD4
XP21                	L	code    	FFFFFFFFFFFFEB98
XP22                	L	code    	FFFFFFFFFFFFEBA4
XP23                	L	code    	FFFFFFFFFFFFEBA8
XP24                	L	code    	FFFFFFFFFFFFEBBC
XP25                	L	code    	FFFFFFFFFFFFEBC8
XP45                	L	code    	FFFFFFFFFFFFEBE0
EXPR3               	L	code    	FFFFFFFFFFFFEBEC
XP31                	L	code    	FFFFFFFFFFFFEBF8
XP34                	L	code    	FFFFFFFFFFFFEC18
XP47                	L	code    	FFFFFFFFFFFFEC38
EXPR4               	L	code    	FFFFFFFFFFFFEC44
XP40                	L	code    	FFFFFFFFFFFFEC58
XP41                	L	code    	FFFFFFFFFFFFEC70
XP46                	L	code    	FFFFFFFFFFFFEC7C
PARN                	L	code    	FFFFFFFFFFFFEC84
XP42                	L	code    	FFFFFFFFFFFFECA8
XP43                	L	code    	FFFFFFFFFFFFECB0
TSTV                	L	code    	FFFFFFFFFFFFECB8
tstv_notfound       	L	code    	FFFFFFFFFFFFED2C
TV1                 	L	code    	FFFFFFFFFFFFED10
TV2                 	L	code    	FFFFFFFFFFFFED04
TSTVRT              	L	code    	FFFFFFFFFFFFED20
getVarName          	L	code    	FFFFFFFFFFFFED3C
gvn1                	L	code    	FFFFFFFFFFFFEDC4
gvn4                	L	code    	FFFFFFFFFFFFED5C
gvn2                	L	code    	FFFFFFFFFFFFED94
gvn6                	L	code    	FFFFFFFFFFFFED84
gvn3                	L	code    	FFFFFFFFFFFFEDA8
findVar             	L	code    	FFFFFFFFFFFFEDD4
fv4                 	L	code    	FFFFFFFFFFFFEDE4
fv3                 	L	code    	FFFFFFFFFFFFEE08
fv1                 	L	code    	FFFFFFFFFFFFEE10
fv2                 	L	code    	FFFFFFFFFFFFEE20
PEEK                	L	code    	FFFFFFFFFFFFEE34
PEEKC               	L	code    	FFFFFFFFFFFFEE44
PEEKH               	L	code    	FFFFFFFFFFFFEE58
PEEKW               	L	code    	FFFFFFFFFFFFEE6C
USRX                	L	code    	FFFFFFFFFFFFEE80
RND                 	L	code    	FFFFFFFFFFFFEE9C
rnd2                	L	code    	FFFFFFFFFFFFEECC
rnd1                	L	code    	FFFFFFFFFFFFEEC4
modu4               	L	code    	FFFFFFFFFFFFEEDC
mod2                	L	code    	FFFFFFFFFFFFEEFC
mod1                	L	code    	FFFFFFFFFFFFEF18
ABS                 	L	code    	FFFFFFFFFFFFEF34
SGN                 	L	code    	FFFFFFFFFFFFEF44
SIZEX               	L	code    	FFFFFFFFFFFFEF54
SETVAL              	L	code    	FFFFFFFFFFFFEF68
sv2                 	L	code    	FFFFFFFFFFFFEF84
SV1                 	L	code    	FFFFFFFFFFFFEFAC
QWHAT               	L	code    	FFFFFFFFFFFFF024
FIN                 	L	code    	FFFFFFFFFFFFEFB0
FI1                 	L	code    	FFFFFFFFFFFFEFCC
FI2                 	L	code    	FFFFFFFFFFFFEFE4
ENDCHK              	L	code    	FFFFFFFFFFFFEFEC
ec1                 	L	code    	FFFFFFFFFFFFF00C
TOOBIG              	L	code    	FFFFFFFFFFFFF014
QSORRY              	L	code    	FFFFFFFFFFFFF01C
GETLN               	L	code    	FFFFFFFFFFFFF068
GL1                 	L	code    	FFFFFFFFFFFFF090
GL3                 	L	code    	FFFFFFFFFFFFF0C4
GL4                 	L	code    	FFFFFFFFFFFFF0EC
GL2                 	L	code    	FFFFFFFFFFFFF0A8
GL7                 	L	code    	FFFFFFFFFFFFF11C
GL6                 	L	code    	FFFFFFFFFFFFF114
GL5                 	L	code    	FFFFFFFFFFFFF0F8
FNDLN               	L	code    	FFFFFFFFFFFFF138
fl1                 	L	code    	FFFFFFFFFFFFF144
FNDLNP              	L	code    	FFFFFFFFFFFFF148
FNDRET1             	L	code    	FFFFFFFFFFFFF174
FNDNXT              	L	code    	FFFFFFFFFFFFF188
FNDRET2             	L	code    	FFFFFFFFFFFFF180
FNDRET              	L	code    	FFFFFFFFFFFFF16C
FNDSKP              	L	code    	FFFFFFFFFFFFF18C
MVUP1               	L	code    	FFFFFFFFFFFFF19C
MVUP                	L	code    	FFFFFFFFFFFFF1AC
MVRET               	L	code    	FFFFFFFFFFFFF1B0
MVDOWN1             	L	code    	FFFFFFFFFFFFF1B4
MVDOWN              	L	code    	FFFFFFFFFFFFF1C4
POPA                	L	code    	FFFFFFFFFFFFF1CC
PP1                 	L	code    	FFFFFFFFFFFFF1FC
PUSHA               	L	code    	FFFFFFFFFFFFF200
PU1                 	L	code    	FFFFFFFFFFFFF240
PRTSTG              	L	code    	FFFFFFFFFFFFF24C
PS1                 	L	code    	FFFFFFFFFFFFF268
PRTRET              	L	code    	FFFFFFFFFFFFF288
QTSTG               	L	code    	FFFFFFFFFFFFF2A4
QT1                 	L	code    	FFFFFFFFFFFFF2BC
QT2                 	L	code    	FFFFFFFFFFFFF2FC
QT3                 	L	code    	FFFFFFFFFFFFF2D4
QT4                 	L	code    	FFFFFFFFFFFFF2E8
QT5                 	L	code    	FFFFFFFFFFFFF308
prCRLF              	L	code    	FFFFFFFFFFFFF310
PRTNUM              	L	code    	FFFFFFFFFFFFF330
PN2                 	L	code    	FFFFFFFFFFFFF360
PN1                 	L	code    	FFFFFFFFFFFFF364
PN6                 	L	code    	FFFFFFFFFFFFF380
PN4                 	L	code    	FFFFFFFFFFFFF390
PN3                 	L	code    	FFFFFFFFFFFFF384
PN5                 	L	code    	FFFFFFFFFFFFF39C
PNRET               	L	code    	FFFFFFFFFFFFF3B0
PRTHEXNUM           	L	code    	FFFFFFFFFFFFF3C8
PHN1                	L	code    	FFFFFFFFFFFFF400
PHN7                	L	code    	FFFFFFFFFFFFF414
PHN8                	L	code    	FFFFFFFFFFFFF418
PHN6                	L	code    	FFFFFFFFFFFFF430
PHN4                	L	code    	FFFFFFFFFFFFF440
PHN3                	L	code    	FFFFFFFFFFFFF434
PHN5                	L	code    	FFFFFFFFFFFFF44C
PHNRET              	L	code    	FFFFFFFFFFFFF460
PRTLN               	L	code    	FFFFFFFFFFFFF478
TSTC                	L	code    	FFFFFFFFFFFFF4C0
TC1                 	L	code    	FFFFFFFFFFFFF4E8
TSTNUM              	L	code    	FFFFFFFFFFFFF4F8
TN1                 	L	code    	FFFFFFFFFFFFF50C
TSNMRET             	L	code    	FFFFFFFFFFFFF54C
TN2                 	L	code    	FFFFFFFFFFFFF534
IGNBLK              	L	code    	FFFFFFFFFFFFF554
IGB2                	L	code    	FFFFFFFFFFFFF55C
IGB1                	L	code    	FFFFFFFFFFFFF568
IGBRET              	L	code    	FFFFFFFFFFFFF570
TOUPBUF             	L	code    	FFFFFFFFFFFFF578
TOUPB1              	L	code    	FFFFFFFFFFFFF588
TOUPBRT             	L	code    	FFFFFFFFFFFFF5C4
DOQUO               	L	code    	FFFFFFFFFFFFF5AC
DOQUO1              	L	code    	FFFFFFFFFFFFF5B8
toUpper             	L	code    	FFFFFFFFFFFFF5CC
TOUPRET             	L	code    	FFFFFFFFFFFFF5D8
CHKIO               	L	code    	FFFFFFFFFFFFF5DC
CHKRET2             	L	code    	FFFFFFFFFFFFF5F4
CHKRET              	L	code    	FFFFFFFFFFFFF5F8
PRMESG              	L	code    	FFFFFFFFFFFFF604
PRMESG1             	L	code    	FFFFFFFFFFFFF614
PRMRET              	L	code    	FFFFFFFFFFFFF628
PRMESGAUX           	L	code    	FFFFFFFFFFFFF638
PRMESGA1            	L	code    	FFFFFFFFFFFFF648
PRMRETA             	L	code    	FFFFFFFFFFFFF65C
OUTC                	L	code    	FFFFFFFFFFFFF66C
INC                 	L	code    	FFFFFFFFFFFFF670
AUXIN               	L	code    	FFFFFFFFFFFFF674
AXIRET_ZERO         	L	code    	FFFFFFFFFFFFF684
AXIRET              	L	code    	FFFFFFFFFFFFF680
AUXOUT              	L	code    	FFFFFFFFFFFFF68C
_cls                	L	code    	FFFFFFFFFFFFF690
_wait10             	L	code    	FFFFFFFFFFFFF698
_getATAStatus       	L	code    	FFFFFFFFFFFFF69C
_waitCFNotBusy      	L	code    	FFFFFFFFFFFFF6A0
_rdcf               	L	code    	FFFFFFFFFFFFF6A4
rdcf6               	L	code    	FFFFFFFFFFFFF6A8
BYEBYE              	L	code    	FFFFFFFFFFFFF8A0
msgInit             	L	code    	FFFFFFFFFFFFF6B8
OKMSG               	L	code    	FFFFFFFFFFFFF6EE
msgWhat             	L	code    	FFFFFFFFFFFFF6F5
SRYMSG              	L	code    	FFFFFFFFFFFFF6FD
CLMSG               	L	code    	FFFFFFFFFFFFF703
msgReadError        	L	code    	FFFFFFFFFFFFF706
msgNumTooBig        	L	code    	FFFFFFFFFFFFF721
msgDivZero          	L	code    	FFFFFFFFFFFFF735
msgVarSpace         	L	code    	FFFFFFFFFFFFF748
msgBytesFree        	L	code    	FFFFFFFFFFFFF760
msgReady            	L	code    	FFFFFFFFFFFFF76E
msgComma            	L	code    	FFFFFFFFFFFFF778
msgLineRange        	L	code    	FFFFFFFFFFFFF78C
msgVar              	L	code    	FFFFFFFFFFFFF7A2
msgRNDBad           	L	code    	FFFFFFFFFFFFF7B9
msgSYSBad           	L	code    	FFFFFFFFFFFFF7CD
msgInputVar         	L	code    	FFFFFFFFFFFFF7DF
msgNextFor          	L	code    	FFFFFFFFFFFFF7FC
msgNextVar          	L	code    	FFFFFFFFFFFFF80F
msgBadGotoGosub     	L	code    	FFFFFFFFFFFFF833
msgRetWoGosub       	L	code    	FFFFFFFFFFFFF850
msgTooBig           	L	code    	FFFFFFFFFFFFF867
msgExtraChars       	L	code    	FFFFFFFFFFFFF87C
LSTROM              	C	constant	0000000000000000
ramtest             	L	code    	FFFFFFFFFFFFF8B0
ramtest2            	L	code    	FFFFFFFFFFFFF8C4
ramtest1            	L	code    	FFFFFFFFFFFFF8E8
ramtest4            	L	code    	FFFFFFFFFFFFF8F0
ramtest3            	L	code    	FFFFFFFFFFFFF91C
ramtest8            	L	code    	FFFFFFFFFFFFF98C
ramtest5            	L	code    	FFFFFFFFFFFFF934
ramtest6            	L	code    	FFFFFFFFFFFFF958
ramtest7            	L	code    	FFFFFFFFFFFFF960
ramtest9            	L	code    	FFFFFFFFFFFFF994
ramtest10           	L	code    	FFFFFFFFFFFFF99C
iberr_rout          	L	code    	FFFFFFFFFFFFF9A4
dberr_rout          	L	code    	FFFFFFFFFFFFF9BC
dberr1              	L	code    	FFFFFFFFFFFFF9F0
msgdberr            	L	code    	FFFFFFFFFFFFFA20
msgEPC              	L	code    	FFFFFFFFFFFFFA34
msgiberr            	L	code    	FFFFFFFFFFFFFA3B
irqrout             	L	code    	FFFFFFFFFFFFFA5C
irq1000Hz           	L	code    	FFFFFFFFFFFFFABC
irq100Hz            	L	code    	FFFFFFFFFFFFFAF0
irqSerial           	L	code    	FFFFFFFFFFFFFB10
irqRaster           	L	code    	FFFFFFFFFFFFFB1C
irqKeybd            	L	code    	FFFFFFFFFFFFFB28
irqColdStart        	L	code    	FFFFFFFFFFFFFB34
irqret              	L	code    	FFFFFFFFFFFFFAF8
nmirout             	L	code    	FFFFFFFFFFFFFB38
msgPerr             	L	code    	FFFFFFFFFFFFFB80
ui_irout            	L	code    	FFFFFFFFFFFFFB94
ui_irout1           	L	code    	FFFFFFFFFFFFFBB8
msgUnimp            	L	code    	FFFFFFFFFFFFFBC0
DTLBHandler         	L	code    	FFFFFFFFFFFFFBE0
dh1                 	L	code    	FFFFFFFFFFFFFBF0
