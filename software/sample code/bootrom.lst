                  	           		; ============================================================================
                  	           		 ; (C) 2012,2013 Robert Finch, Stratford
                  	           		 ; All Rights Reserved.
                  	           		 ; robfinch<remove>@opencores.org
                  	           		 ;
                  	           		 ; This source file is free software: you can redistribute it and/or modify 
                  	           		 ; it under the terms of the GNU Lesser General Public License as published 
                  	           		 ; by the Free Software Foundation, either version 3 of the License, or     
                  	           		 ; (at your option) any later version.                                      
                  	           		 ;                                                                          
                  	           		 ; This source file is distributed in the hope that it will be useful,      
                  	           		 ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                  	           		 ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                  	           		 ; GNU General Public License for more details.                             
                  	           		 ;                                                                          
                  	           		 ; You should have received a copy of the GNU General Public License        
                  	           		 ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                  	           		 ;                                                                          
                  	           		 ; ============================================================================
                  	           		 ;
                  	           		 CR	EQU	0x0D		;ASCII equates
                  	           		 LF	EQU	0x0A
                  	           		 TAB	EQU	0x09
                  	           		 CTRLC	EQU	0x03
                  	           		 CTRLH	EQU	0x08
                  	           		 CTRLS	EQU	0x13
                  	           		 CTRLX	EQU	0x18
                  	           		 XON		EQU	0x11
                  	           		 XOFF	EQU	0x13
                  	           		 
                  	           		 DATA_PRESENT	EQU	0x01		; there is data preset at the serial port bc_uart3
                  	           		 XMIT_NOT_FULL	EQU	0x20
                  	           		 
                  	           		 BUFLEN	EQU	80	;	length of keyboard input buffer
                  	           		 
                  	           		 ; Initial stack tops for contexts
                  	           		 ; Each context gets 1k from the special 16k startup stack memory
                  	           		 ;
                  	           		 STACKTOP0	EQU		0xFFFF_FFFF_FFFE_FFF8
                  	           		 STACKTOP1	EQU		0xFFFF_FFFF_FFFE_FBF8
                  	           		 STACKTOP2	EQU		0xFFFF_FFFF_FFFE_F7F8
                  	           		 STACKTOP3	EQU		0xFFFF_FFFF_FFFE_F3F8
                  	           		 STACKTOP4	EQU		0xFFFF_FFFF_FFFE_EFF8
                  	           		 STACKTOP5	EQU		0xFFFF_FFFF_FFFE_EBF8
                  	           		 STACKTOP6	EQU		0xFFFF_FFFF_FFFE_E7F8
                  	           		 STACKTOP7	EQU		0xFFFF_FFFF_FFFE_E3F8
                  	           		 STACKTOP8	EQU		0xFFFF_FFFF_FFFE_DFF8
                  	           		 STACKTOP9	EQU		0xFFFF_FFFF_FFFE_DBF8
                  	           		 STACKTOP10	EQU		0xFFFF_FFFF_FFFE_D7F8
                  	           		 STACKTOP11	EQU		0xFFFF_FFFF_FFFE_D3F8
                  	           		 STACKTOP12	EQU		0xFFFF_FFFF_FFFE_CFF8
                  	           		 STACKTOP13	EQU		0xFFFF_FFFF_FFFE_CBF8
                  	           		 STACKTOP14	EQU		0xFFFF_FFFF_FFFE_C7F8
                  	           		 STACKTOP15	EQU		0xFFFF_FFFF_FFFE_C3F8
                  	           		 
                  	           		 
                  	           		 ; BOOT ROM routines
                  	           		 
                  	           		 TCBSize		EQU		0x200			; 512 bytes per TCB
                  	           		 TCBBase		EQU		0x00000001_00000000			; TCB pages
                  	           		 TCBr1		EQU		0x00
                  	           		 TCBr2		EQU		0x08
                  	           		 TCBr3		EQU		0x10
                  	           		 TCBr4		EQU		0x18
                  	           		 TCBr5		EQU		0x20
                  	           		 TCBr6		EQU		0x28
                  	           		 TCBr7		EQU		0x30
                  	           		 TCBr8		EQU		0x38
                  	           		 TCBr9		EQU		0x40
                  	           		 TCBr10		EQU		0x48
                  	           		 TCBr11		EQU		0x50
                  	           		 TCBr12		EQU		0x58
                  	           		 TCBr13		EQU		0x60
                  	           		 TCBr14		EQU		0x68
                  	           		 TCBr15		EQU		0x70
                  	           		 TCBr16		EQU		0x78
                  	           		 TCBr17		EQU		0x80
                  	           		 TCBr18		EQU		0x88
                  	           		 TCBr19		EQU		0x90
                  	           		 TCBr20		EQU		0x98
                  	           		 TCBr21		EQU		0xA0
                  	           		 TCBr22		EQU		0xA8
                  	           		 TCBr23		EQU		0xB0
                  	           		 TCBr24		EQU		0xB8
                  	           		 TCBr25		EQU		0xC0
                  	           		 TCBr26		EQU		0xC8
                  	           		 TCBr27		EQU		0xD0
                  	           		 TCBr28		EQU		0xD8
                  	           		 TCBr29		EQU		0xE0
                  	           		 TCBr30		EQU		0xE8
                  	           		 TCBr31		EQU		0xF0
                  	           		 
                  	           		 warmStart   EQU     0x1020
                  	           		 usrJmp      EQU     0x1028
                  	           		 TickIRQAddr		EQU		0x1030
                  	           		 TaskBlock		EQU		0x1038
                  	           		 tencount		EQU		0x13F8
                  	           		 Milliseconds	EQU		0x1400
                  	           		 Lastloc			EQU		0x1408
                  	           		 ScreenColor	EQU		0x1414
                  	           		 CursorRow	EQU		0x1416
                  	           		 CursorCol	EQU		0x1418
                  	           		 CursorFlash	EQU		0x141A
                  	           		 KeybdEcho	EQU		0x141C
                  	           		 KeybdBuffer	EQU		0x1440
                  	           		 KeybdHead	EQU		0x1450
                  	           		 KeybdTail	EQU		0x1451
                  	           		 Score		EQU		0x1500
                  	           		 Manpos		EQU		0x1508
                  	           		 MissileActive	EQU		0x1510
                  	           		 MissileX	EQU		0x1512
                  	           		 MissileY	EQU		0x1514
                  	           		 InvadersRow1	EQU		0x1520
                  	           		 InvadersRow2	EQU		0x1530
                  	           		 InvadersRow3	EQU		0x1540
                  	           		 InvadersRow4	EQU		0x1550
                  	           		 InvadersRow5	EQU		0x1560
                  	           		 InvadersColpos	EQU		0x1570
                  	           		 InvadersRowpos	EQU		0x1571
                  	           		 Uart_rxfifo		EQU		0x1600
                  	           		 Uart_rxhead		EQU		0x1800
                  	           		 Uart_rxtail		EQU		0x1802
                  	           		 Uart_ms			EQU		0x1808
                  	           		 Uart_rxrts		EQU		0x1809
                  	           		 Uart_rxdtr		EQU		0x180A
                  	           		 Uart_rxxon		EQU		0x180B
                  	           		 Uart_rxflow		EQU		0x180C
                  	           		 Uart_fon		EQU		0x180E
                  	           		 Uart_foff		EQU		0x1810
                  	           		 Uart_txrts		EQU		0x1812
                  	           		 Uart_txdtr		EQU		0x1813
                  	           		 Uart_txxon		EQU		0x1814
                  	           		 Uart_txxonoff	EQU		0x1815
                  	           		 TaskList		EQU		0x2000
                  	           		 ReadyList1		EQU		0x2000
                  	           		 ReadyList2		EQU		0x2020
                  	           		 ReadyList3		EQU		0x2040
                  	           		 ReadyList4		EQU		0x2060
                  	           		 ReadyList5		EQU		0x2080
                  	           		 ReadyNdx1		EQU		0x20A0
                  	           		 ReadyNdx2		EQU		0x20A1
                  	           		 ReadyNdx3		EQU		0x20A2
                  	           		 ReadyNdx4		EQU		0x20A3
                  	           		 ReadyNdx5		EQU		0x20A4
                  	           		 RunningTCB		EQU		0x20A6
                  	           		 NextToRunTCB	EQU		0x20A8
                  	           		 r1save			EQU		0x20B0
                  	           		 r2save			EQU		0x20B8
                  	           		 AXCstart		EQU		0x20C0
                  	           		 
                  	           		 p100IRQvec		EQU		0x3000
                  	           		 keybdIRQvec		EQU		0x3008
                  	           		 serialIRQvec	EQU		0x3010
                  	           		 rasterIRQvec	EQU		0x3018
                  	           		 
                  	           		 TEXTSCR		EQU		0xD0_0000
                  	           		 COLORSCR	EQU		0xD1_0000
                  	           		 TEXTREG		EQU		0xDA_0000
                  	           		 TEXT_COLS	EQU		0x0
                  	           		 TEXT_ROWS	EQU		0x2
                  	           		 TEXT_CURPOS	EQU		0x16
                  	           		 KEYBD		EQU		0xDC_0000
                  	           		 KEYBDCLR	EQU		0xDC_0002
                  	           		 
                  	           		 UART		EQU		0xDC_0A00
                  	           		 UART_LS		EQU		0xDC_0A01
                  	           		 UART_MS		EQU		0xDC_0A02
                  	           		 UART_IS		EQU		0xDC_0A03
                  	           		 UART_IE		EQU		0xDC_0A04
                  	           		 UART_MC		EQU		0xDC_0A06
                  	           		 DATETIME	EQU		0xDC_0400
                  	           		 PIC			EQU		0xDC_0FF0
                  	           		 PIC_IE		EQU		0xDC_0FF2
                  	           		 
                  	           		 PSG			EQU		0xD5_0000
                  	           		 PSGFREQ0	EQU		0xD5_0000
                  	           		 PSGPW0		EQU		0xD5_0002
                  	           		 PSGCTRL0	EQU		0xD5_0004
                  	           		 PSGADSR0	EQU		0xD5_0006
                  	           		 
                  	           		 SPRRAM		EQU		0xD8_0000
                  	           		 AC97		EQU		0xDC_1000
                  	           		 LED			EQU		0xDC_0600
                  	           		 GACCEL		EQU		0xDA_E000
                  	           		 RASTERIRQ	EQU		0xDA_0100
                  	           		 BOOT_STACK	EQU		0xFFFF_FFFF_FFFE_FFF8
                  	           		 SPRITEREGS	EQU		0xDA_D000
                  	           		 BITMAPSCR	EQU		0x00000001_00200000
                  	           		 
                  	           		 txempty	EQU		0x40
                  	           		 rxfull	EQU		0x01
                  	           		 
                  	           		 ;
                  	           		 ; Internal variables follow:
                  	           		 ;
0000000100600000	           		 		bss
0000000000001038	           		 		org		0x1038
0000000000000000	           		 pos		dh		0		; text screen position
0000000000001040	           		 		org		0x1040
                  	           		 
1040 0000000000000000	 lineLinkTbl		fill.b	25,0	; screen line link table
1048 0000000000000000
1050 0000000000000000
1058 0000000000000000
0000000000001068	           		 		align 8
                  	           		 
0000000000001080	           		 		org		0x1080
0000000000001088	           		         align   8
0000000000001088 0000000000000001	 OSSP	dw	1	; OS value of sp
0000000000001090 0000000000000001	 CURRNT	dw	1	;	Current line pointer
0000000000001098 0000000000000001	 STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
00000000000010A0 0000000000000001	 STKINP	dw	1	;	Saves stack pointer during 'INPUT'
00000000000010A8 0000000000000001	 LOPVAR	dw	1	;	'FOR' loop save area
00000000000010B0 0000000000000001	 LOPINC	dw	1	;	increment
00000000000010B8 0000000000000001	 LOPLMT	dw	1	;	limit
00000000000010C0 0000000000000001	 LOPLN	dw	1	;	line number
00000000000010C8 0000000000000001	 LOPPT	dw	1	;	text pointer
00000000000010D0 0000000000000001	 TXTUNF	dw	1	;	points to unfilled text area
00000000000010D8 0000000000000001	 VARBGN	dw	1	;	points to variable area
00000000000010E0 0000000000000001	 IVARBGN dw  1   ;   points to integer variable area
00000000000010E8 0000000000000001	 SVARBGN dw  1   ;   points to string variable area
00000000000010F0 0000000000000001	 FVARBGN dw  1   ;   points to float variable area
00000000000010F8 0000000000000001	 STKBOT	dw	1	;	holds lower limit for stack growth
1100 0000000000000000	 NUMWKA	fill.b	24,0			; numeric work area
1108 0000000000000000
1110 0000000000000000
1118 0000000000000000	 BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
1120 0000000000000000
1128 0000000000000000
1130 0000000000000000
1138 0000000000000000
1140 0000000000000000
1148 0000000000000000
1150 0000000000000000
1158 0000000000000000
1160 0000000000000000
                  	           		 
000000000000116E	           		         bss
0000000100600000	           		         org     0x1_00600000
                  	           		 TXT		equ		0x1_00600000	; Beginning of program area
                  	           		 
                  	           		 ;	org 0x070
                  	           		 ;	iret
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;	nop
                  	           		 ;
0000000000000000	           		 	code
FFFFFFFFFFFFB000	           		 	org 0xFFFF_FFFF_FFFF_B000
                  	           		 
                  	           		 ; jump table
                  	           		 ;
FFFFFFFFFFFFB000	33FFED54		 	jmp		SerialGetChar
FFFFFFFFFFFFB004	33FFED0C		 	jmp		SerialPutChar
FFFFFFFFFFFFB008	33FFEE06		 	jmp		SetKeyboardEcho
FFFFFFFFFFFFB00C	33FFEE1D		 	jmp		KeybdCheckForKey
FFFFFFFFFFFFB010	33FFEE08		 	jmp		KeybdGetChar
FFFFFFFFFFFFB014	33FFEF47		 	jmp		DisplayChar
FFFFFFFFFFFFB018	33FFEFE7		 	jmp		DisplayString
                  	           		 
FFFFFFFFFFFFB01C	           		 start:
                  	           		 ;	lea		MSGRAM,a1
                  	           		 ;	jsr		DisplayString
                  	           		 
FFFFFFFFFFFFB01C	           		 ColdStart:
FFFFFFFFFFFFB01C	0000000A		 	icache_on				; turn on the ICache
FFFFFFFFFFFFB020	0000000D		 	dcache_off				; turn on the DCache
                  	           		 
                  	           		 ; Initialize the context schedule with all contexts treated equally
                  	           		 ; There are only 16 contexts, but 256 schedule slots. Each context is
                  	           		 ; given 16 slots distributed evenly throughout the execution pattern
                  	           		 ; table.
                  	           		 ;
FFFFFFFFFFFFB024	0410840A		 	xor		r1,r1,r1	; r1 = 0
FFFFFFFFFFFFB028	           		 ict1:
FFFFFFFFFFFFB028	0410803A		 	mtep	r1,r1		; only the low order four bits of r1 will move to the pattern table
FFFFFFFFFFFFB02C	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFB030	101100FF		 	cmpi	r2,r1,#255
FFFFFFFFFFFFB034	BE207FA9		 	bne		r2,r0,ict1
                  	           		 
                  	           		 ; Point the interrupt return address register of the context to the 
                  	           		 ; context startup code. The context will start up when an interrupt return
                  	           		 ; occurs.
                  	           		 ;
                  	           		 ; We cannot use a loop for this. Fortunately there's only 16 contexts.
                  	           		 ;
FFFFFFFFFFFFB038	E6BFB214		; SETLO
FFFFFFFFFFFFB03C	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB040	E6BEFFF8		; SETLO
FFFFFFFFFFFFB044	6A0D782D		 	lea		r30,STACKTOP0
FFFFFFFFFFFFB048	0000000F		 	iepp
FFFFFFFFFFFFB04C	DE000000		 	nop
FFFFFFFFFFFFB050	DE000000		 	nop
FFFFFFFFFFFFB054	E6BFB214		; SETLO
FFFFFFFFFFFFB058	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB05C	E6BEFBF8		; SETLO
FFFFFFFFFFFFB060	6A0D782D		 	lea		r30,STACKTOP1
FFFFFFFFFFFFB064	0000000F		 	iepp		
FFFFFFFFFFFFB068	DE000000		 	nop
FFFFFFFFFFFFB06C	DE000000		 	nop
FFFFFFFFFFFFB070	E6BFB214		; SETLO
FFFFFFFFFFFFB074	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB078	E6BEF7F8		; SETLO
FFFFFFFFFFFFB07C	6A0D782D		 	lea		r30,STACKTOP2
FFFFFFFFFFFFB080	0000000F		 	iepp		
FFFFFFFFFFFFB084	DE000000		 	nop
FFFFFFFFFFFFB088	DE000000		 	nop
FFFFFFFFFFFFB08C	E6BFB214		; SETLO
FFFFFFFFFFFFB090	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB094	E6BEF3F8		; SETLO
FFFFFFFFFFFFB098	6A0D782D		 	lea		r30,STACKTOP3
FFFFFFFFFFFFB09C	0000000F		 	iepp		
FFFFFFFFFFFFB0A0	DE000000		 	nop
FFFFFFFFFFFFB0A4	DE000000		 	nop
                  	           		 
FFFFFFFFFFFFB0A8	E6BFB214		; SETLO
FFFFFFFFFFFFB0AC	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB0B0	E6BEEFF8		; SETLO
FFFFFFFFFFFFB0B4	6A0D782D		 	lea		r30,STACKTOP4
FFFFFFFFFFFFB0B8	0000000F		 	iepp
FFFFFFFFFFFFB0BC	DE000000		 	nop
FFFFFFFFFFFFB0C0	DE000000		 	nop
FFFFFFFFFFFFB0C4	E6BFB214		; SETLO
FFFFFFFFFFFFB0C8	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB0CC	E6BEEBF8		; SETLO
FFFFFFFFFFFFB0D0	6A0D782D		 	lea		r30,STACKTOP5
FFFFFFFFFFFFB0D4	0000000F		 	iepp		
FFFFFFFFFFFFB0D8	DE000000		 	nop
FFFFFFFFFFFFB0DC	DE000000		 	nop
FFFFFFFFFFFFB0E0	E6BFB214		; SETLO
FFFFFFFFFFFFB0E4	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB0E8	E6BEE7F8		; SETLO
FFFFFFFFFFFFB0EC	6A0D782D		 	lea		r30,STACKTOP6
FFFFFFFFFFFFB0F0	0000000F		 	iepp		
FFFFFFFFFFFFB0F4	DE000000		 	nop
FFFFFFFFFFFFB0F8	DE000000		 	nop
FFFFFFFFFFFFB0FC	E6BFB214		; SETLO
FFFFFFFFFFFFB100	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB104	E6BEE3F8		; SETLO
FFFFFFFFFFFFB108	6A0D782D		 	lea		r30,STACKTOP7
FFFFFFFFFFFFB10C	0000000F		 	iepp		
FFFFFFFFFFFFB110	DE000000		 	nop
FFFFFFFFFFFFB114	DE000000		 	nop
                  	           		 	
FFFFFFFFFFFFB118	E6BFB214		; SETLO
FFFFFFFFFFFFB11C	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB120	E6BEDFF8		; SETLO
FFFFFFFFFFFFB124	6A0D782D		 	lea		r30,STACKTOP8
FFFFFFFFFFFFB128	0000000F		 	iepp
FFFFFFFFFFFFB12C	DE000000		 	nop
FFFFFFFFFFFFB130	DE000000		 	nop
FFFFFFFFFFFFB134	E6BFB214		; SETLO
FFFFFFFFFFFFB138	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB13C	E6BEDBF8		; SETLO
FFFFFFFFFFFFB140	6A0D782D		 	lea		r30,STACKTOP9
FFFFFFFFFFFFB144	0000000F		 	iepp		
FFFFFFFFFFFFB148	DE000000		 	nop
FFFFFFFFFFFFB14C	DE000000		 	nop
FFFFFFFFFFFFB150	E6BFB214		; SETLO
FFFFFFFFFFFFB154	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB158	E6BED7F8		; SETLO
FFFFFFFFFFFFB15C	6A0D782D		 	lea		r30,STACKTOP10
FFFFFFFFFFFFB160	0000000F		 	iepp		
FFFFFFFFFFFFB164	DE000000		 	nop
FFFFFFFFFFFFB168	DE000000		 	nop
FFFFFFFFFFFFB16C	E6BFB214		; SETLO
FFFFFFFFFFFFB170	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB174	E6BED3F8		; SETLO
FFFFFFFFFFFFB178	6A0D782D		 	lea		r30,STACKTOP11
FFFFFFFFFFFFB17C	0000000F		 	iepp		
FFFFFFFFFFFFB180	DE000000		 	nop
FFFFFFFFFFFFB184	DE000000		 	nop
                  	           		 	
FFFFFFFFFFFFB188	E6BFB214		; SETLO
FFFFFFFFFFFFB18C	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB190	E6BECFF8		; SETLO
FFFFFFFFFFFFB194	6A0D782D		 	lea		r30,STACKTOP12
FFFFFFFFFFFFB198	0000000F		 	iepp
FFFFFFFFFFFFB19C	DE000000		 	nop
FFFFFFFFFFFFB1A0	DE000000		 	nop
FFFFFFFFFFFFB1A4	E6BFB214		; SETLO
FFFFFFFFFFFFB1A8	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB1AC	E6BECBF8		; SETLO
FFFFFFFFFFFFB1B0	6A0D782D		 	lea		r30,STACKTOP13
FFFFFFFFFFFFB1B4	0000000F		 	iepp		
FFFFFFFFFFFFB1B8	DE000000		 	nop
FFFFFFFFFFFFB1BC	DE000000		 	nop
FFFFFFFFFFFFB1C0	E6BFB214		; SETLO
FFFFFFFFFFFFB1C4	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB1C8	E6BEC7F8		; SETLO
FFFFFFFFFFFFB1CC	6A0D782D		 	lea		r30,STACKTOP14
FFFFFFFFFFFFB1D0	0000000F		 	iepp		
FFFFFFFFFFFFB1D4	DE000000		 	nop
FFFFFFFFFFFFB1D8	DE000000		 	nop
FFFFFFFFFFFFB1DC	E6BFB214		; SETLO
FFFFFFFFFFFFB1E0	6A0D642D		 	lea		r25,ctxstart
FFFFFFFFFFFFB1E4	E6BEC3F8		; SETLO
FFFFFFFFFFFFB1E8	6A0D782D		 	lea		r30,STACKTOP15
FFFFFFFFFFFFB1EC	0000000F		 	iepp		
FFFFFFFFFFFFB1F0	DE000000		 	nop
FFFFFFFFFFFFB1F4	DE000000		 	nop
                  	           		 
                  	           		 ; Ensure that context zero is the active context
                  	           		 ;
FFFFFFFFFFFFB1F8	           		 ctxstart3:
FFFFFFFFFFFFB1F8	02008568		 	mfspr	r1,AXC			
FFFFFFFFFFFFB1FC	BE1000A8		 	beq		r1,r0,ctxstart2
FFFFFFFFFFFFB200	0000000F		 	iepp
FFFFFFFFFFFFB204	DE000000		 	nop
FFFFFFFFFFFFB208	DE000000		 	nop
FFFFFFFFFFFFB20C	BE007F6A		 	bra		ctxstart3
FFFFFFFFFFFFB210	           		 ctxstart2:	
FFFFFFFFFFFFB210	6000A0C0		 	sb		r1,AXCstart		; save off the startup context which should be context zero
                  	           		 
                  	           		 ; Entry point for context startup
                  	           		 ;
                  	           		 ; Avoid repeating all the system initialization when a context starts up by testing whether
                  	           		 ; or not the context is the starting context.
                  	           		 ;
FFFFFFFFFFFFB214	           		 ctxstart:
FFFFFFFFFFFFB214	02008568		 	mfspr	r1,AXC
FFFFFFFFFFFFB218	4A0120C0		 	lbu		r2,AXCstart
FFFFFFFFFFFFB21C	BE1107E9		 	bne		r1,r2,ctxstart1
                  	           		 	
                  	           		 ;
                  	           		 ; set system vectors
                  	           		 ; TBA defaults to zero on reset
                  	           		 ;
FFFFFFFFFFFFB220	E0C00000		 	setlo	r3,#0
FFFFFFFFFFFFB224	E08001FF		 	setlo	r2,#511
FFFFFFFFFFFFB228	9A00EA20		 	lea		r1,nmirout
FFFFFFFFFFFFB22C	           		 csj5:
FFFFFFFFFFFFB22C	66308000		 	sw		r1,[r3]
FFFFFFFFFFFFB230	0A318008		 	addui	r3,r3,#8
FFFFFFFFFFFFB234	BE017FCF		 	loop	r2,csj5
FFFFFFFFFFFFB238	E6BFB768		; SETLO
FFFFFFFFFFFFB23C	6A0D042D		 	lea		r1,KeybdSC		; keyboard BIOS vector
FFFFFFFFFFFFB240	66008D08		 	sw		r1,0xD08
FFFFFFFFFFFFB244	9A00E950		 	lea		r1,irqrout
FFFFFFFFFFFFB248	66008E08		 	sw		r1,0xE08		; set IRQ vector
FFFFFFFFFFFFB24C	9A00E8BC		 	lea		r1,dberr_rout
FFFFFFFFFFFFB250	66008FE0		 	sw		r1,0xFE0		; set Bus error vector
FFFFFFFFFFFFB254	9A00E8A4		 	lea		r1,iberr_rout
FFFFFFFFFFFFB258	66008FE8		 	sw		r1,0xFE8		; set Bus error vector
FFFFFFFFFFFFB25C	9A00EA20		 	lea		r1,nmirout
FFFFFFFFFFFFB260	66008FF0		 	sw		r1,0xFF0		; set NMI vector
                  	           		 	
FFFFFFFFFFFFB264	E6BFB7C4		; SETLO
FFFFFFFFFFFFB268	6A0D042D		 	lea		r1,KeybdIRQ
FFFFFFFFFFFFB26C	6600B008		 	sw		r1,keybdIRQvec
FFFFFFFFFFFFB270	E6BFB8EC		; SETLO
FFFFFFFFFFFFB274	6A0D042D		 	lea		r1,Pulse100
FFFFFFFFFFFFB278	6600B000		 	sw		r1,p100IRQvec
FFFFFFFFFFFFB27C	E6BFB628		; SETLO
FFFFFFFFFFFFB280	6A0D042D		 	lea		r1,SerialIRQ
FFFFFFFFFFFFB284	6600B010		 	sw		r1,serialIRQvec
FFFFFFFFFFFFB288	9A00CAC4		 	lea		r1,RasterIRQfn
FFFFFFFFFFFFB28C	6600B018		 	sw		r1,rasterIRQvec
                  	           		 
                  	           		 	;-------------------------------
                  	           		 	; Initialize I/O devices
                  	           		 	;-------------------------------
FFFFFFFFFFFFB290	31FFECEC		 	call	SerialInit
FFFFFFFFFFFFB294	31FFEDEC		 	call	KeybdInit
FFFFFFFFFFFFB298	31FFECE4		 	call	PICInit
FFFFFFFFFFFFB29C	31FFF299		 	call	SetupRasterIRQ
FFFFFFFFFFFFB2A0	00000040		 	cli						; enable interrupts
                  	           		 ;	call	HelloWorld
FFFFFFFFFFFFB2A4	E0C000CE		 	setlo	r3,#0xCE		; blue on blue
FFFFFFFFFFFFB2A8	62019414		 	sc		r3,ScreenColor
FFFFFFFFFFFFB2AC	42019414		 	lc		r3,0x1414
FFFFFFFFFFFFB2B0	E0C00020		 	setlo	r3,#32
FFFFFFFFFFFFB2B4	62019416		 	sc		r3,0x1416		; we do a store, then a load through the dcache
FFFFFFFFFFFFB2B8	42011416		 	lc		r2,0x1416		;
FFFFFFFFFFFFB2BC	BE218048		 	beq		r2,r3,dcokay
FFFFFFFFFFFFB2C0	0000000D		 	dcache_off				; data cache failed
FFFFFFFFFFFFB2C4	           		 dcokay:
FFFFFFFFFFFFB2C4	620020A8		 	sc		r0,NextToRunTCB
FFFFFFFFFFFFB2C8	620020A6		 	sc		r0,RunningTCB
FFFFFFFFFFFFB2CC	31FFEED9		 	call	ClearScreen
FFFFFFFFFFFFB2D0	31FFEEC4		 	call	ClearBmpScreen
FFFFFFFFFFFFB2D4	31FFF1ED		 	call	RandomizeSprram
FFFFFFFFFFFFB2D8	62001416		 	sc		r0,CursorRow
FFFFFFFFFFFFB2DC	62001418		 	sc		r0,CursorCol
FFFFFFFFFFFFB2E0	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB2E4	6000941A		 	sb		r1,CursorFlash
FFFFFFFFFFFFB2E8	E6BFB36D		; SETLO
FFFFFFFFFFFFB2EC	6A0D042D		 	lea		r1,MSGSTART
FFFFFFFFFFFFB2F0	31FFEFF5		 	call	DisplayStringCRLF
FFFFFFFFFFFFB2F4	33FFF096		 	jmp		Monitor
FFFFFFFFFFFFB2F8	31FFF1F7		 	call	SetupAC97		; and Beep
FFFFFFFFFFFFB2FC	E0C00004		 	setlo	r3,#4
FFFFFFFFFFFFB300	E69C0600		; SETLO
FFFFFFFFFFFFB304	EE800003		; SETMID
FFFFFFFFFFFFB308	6A0D0C28		 	outb	r3,LED
FFFFFFFFFFFFB30C	31FFF221		 	call	Beep
                  	           		 
FFFFFFFFFFFFB310	           		 j4:
FFFFFFFFFFFFB310	33FFF096		 	jmp		Monitor
FFFFFFFFFFFFB314	BE007FEA		 	bra		j4
                  	           		 
                  	           		 ; for now hang the contexts
                  	           		 ;
FFFFFFFFFFFFB318	           		 ctxstart1:
FFFFFFFFFFFFB318	BE00000A		 	bra		ctxstart1
                  	           		 
                  	           		 ;	call	ramtest
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Hello World!
                  	           		 ;-----------------------------------------
FFFFFFFFFFFFB31C	           		 HelloWorld:
FFFFFFFFFFFFB31C	0FEF0018		 	subui	r30,r30,#24
FFFFFFFFFFFFB320	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFB324	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFB328	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFB32C	E6BFB360		; SETLO
FFFFFFFFFFFFB330	6A0D082D		 	lea		r2,MSG
FFFFFFFFFFFFB334	           		 j3:
FFFFFFFFFFFFB334	40208000		 	lb		r1,[r2]
FFFFFFFFFFFFB338	BE100088		 	beq		r1,r0,j2
FFFFFFFFFFFFB33C	31FFED0C		 	call	SerialPutChar
FFFFFFFFFFFFB340	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFB344	BE007F8A		 	bra		j3
FFFFFFFFFFFFB348	           		 j2:
FFFFFFFFFFFFB348	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFB34C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFB350	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFB354	37EF8018		 	ret		#24
                  	           		 
                  	           		 
FFFFFFFFFFFFB358 0000000000000000	 	align	16
FFFFFFFFFFFFB360	           		 	align	16
FFFFFFFFFFFFB360	           		 MSG:	
FFFFFFFFFFFFB360 6F57206F6C6C6548	 	db	"Hello World!",0
FFFFFFFFFFFFB36D	           		 MSGSTART:
FFFFFFFFFFFFB368 7061520021646C72	 	db	"Raptor64 system starting....",0
FFFFFFFFFFFFB370 7973203436726F74
FFFFFFFFFFFFB378 617473206D657473
FFFFFFFFFFFFB380 2E2E2E676E697472
                  	           		 
FFFFFFFFFFFFB388 000000000000002E	 	align 16
FFFFFFFFFFFFB390	           		 	align 16
                  	           		 
                  	           		 ;----------------------------------------------------------
                  	           		 ; Initialize programmable interrupt controller (PIC)
                  	           		 ;  0 = nmi
                  	           		 ;  1 = keyboard reset
                  	           		 ;  2 = 1000Hz pulse (context switcher)
                  	           		 ;  3 = 100Hz pulse (cursor flash)
                  	           		 ;  8 = uart
                  	           		 ; 13 = raster interrupt
                  	           		 ; 15 = keyboard char
                  	           		 ;----------------------------------------------------------
FFFFFFFFFFFFB390	           		 PICInit:
FFFFFFFFFFFFB390	E6BFB3AC		; SETLO
FFFFFFFFFFFFB394	6A0D042D		 	lea		r1,PICret
FFFFFFFFFFFFB398	66009030		 	sw		r1,TickIRQAddr
                  	           		 	; enable: raster irq,
FFFFFFFFFFFFB39C	E07FA00F		 	setlo	r1,#0xA00F	; enable nmi,kbd_rst,and kbd_irq
                  	           		 	; A10F enable serial IRQ
FFFFFFFFFFFFB3A0	E69C0FF2		; SETLO
FFFFFFFFFFFFB3A4	EE800003		; SETMID
FFFFFFFFFFFFB3A8	6A0D0429		 	outc	r1,PIC_IE
FFFFFFFFFFFFB3AC	           		 PICret:
FFFFFFFFFFFFB3AC	37EF8000		 	ret
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Serial port
                  	           		 ;==============================================================================
                  	           		 ;-----------------------------------------
                  	           		 ; Initialize the serial port
                  	           		 ;-----------------------------------------
                  	           		 ;
FFFFFFFFFFFFB3B0	           		 SerialInit:
FFFFFFFFFFFFB3B0	62001800		 	sc		r0,Uart_rxhead		; reset buffer indexes
FFFFFFFFFFFFB3B4	62001802		 	sc		r0,Uart_rxtail
FFFFFFFFFFFFB3B8	E04001F0		 	setlo	r1,#0x1f0
FFFFFFFFFFFFB3BC	62009810		 	sc		r1,Uart_foff		; set threshold for XOFF
FFFFFFFFFFFFB3C0	E0400010		 	setlo	r1,#0x010
FFFFFFFFFFFFB3C4	6200980E		 	sc		r1,Uart_fon			; set threshold for XON
FFFFFFFFFFFFB3C8	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB3CC	E69C0A04		; SETLO
FFFFFFFFFFFFB3D0	EE800003		; SETMID
FFFFFFFFFFFFB3D4	6A0D0428		 	outb	r1,UART_IE			; enable receive interrupt only
FFFFFFFFFFFFB3D8	60001809		 	sb		r0,Uart_rxrts		; no RTS/CTS signals available
FFFFFFFFFFFFB3DC	60001812		 	sb		r0,Uart_txrts		; no RTS/CTS signals available
FFFFFFFFFFFFB3E0	60001813		 	sb		r0,Uart_txdtr		; no DTR signals available
FFFFFFFFFFFFB3E4	6000180A		 	sb		r0,Uart_rxdtr		; no DTR signals available
FFFFFFFFFFFFB3E8	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB3EC	60009814		 	sb		r1,Uart_txxon		; for now
FFFFFFFFFFFFB3F0	37EF8000		 	ret
                  	           		 
                  	           		 ;---------------------------------------------------------------------------------
                  	           		 ; Get character directly from serial port. Blocks until a character is available.
                  	           		 ;---------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB3F4	           		 SerialGetCharDirect:
FFFFFFFFFFFFB3F4	           		 sgc1:
FFFFFFFFFFFFB3F4	E69C0A01		; SETLO
FFFFFFFFFFFFB3F8	EE800003		; SETMID
FFFFFFFFFFFFB3FC	6A0D0420		 	inb		r1,UART_LS		; uart status
FFFFFFFFFFFFB400	14108001		 	andi	r1,r1,#rxfull	; is there a char available ?
FFFFFFFFFFFFB404	BE107F88		 	beq		r1,r0,sgc1
FFFFFFFFFFFFB408	E69C0A00		; SETLO
FFFFFFFFFFFFB40C	EE800003		; SETMID
FFFFFFFFFFFFB410	6A0D0420		 	inb		r1,UART
FFFFFFFFFFFFB414	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------
                  	           		 ; Check for a character at the serial port
                  	           		 ; returns r1 = 1 if char available, 0 otherwise
                  	           		 ;------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB418	           		 SerialCheckForCharDirect:
FFFFFFFFFFFFB418	E69C0A01		; SETLO
FFFFFFFFFFFFB41C	EE800003		; SETMID
FFFFFFFFFFFFB420	6A0D0420		 	inb		r1,UART_LS		; uart status
FFFFFFFFFFFFB424	14108001		 	andi	r1,r1,#rxfull	; is there a char available ?
FFFFFFFFFFFFB428	04100439		 	sne		r1,r1,r0
FFFFFFFFFFFFB42C	37EF8000		 	ret
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Put character to serial port
                  	           		 ; r1 = char to put
                  	           		 ;-----------------------------------------
                  	           		 ;
FFFFFFFFFFFFB430	           		 SerialPutChar:
FFFFFFFFFFFFB430	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFB434	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFB438	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFB43C	67E20010		 	sw		r4,16[sp]
FFFFFFFFFFFFB440	67E28018		 	sw		r5,24[sp]
FFFFFFFFFFFFB444	E69C0A06		; SETLO
FFFFFFFFFFFFB448	EE800003		; SETMID
FFFFFFFFFFFFB44C	6A0D0820		 	inb		r2,UART_MC
FFFFFFFFFFFFB450	16210003		 	ori		r2,r2,#3		; assert DTR / RTS
FFFFFFFFFFFFB454	E69C0A06		; SETLO
FFFFFFFFFFFFB458	EE800003		; SETMID
FFFFFFFFFFFFB45C	6A0D0828		 	outb	r2,UART_MC
FFFFFFFFFFFFB460	40011812		 	lb		r2,Uart_txrts
FFFFFFFFFFFFB464	BE200168		 	beq		r2,r0,spcb1
FFFFFFFFFFFFB468	46021400		 	lw		r4,Milliseconds
FFFFFFFFFFFFB46C	E0C00064		 	setlo	r3,#100			; delay count (1 s)
FFFFFFFFFFFFB470	           		 spcb3:
FFFFFFFFFFFFB470	80011808		 	inb		r2,UART_MS
FFFFFFFFFFFFB474	1421000A		 	andi	r2,r2,#10		; is CTS asserted ?
FFFFFFFFFFFFB478	BE2000C9		 	bne		r2,r0,spcb1
FFFFFFFFFFFFB47C	46029400		 	lw		r5,Milliseconds
FFFFFFFFFFFFB480	BE42FF88		 	beq		r4,r5,spcb3
FFFFFFFFFFFFB484	02520009		 	mov		r4,r5
FFFFFFFFFFFFB488	BE01FF4F		 	loop	r3,spcb3
FFFFFFFFFFFFB48C	BE00046A		 	bra		spcabort
FFFFFFFFFFFFB490	           		 spcb1:
FFFFFFFFFFFFB490	40011813		 	lb		r2,Uart_txdtr
FFFFFFFFFFFFB494	BE200168		 	beq		r2,r0,spcb2
FFFFFFFFFFFFB498	46021400		 	lw		r4,Milliseconds
FFFFFFFFFFFFB49C	E0C00064		 	setlo	r3,#100			; delay count
FFFFFFFFFFFFB4A0	           		 spcb4:
FFFFFFFFFFFFB4A0	80011808		 	inb		r2,UART_MS
FFFFFFFFFFFFB4A4	14210014		 	andi	r2,r2,#20		; is DSR asserted ?
FFFFFFFFFFFFB4A8	BE2000C9		 	bne		r2,r0,spcb2
FFFFFFFFFFFFB4AC	46029400		 	lw		r5,Milliseconds
FFFFFFFFFFFFB4B0	BE42FF88		 	beq		r4,r5,spcb4
FFFFFFFFFFFFB4B4	02520009		 	mov		r4,r5
FFFFFFFFFFFFB4B8	BE01FF4F		 	loop	r3,spcb4
FFFFFFFFFFFFB4BC	BE0002EA		 	bra		spcabort
FFFFFFFFFFFFB4C0	           		 spcb2:	
FFFFFFFFFFFFB4C0	40011814		 	lb		r2,Uart_txxon
FFFFFFFFFFFFB4C4	BE2000C8		 	beq		r2,r0,spcb5
FFFFFFFFFFFFB4C8	           		 spcb6:
FFFFFFFFFFFFB4C8	40011815		 	lb		r2,Uart_txxonoff
FFFFFFFFFFFFB4CC	BE200088		 	beq		r2,r0,spcb5
FFFFFFFFFFFFB4D0	80021808		 	inb		r4,UART_MS
FFFFFFFFFFFFB4D4	14420080		 	andi	r4,r4,#0x80			; DCD ?
FFFFFFFFFFFFB4D8	BE407F89		 	bne		r4,r0,spcb6
FFFFFFFFFFFFB4DC	           		 spcb5:
FFFFFFFFFFFFB4DC	46021400		 	lw		r4,Milliseconds
FFFFFFFFFFFFB4E0	E0C00064		 	setlo	r3,#100				; wait up to 1s
FFFFFFFFFFFFB4E4	           		 spcb8:
FFFFFFFFFFFFB4E4	E69C0A01		; SETLO
FFFFFFFFFFFFB4E8	EE800003		; SETMID
FFFFFFFFFFFFB4EC	6A0D0820		 	inb		r2,UART_LS
FFFFFFFFFFFFB4F0	14210020		 	andi	r2,r2,#0x20			; tx not full ?
FFFFFFFFFFFFB4F4	BE2000C9		 	bne		r2,r0,spcb7
FFFFFFFFFFFFB4F8	46029400		 	lw		r5,Milliseconds
FFFFFFFFFFFFB4FC	BE42FF48		 	beq		r4,r5,spcb8
FFFFFFFFFFFFB500	02520009		 	mov		r4,r5
FFFFFFFFFFFFB504	BE01FF0F		 	loop	r3,spcb8
FFFFFFFFFFFFB508	BE00008A		 	bra		spcabort
FFFFFFFFFFFFB50C	           		 spcb7:
FFFFFFFFFFFFB50C	E69C0A00		; SETLO
FFFFFFFFFFFFB510	EE800003		; SETMID
FFFFFFFFFFFFB514	6A0D0428		 	outb	r1,UART
FFFFFFFFFFFFB518	           		 spcabort:
FFFFFFFFFFFFB518	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB51C	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFB520	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFB524	47E28018		 	lw		r5,24[sp]
FFFFFFFFFFFFB528	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;-------------------------------------------------
                  	           		 ; Compute number of characters in recieve buffer.
                  	           		 ; r4 = number of chars
                  	           		 ;-------------------------------------------------
FFFFFFFFFFFFB52C	           		 CharsInRxBuf:
FFFFFFFFFFFFB52C	42021800		 	lc		r4,Uart_rxhead
FFFFFFFFFFFFB530	42011802		 	lc		r2,Uart_rxtail
FFFFFFFFFFFFB534	04411005		 	subu	r4,r4,r2
FFFFFFFFFFFFB538	BE4000A3		 	bgt		r4,r0,cirxb1
FFFFFFFFFFFFB53C	E1000200		 	setlo	r4,#0x200
FFFFFFFFFFFFB540	04411003		 	addu	r4,r4,r2
FFFFFFFFFFFFB544	42011800		 	lc		r2,Uart_rxhead
FFFFFFFFFFFFB548	04411005		 	subu	r4,r4,r2
FFFFFFFFFFFFB54C	           		 cirxb1:
FFFFFFFFFFFFB54C	37EF8000		 	ret
                  	           		 
                  	           		 ;----------------------------------------------
                  	           		 ; Get character from rx fifo
                  	           		 ; If the fifo is empty enough then send an XON
                  	           		 ;----------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB550	           		 SerialGetChar:
FFFFFFFFFFFFB550	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFB554	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFB558	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFB55C	67E20010		 	sw		r4,16[sp]
FFFFFFFFFFFFB560	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFB564	42019800		 	lc		r3,Uart_rxhead
FFFFFFFFFFFFB568	42011802		 	lc		r2,Uart_rxtail
FFFFFFFFFFFFB56C	BE218528		 	beq		r2,r3,sgcfifo1	; is there a char available ?
FFFFFFFFFFFFB570	9A019600		 	lea		r3,Uart_rxfifo
FFFFFFFFFFFFB574	6A218400		 	lb		r1,[r2+r3]		; get the char from the fifo into r1
FFFFFFFFFFFFB578	0A210001		 	addui	r2,r2,#1		; increment the fifo pointer
FFFFFFFFFFFFB57C	142101FF		 	andi	r2,r2,#0x1ff
FFFFFFFFFFFFB580	62011802		 	sc		r2,Uart_rxtail
FFFFFFFFFFFFB584	4001180C		 	lb		r2,Uart_rxflow	; using flow control ?
FFFFFFFFFFFFB588	BE2003A8		 	beq		r2,r0,sgcfifo2
FFFFFFFFFFFFB58C	4201980E		 	lc		r3,Uart_fon		; enough space in Rx buffer ?
FFFFFFFFFFFFB590	31FFED4B		 	call	CharsInRxBuf
FFFFFFFFFFFFB594	BE418343		 	bgt		r4,r3,sgcfifo2
FFFFFFFFFFFFB598	6000180C		 	sb		r0,Uart_rxflow	; flow off
FFFFFFFFFFFFB59C	40021809		 	lb		r4,Uart_rxrts
FFFFFFFFFFFFB5A0	BE400108		 	beq		r4,r0,sgcfifo3
FFFFFFFFFFFFB5A4	E69C0A06		; SETLO
FFFFFFFFFFFFB5A8	EE800003		; SETMID
FFFFFFFFFFFFB5AC	6A0D1020		 	inb		r4,UART_MC		; set rts bit in MC
FFFFFFFFFFFFB5B0	16420002		 	ori		r4,r4,#2
FFFFFFFFFFFFB5B4	E69C0A06		; SETLO
FFFFFFFFFFFFB5B8	EE800003		; SETMID
FFFFFFFFFFFFB5BC	6A0D1028		 	outb	r4,UART_MC
FFFFFFFFFFFFB5C0	           		 sgcfifo3:
FFFFFFFFFFFFB5C0	4002180A		 	lb		r4,Uart_rxdtr
FFFFFFFFFFFFB5C4	BE400108		 	beq		r4,r0,sgcfifo4
FFFFFFFFFFFFB5C8	E69C0A06		; SETLO
FFFFFFFFFFFFB5CC	EE800003		; SETMID
FFFFFFFFFFFFB5D0	6A0D1020		 	inb		r4,UART_MC		; set DTR
FFFFFFFFFFFFB5D4	16420001		 	ori		r4,r4,#1
FFFFFFFFFFFFB5D8	E69C0A06		; SETLO
FFFFFFFFFFFFB5DC	EE800003		; SETMID
FFFFFFFFFFFFB5E0	6A0D1028		 	outb	r4,UART_MC
FFFFFFFFFFFFB5E4	           		 sgcfifo4:
FFFFFFFFFFFFB5E4	4002180B		 	lb		r4,Uart_rxxon
FFFFFFFFFFFFB5E8	BE4000A8		 	beq		r4,r0,sgcfifo5
FFFFFFFFFFFFB5EC	E1000011		 	setlo	r4,#XON
FFFFFFFFFFFFB5F0	E69C0A00		; SETLO
FFFFFFFFFFFFB5F4	EE800003		; SETMID
FFFFFFFFFFFFB5F8	6A0D1028		 	outb	r4,UART
FFFFFFFFFFFFB5FC	           		 sgcfifo5:
FFFFFFFFFFFFB5FC	           		 sgcfifo2:					; return with char in r1
FFFFFFFFFFFFB5FC	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB600	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFB604	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFB608	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFB60C	37EF8020		 	ret		#32
FFFFFFFFFFFFB610	           		 sgcfifo1:
FFFFFFFFFFFFB610	E07FFFFF		 	setlo	r1,#-1			; no char available
FFFFFFFFFFFFB614	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB618	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFB61C	47E20010		 	lw		r4,16[sp]
FFFFFFFFFFFFB620	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFB624	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Serial port IRQ
                  	           		 ;-----------------------------------------
                  	           		 ;
FFFFFFFFFFFFB628	           		 SerialIRQ:
FFFFFFFFFFFFB628	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFB62C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFB630	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFB634	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFB638	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFB63C	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFB640	E69C0A03		; SETLO
FFFFFFFFFFFFB644	EE800003		; SETMID
FFFFFFFFFFFFB648	6A0D0420		 	inb		r1,UART_IS		; get interrupt status
FFFFFFFFFFFFB64C	BE1000A1		 	bge		r1,r0,sirq1
FFFFFFFFFFFFB650	1410807F		 	andi	r1,r1,#0x7f		; switch on interrupt type
FFFFFFFFFFFFB654	B0100D04		 	beqi	r1,#4,srxirq
FFFFFFFFFFFFB658	B0100B0C		 	beqi	r1,#0xC,stxirq
FFFFFFFFFFFFB65C	B0100710		 	beqi	r1,#0x10,smsirq
FFFFFFFFFFFFB660	           		 sirq1:
FFFFFFFFFFFFB660	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFB664	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFB668	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFB66C	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFB670	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFB674	37EF8028		 	ret		#40
                  	           		 
                  	           		 ; Get the modem status and record it
FFFFFFFFFFFFB678	           		 smsirq:
FFFFFFFFFFFFB678	80009808		 	inb		r1,UART_MS
FFFFFFFFFFFFB67C	60009808		 	sb		r1,Uart_ms
FFFFFFFFFFFFB680	BE007F0A		 	bra		sirq1
                  	           		 
FFFFFFFFFFFFB684	           		 stxirq:
FFFFFFFFFFFFB684	BE007EEA		 	bra		sirq1
                  	           		 
                  	           		 ; Get a character from the uart and store it in the rx fifo
FFFFFFFFFFFFB688	           		 srxirq:
FFFFFFFFFFFFB688	           		 srxirq1:
FFFFFFFFFFFFB688	E69C0A00		; SETLO
FFFFFFFFFFFFB68C	EE800003		; SETMID
FFFFFFFFFFFFB690	6A0D0420		 	inb		r1,UART				; get the char (clears interrupt)
FFFFFFFFFFFFB694	40011814		 	lb		r2,Uart_txxon
FFFFFFFFFFFFB698	BE200108		 	beq		r2,r0,srxirq3
FFFFFFFFFFFFB69C	B2100413		 	bnei	r1,#XOFF,srxirq2
FFFFFFFFFFFFB6A0	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB6A4	60009815		 	sb		r1,Uart_txxonoff
FFFFFFFFFFFFB6A8	BE00016A		 	bra		srxirq5
FFFFFFFFFFFFB6AC	           		 srxirq2:
FFFFFFFFFFFFB6AC	B2100311		 	bnei	r1,#XON,srxirq3
FFFFFFFFFFFFB6B0	60001815		 	sb		r0,Uart_txxonoff
FFFFFFFFFFFFB6B4	BE00010A		 	bra		srxirq5
FFFFFFFFFFFFB6B8	           		 srxirq3:
FFFFFFFFFFFFB6B8	60001815		 	sb		r0,Uart_txxonoff
FFFFFFFFFFFFB6BC	42011800		 	lc		r2,Uart_rxhead
FFFFFFFFFFFFB6C0	9A019600		 	lea		r3,Uart_rxfifo
FFFFFFFFFFFFB6C4	6A310410		 	sb		r1,[r3+r2]			; store in buffer
FFFFFFFFFFFFB6C8	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFB6CC	142101FF		 	andi	r2,r2,#0x1ff
FFFFFFFFFFFFB6D0	62011800		 	sc		r2,Uart_rxhead
FFFFFFFFFFFFB6D4	           		 srxirq5:
FFFFFFFFFFFFB6D4	E69C0A01		; SETLO
FFFFFFFFFFFFB6D8	EE800003		; SETMID
FFFFFFFFFFFFB6DC	6A0D0420		 	inb		r1,UART_LS			; check for another ready character
FFFFFFFFFFFFB6E0	14108001		 	andi	r1,r1,#rxfull
FFFFFFFFFFFFB6E4	BE107D29		 	bne		r1,r0,srxirq1
FFFFFFFFFFFFB6E8	4000980C		 	lb		r1,Uart_rxflow		; are we using flow controls?
FFFFFFFFFFFFB6EC	BE1003C9		 	bne		r1,r0,srxirq8
FFFFFFFFFFFFB6F0	31FFED4B		 	call	CharsInRxBuf
FFFFFFFFFFFFB6F4	42009810		 	lc		r1,Uart_foff
FFFFFFFFFFFFB6F8	BE408360		 	blt		r4,r1,srxirq8
FFFFFFFFFFFFB6FC	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFB700	6000980C		 	sb		r1,Uart_rxflow
FFFFFFFFFFFFB704	40009809		 	lb		r1,Uart_rxrts
FFFFFFFFFFFFB708	BE100108		 	beq		r1,r0,srxirq6
FFFFFFFFFFFFB70C	E69C0A06		; SETLO
FFFFFFFFFFFFB710	EE800003		; SETMID
FFFFFFFFFFFFB714	6A0D0420		 	inb		r1,UART_MC
FFFFFFFFFFFFB718	141080FD		 	andi	r1,r1,#0xFD		; turn off RTS
FFFFFFFFFFFFB71C	E69C0A06		; SETLO
FFFFFFFFFFFFB720	EE800003		; SETMID
FFFFFFFFFFFFB724	6A0D0428		 	outb	r1,UART_MC
FFFFFFFFFFFFB728	           		 srxirq6:
FFFFFFFFFFFFB728	4000980A		 	lb		r1,Uart_rxdtr
FFFFFFFFFFFFB72C	BE100108		 	beq		r1,r0,srxirq7
FFFFFFFFFFFFB730	E69C0A06		; SETLO
FFFFFFFFFFFFB734	EE800003		; SETMID
FFFFFFFFFFFFB738	6A0D0420		 	inb		r1,UART_MC
FFFFFFFFFFFFB73C	141080FE		 	andi	r1,r1,#0xFE		; turn off DTR
FFFFFFFFFFFFB740	E69C0A06		; SETLO
FFFFFFFFFFFFB744	EE800003		; SETMID
FFFFFFFFFFFFB748	6A0D0428		 	outb	r1,UART_MC
FFFFFFFFFFFFB74C	           		 srxirq7:
FFFFFFFFFFFFB74C	4000980B		 	lb		r1,Uart_rxxon
FFFFFFFFFFFFB750	BE1000A8		 	beq		r1,r0,srxirq8
FFFFFFFFFFFFB754	E0400013		 	setlo	r1,#XOFF
FFFFFFFFFFFFB758	E69C0A00		; SETLO
FFFFFFFFFFFFB75C	EE800003		; SETMID
FFFFFFFFFFFFB760	6A0D0428		 	outb	r1,UART
FFFFFFFFFFFFB764	           		 srxirq8:
FFFFFFFFFFFFB764	BE0077EA		 	bra		sirq1
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Keyboard BIOS
                  	           		 ; BIOS interrupt #417
                  	           		 ;
                  	           		 ; Function in R1
                  	           		 ; 0 = initialize keyboard
                  	           		 ; 1 = set keyboard echo
                  	           		 ; 2 = get keyboard character
                  	           		 ; 3 = check for key available
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFB768	           		 KeybdSC:
FFFFFFFFFFFFB768	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFB76C	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFB770	B2100300		 	bnei	r1,#0,kbdsc1
FFFFFFFFFFFFB774	31FFEDEC		 	call	KeybdInit
FFFFFFFFFFFFB778	BE00016A		 	bra		kbdscRet
FFFFFFFFFFFFB77C	           		 kbdsc1:
FFFFFFFFFFFFB77C	B2100401		 	bnei	r1,#1,kbdsc2
FFFFFFFFFFFFB780	02208009		 	mov		r1,r2
FFFFFFFFFFFFB784	31FFEE06		 	call	SetKeyboardEcho
FFFFFFFFFFFFB788	BE0000EA		 	bra		kbdscRet
FFFFFFFFFFFFB78C	           		 kbdsc2:
FFFFFFFFFFFFB78C	B2100302		 	bnei	r1,#2,kbdsc3
FFFFFFFFFFFFB790	31FFEE08		 	call	KeybdGetChar
FFFFFFFFFFFFB794	BE00008A		 	bra		kbdscRet
FFFFFFFFFFFFB798	           		 kbdsc3:
FFFFFFFFFFFFB798	B2100303		 	bnei	r1,#3,kbdsc4
FFFFFFFFFFFFB79C	31FFEE1D		 	call	KeybdCheckForKey
FFFFFFFFFFFFB7A0	BE00002A		 	bra		kbdscRet
FFFFFFFFFFFFB7A4	           		 kbdsc4:
FFFFFFFFFFFFB7A4	           		 kbdscRet:
FFFFFFFFFFFFB7A4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFB7A8	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFB7AC	01800021		 	eret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Initialize keyboard
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFB7B0	           		 KeybdInit:
FFFFFFFFFFFFB7B0	60001450		 	sb		r0,KeybdHead
FFFFFFFFFFFFB7B4	60001451		 	sb		r0,KeybdTail
FFFFFFFFFFFFB7B8	E0400001		 	setlo	r1,#1			; turn on keyboard echo
FFFFFFFFFFFFB7BC	6000941C		 	sb		r1,KeybdEcho
FFFFFFFFFFFFB7C0	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Normal keyboard interrupt, the lowest priority interrupt in the system.
                  	           		 ; Grab the character from the keyboard device and store it in a buffer.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB7C4	           		 KeybdIRQ:
FFFFFFFFFFFFB7C4	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFB7C8	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFB7CC	4A009450		 	lbu		r1,KeybdHead
FFFFFFFFFFFFB7D0	1410800F		 	andi	r1,r1,#0x0f				; r1 = index into buffer
FFFFFFFFFFFFB7D4	           		 KeybdIRQa:
FFFFFFFFFFFFB7D4	E69C0000		; SETLO
FFFFFFFFFFFFB7D8	EE800003		; SETMID
FFFFFFFFFFFFB7DC	6A0D0821		 	inch	r2,KEYBD				; get keyboard character
FFFFFFFFFFFFB7E0	E69C0002		; SETLO
FFFFFFFFFFFFB7E4	EE800003		; SETMID
FFFFFFFFFFFFB7E8	6A0D0029		 	outc	r0,KEYBD+2				; clear keyboard strobe (turns off the IRQ)
FFFFFFFFFFFFB7EC	60111440		 	sb		r2,KeybdBuffer[r1]		; store character in buffer
FFFFFFFFFFFFB7F0	0A108001		 	addui	r1,r1,#1				; increment head index
FFFFFFFFFFFFB7F4	1410800F		 	andi	r1,r1,#0x0f
FFFFFFFFFFFFB7F8	60009450		 	sb		r1,KeybdHead
FFFFFFFFFFFFB7FC	           		 KeybdIRQb:
FFFFFFFFFFFFB7FC	4A011451		 	lbu		r2,KeybdTail			; check to see if we've collided
FFFFFFFFFFFFB800	BE110089		 	bne		r1,r2,KeybdIRQc			; with the tail
FFFFFFFFFFFFB804	0A210001		 	addui	r2,r2,#1				; if so, increment the tail index
FFFFFFFFFFFFB808	1421000F		 	andi	r2,r2,#0x0f				; the oldest character will be lost
FFFFFFFFFFFFB80C	60011451		 	sb		r2,KeybdTail
FFFFFFFFFFFFB810	           		 KeybdIRQc:
FFFFFFFFFFFFB810	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB814	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; r1 0=echo off, non-zero = echo on
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFB818	           		 SetKeyboardEcho:
FFFFFFFFFFFFB818	6000941C		 	sb		r1,KeybdEcho
FFFFFFFFFFFFB81C	37EF8000		 	ret
                  	           		 
                  	           		 ;-----------------------------------------
                  	           		 ; Get character from keyboard buffer
                  	           		 ;-----------------------------------------
FFFFFFFFFFFFB820	           		 KeybdGetChar:
FFFFFFFFFFFFB820	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFB824	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFB828	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFB82C	4A011451		 	lbu		r2,KeybdTail
FFFFFFFFFFFFB830	4A009450		 	lbu		r1,KeybdHead
FFFFFFFFFFFFB834	BE110188		 	beq		r1,r2,nochar
FFFFFFFFFFFFB838	4A209440		 	lbu		r1,KeybdBuffer[r2]
FFFFFFFFFFFFB83C	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFB840	1421000F		 	andi	r2,r2,#0x0f
FFFFFFFFFFFFB844	60011451		 	sb		r2,KeybdTail
FFFFFFFFFFFFB848	4001141C		 	lb		r2,KeybdEcho
FFFFFFFFFFFFB84C	BE2000E8		 	beq		r2,r0,kgc3
FFFFFFFFFFFFB850	B210030D		 	bnei	r1,#CR,kgc2
FFFFFFFFFFFFB854	31FFF93F		 	call	CRLF			; convert CR keystroke into CRLF
FFFFFFFFFFFFB858	BE00008A		 	bra		kgc3
FFFFFFFFFFFFB85C	           		 kgc2:
FFFFFFFFFFFFB85C	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFB860	BE00004A		 	bra		kgc3
FFFFFFFFFFFFB864	           		 nochar:
FFFFFFFFFFFFB864	E07FFFFF		 	setlo	r1,#-1
FFFFFFFFFFFFB868	           		 kgc3:
FFFFFFFFFFFFB868	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFB86C	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB870	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Check if there is a keyboard character available in the keyboard buffer.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB874	           		 KeybdCheckForKey:
FFFFFFFFFFFFB874	4A009451		 	lbu		r1,KeybdTail
FFFFFFFFFFFFB878	4A011450		 	lbu		r2,KeybdHead
FFFFFFFFFFFFB87C	04110439		 	sne		r1,r1,r2
FFFFFFFFFFFFB880	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Check if there is a keyboard character available. If so return true (1)
                  	           		 ; otherwise return false (0) in r1.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB884	           		 KeybdCheckForKeyDirect:
FFFFFFFFFFFFB884	E69C0000		; SETLO
FFFFFFFFFFFFB888	EE800003		; SETMID
FFFFFFFFFFFFB88C	6A0D0421		 	inch	r1,KEYBD
FFFFFFFFFFFFB890	04100430		 	slt		r1,r1,r0
FFFFFFFFFFFFB894	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Get character directly from keyboard. This routine blocks until a key is
                  	           		 ; available.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB898	           		 KeybdGetCharDirect:
FFFFFFFFFFFFB898	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFB89C	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFB8A0	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFB8A4	E09C0000		 	setlo	r2,KEYBD
FFFFFFFFFFFFB8A8	           		 kgc1:
FFFFFFFFFFFFB8A8	E69C0000		; SETLO
FFFFFFFFFFFFB8AC	EE800003		; SETMID
FFFFFFFFFFFFB8B0	6A0D0421		 	inch	r1,KEYBD
FFFFFFFFFFFFB8B4	BE107FA1		 	bge		r1,r0,kgc1
FFFFFFFFFFFFB8B8	E69C0002		; SETLO
FFFFFFFFFFFFB8BC	EE800003		; SETMID
FFFFFFFFFFFFB8C0	6A0D0029		 	outc	r0,KEYBD+2		; clear keyboard strobe
FFFFFFFFFFFFB8C4	141080FF		 	andi	r1,r1,#0xff		; remove strobe bit
FFFFFFFFFFFFB8C8	4001141C		 	lb		r2,KeybdEcho	; is keyboard echo on ?
FFFFFFFFFFFFB8CC	BE2000A8		 	beq		r2,r0,gk1
FFFFFFFFFFFFB8D0	B210030D		 	bnei	r1,#'\r',gk2	; convert CR keystroke into CRLF
FFFFFFFFFFFFB8D4	31FFF93F		 	call	CRLF
FFFFFFFFFFFFB8D8	BE00004A		 	bra		gk1
FFFFFFFFFFFFB8DC	           		 gk2:
FFFFFFFFFFFFB8DC	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFB8E0	           		 gk1:
FFFFFFFFFFFFB8E0	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFB8E4	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFB8E8	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; 100 Hz interrupt
                  	           		 ; - takes care of "flashing" the cursor
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFB8EC	           		 Pulse100:
FFFFFFFFFFFFB8EC	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFB8F0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFB8F4	E6900000		; SETLO
FFFFFFFFFFFFB8F8	EE800003		; SETMID
FFFFFFFFFFFFB8FC	6A0D082D		 	lea		r2,TEXTSCR
FFFFFFFFFFFFB900	8220814E		 	inch	r1,334[r2]
FFFFFFFFFFFFB904	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFB908	9220814E		 	outc	r1,334[r2]
FFFFFFFFFFFFB90C	31FFF2D8		 	call	DisplayDatetime
FFFFFFFFFFFFB910	31FFEE4A		 	call	SelectNextToRunTCB
FFFFFFFFFFFFB914	31FFEE4C		 	call	SwitchTask
FFFFFFFFFFFFB918	E6BF0010		; SETLO
FFFFFFFFFFFFB91C	6A0D0010		 	sb		r0,0xFFFF_FFFF_FFFF_0010	; clear interrupt
                  	           		 ;	lw		r1,TickIRQAddr
                  	           		 ;	jal		r31,[r1]
                  	           		 ;	lw		r1,Milliseconds
                  	           		 ;	andi	r1,r1,#0x0f
                  	           		 ;	bnei	r1,#5,p1001
                  	           		 ;	call	FlashCursor
FFFFFFFFFFFFB920	           		 p1001:
FFFFFFFFFFFFB920	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFB924	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFB928	           		 SelectNextToRunTCB:
FFFFFFFFFFFFB928	620020A8		 	sc		r0,NextToRunTCB
FFFFFFFFFFFFB92C	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Switch from the RunningTCB to the NextToRunTCB
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFB930	           		 SwitchTask:
FFFFFFFFFFFFB930	6600A0B0		 	sw		r1,r1save
FFFFFFFFFFFFB934	660120B8		 	sw		r2,r2save
FFFFFFFFFFFFB938	4C00A0A8		 	lcu		r1,NextToRunTCB
FFFFFFFFFFFFB93C	4C0120A6		 	lcu		r2,RunningTCB
FFFFFFFFFFFFB940	BE110089		 	bne		r1,r2,swtsk1		; are we already running this TCB ?
FFFFFFFFFFFFB944	4600A0B0		 	lw		r1,r1save
FFFFFFFFFFFFB948	460120B8		 	lw		r2,r2save
FFFFFFFFFFFFB94C	37EF8000		 	ret
FFFFFFFFFFFFB950	           		 swtsk1:
FFFFFFFFFFFFB950	142101FF		 	andi	r2,r2,#0x1ff		; max 512 TCB's
FFFFFFFFFFFFB954	1A210200		 	mului	r2,r2,#TCBSize
FFFFFFFFFFFFB958	E6800000		; SETLO
FFFFFFFFFFFFB95C	EE800400		; SETMID
FFFFFFFFFFFFB960	042D0803		 	addui	r2,r2,#TCBBase
FFFFFFFFFFFFB964	4600A0B0		 	lw		r1,r1save			; get back r1
FFFFFFFFFFFFB968	66208000		 	sw		r1,TCBr1[r2]
FFFFFFFFFFFFB96C	4600A0B8		 	lw		r1,r2save			; get back r2
FFFFFFFFFFFFB970	66208008		 	sw		r1,TCBr2[r2]
FFFFFFFFFFFFB974	66218010		 	sw		r3,TCBr3[r2]
FFFFFFFFFFFFB978	66220018		 	sw		r4,TCBr4[r2]
FFFFFFFFFFFFB97C	66228020		 	sw		r5,TCBr5[r2]
FFFFFFFFFFFFB980	66230028		 	sw		r6,TCBr6[r2]
FFFFFFFFFFFFB984	66238030		 	sw		r7,TCBr7[r2]
FFFFFFFFFFFFB988	66240038		 	sw		r8,TCBr8[r2]
FFFFFFFFFFFFB98C	66248040		 	sw		r9,TCBr9[r2]
FFFFFFFFFFFFB990	66250048		 	sw		r10,TCBr10[r2]
FFFFFFFFFFFFB994	66258050		 	sw		r11,TCBr11[r2]
FFFFFFFFFFFFB998	66260058		 	sw		r12,TCBr12[r2]
FFFFFFFFFFFFB99C	66268060		 	sw		r13,TCBr13[r2]
FFFFFFFFFFFFB9A0	66270068		 	sw		r14,TCBr14[r2]
FFFFFFFFFFFFB9A4	66278070		 	sw		r15,TCBr15[r2]
FFFFFFFFFFFFB9A8	66280078		 	sw		r16,TCBr16[r2]
FFFFFFFFFFFFB9AC	66288080		 	sw		r17,TCBr17[r2]
FFFFFFFFFFFFB9B0	66290088		 	sw		r18,TCBr18[r2]
FFFFFFFFFFFFB9B4	66298090		 	sw		r19,TCBr19[r2]
FFFFFFFFFFFFB9B8	662A0098		 	sw		r20,TCBr20[r2]
FFFFFFFFFFFFB9BC	662A80A0		 	sw		r21,TCBr21[r2]
FFFFFFFFFFFFB9C0	662B00A8		 	sw		r22,TCBr22[r2]
FFFFFFFFFFFFB9C4	662B80B0		 	sw		r23,TCBr23[r2]
FFFFFFFFFFFFB9C8	662C00B8		 	sw		r24,TCBr24[r2]
FFFFFFFFFFFFB9CC	662C80C0		 	sw		r25,TCBr25[r2]
FFFFFFFFFFFFB9D0	662D00C8		 	sw		r26,TCBr26[r2]
FFFFFFFFFFFFB9D4	662D80D0		 	sw		r27,TCBr27[r2]
FFFFFFFFFFFFB9D8	662E00D8		 	sw		r28,TCBr28[r2]
FFFFFFFFFFFFB9DC	662E80E0		 	sw		r29,TCBr29[r2]
FFFFFFFFFFFFB9E0	662F00E8		 	sw		r30,TCBr30[r2]
FFFFFFFFFFFFB9E4	662F80F0		 	sw		r31,TCBr31[r2]
                  	           		 
FFFFFFFFFFFFB9E8	4C0120A8		 	lcu		r2,NextToRunTCB
FFFFFFFFFFFFB9EC	620120A6		 	sc		r2,RunningTCB
FFFFFFFFFFFFB9F0	1A210200		 	mului	r2,r2,#TCBSize
FFFFFFFFFFFFB9F4	E6800000		; SETLO
FFFFFFFFFFFFB9F8	EE800400		; SETMID
FFFFFFFFFFFFB9FC	042D0803		 	addui	r2,r2,#TCBBase
                  	           		 
FFFFFFFFFFFFBA00	46208000		 	lw		r1,TCBr1[r2]
FFFFFFFFFFFFBA04	46218010		 	lw		r3,TCBr3[r2]
FFFFFFFFFFFFBA08	46220018		 	lw		r4,TCBr4[r2]
FFFFFFFFFFFFBA0C	46228020		 	lw		r5,TCBr5[r2]
FFFFFFFFFFFFBA10	46230028		 	lw		r6,TCBr6[r2]
FFFFFFFFFFFFBA14	46238030		 	lw		r7,TCBr7[r2]
FFFFFFFFFFFFBA18	46240038		 	lw		r8,TCBr8[r2]
FFFFFFFFFFFFBA1C	46248040		 	lw		r9,TCBr9[r2]
FFFFFFFFFFFFBA20	46250048		 	lw		r10,TCBr10[r2]
FFFFFFFFFFFFBA24	46258050		 	lw		r11,TCBr11[r2]
FFFFFFFFFFFFBA28	46260058		 	lw		r12,TCBr12[r2]
FFFFFFFFFFFFBA2C	46268060		 	lw		r13,TCBr13[r2]
FFFFFFFFFFFFBA30	46270068		 	lw		r14,TCBr14[r2]
FFFFFFFFFFFFBA34	46278070		 	lw		r15,TCBr15[r2]
FFFFFFFFFFFFBA38	46280078		 	lw		r16,TCBr16[r2]
FFFFFFFFFFFFBA3C	46288080		 	lw		r17,TCBr17[r2]
FFFFFFFFFFFFBA40	46290088		 	lw		r18,TCBr18[r2]
FFFFFFFFFFFFBA44	46298090		 	lw		r19,TCBr19[r2]
FFFFFFFFFFFFBA48	462A0098		 	lw		r20,TCBr20[r2]
FFFFFFFFFFFFBA4C	462A80A0		 	lw		r21,TCBr21[r2]
FFFFFFFFFFFFBA50	462B00A8		 	lw		r22,TCBr22[r2]
FFFFFFFFFFFFBA54	462B80B0		 	lw		r23,TCBr23[r2]
FFFFFFFFFFFFBA58	462C00B8		 	lw		r24,TCBr24[r2]
FFFFFFFFFFFFBA5C	462C80C0		 	lw		r25,TCBr25[r2]
FFFFFFFFFFFFBA60	462D00C8		 	lw		r26,TCBr26[r2]
FFFFFFFFFFFFBA64	462D80D0		 	lw		r27,TCBr27[r2]
FFFFFFFFFFFFBA68	462E00D8		 	lw		r28,TCBr28[r2]
FFFFFFFFFFFFBA6C	462E80E0		 	lw		r29,TCBr29[r2]
FFFFFFFFFFFFBA70	462F00E8		 	lw		r30,TCBr30[r2]
FFFFFFFFFFFFBA74	462F80F0		 	lw		r31,TCBr31[r2]
FFFFFFFFFFFFBA78	46210008		 	lw		r2,TCBr2[r2]
FFFFFFFFFFFFBA7C	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Flash Cursor
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBA80	           		 FlashCursor:
FFFFFFFFFFFFBA80	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBA84	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBA88	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBA8C	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBA90	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBA94	31FFEF37		 	call	CalcScreenLoc
FFFFFFFFFFFFBA98	E6810000		; SETLO
FFFFFFFFFFFFBA9C	041D0403		 	addui	r1,r1,#0x10000
FFFFFFFFFFFFBAA0	4001141A		 	lb		r2,CursorFlash
FFFFFFFFFFFFBAA4	BE2001C8		 	beq		r2,r0,flshcrsr2
                  	           		 	; causes screen colors to flip around
FFFFFFFFFFFFBAA8	82110000		 	inch	r2,[r1]
FFFFFFFFFFFFBAAC	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFBAB0	92110000		 	outc	r2,[r1]
FFFFFFFFFFFFBAB4	           		 flshcrsr3:
FFFFFFFFFFFFBAB4	46011408		 	lw		r2,Lastloc
FFFFFFFFFFFFBAB8	BE110088		 	beq		r1,r2,flshcrsr1
                  	           		 	; restore the screen colors of the previous cursor location
FFFFFFFFFFFFBABC	42019414		 	lc		r3,ScreenColor
FFFFFFFFFFFFBAC0	92218000		 	outc	r3,[r2]
FFFFFFFFFFFFBAC4	66009408		 	sw		r1,Lastloc
FFFFFFFFFFFFBAC8	           		 flshcrsr1:
FFFFFFFFFFFFBAC8	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBACC	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBAD0	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBAD4	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFBAD8	37EF8020		 	ret		#32
FFFFFFFFFFFFBADC	           		 flshcrsr2:
FFFFFFFFFFFFBADC	42019414		 	lc		r3,ScreenColor
FFFFFFFFFFFFBAE0	92118000		 	outc	r3,[r1]
FFFFFFFFFFFFBAE4	BE007E8A		 	bra		flshcrsr3
                  	           		 
FFFFFFFFFFFFBAE8	           		 CursorOff:
FFFFFFFFFFFFBAE8	160080A0		 	lw		r1,#0xA0
FFFFFFFFFFFFBAEC	E69A0010		; SETLO
FFFFFFFFFFFFBAF0	EE800003		; SETMID
FFFFFFFFFFFFBAF4	6A0D0429		 	outc	r1,TEXTREG+16		; turn off cursor
FFFFFFFFFFFFBAF8	37EF8000		 	ret
FFFFFFFFFFFFBAFC	           		 CursorOn:
FFFFFFFFFFFFBAFC	160080E0		 	lw		r1,#0xE0
FFFFFFFFFFFFBB00	E69A0010		; SETLO
FFFFFFFFFFFFBB04	EE800003		; SETMID
FFFFFFFFFFFFBB08	6A0D0429		 	outc	r1,TEXTREG+16		; turn on cursor
FFFFFFFFFFFFBB0C	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFBB10	           		 ClearBmpScreen:
FFFFFFFFFFFFBB10	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFBB14	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBB18	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBB1C	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBB20	E68FFC00		; SETLO
FFFFFFFFFFFFBB24	040D0809		 	lw		r2,#1364*768
FFFFFFFFFFFFBB28	06210601		 	shrui	r2,r2,#3			; r2 = # words to clear
FFFFFFFFFFFFBB2C	E6A92929		; SETLO
FFFFFFFFFFFFBB30	EEA4A4A4		; SETMID
FFFFFFFFFFFFBB34	F6829292		; SETHI
FFFFFFFFFFFFBB38	6A0D042D		 	lea		r1,0x2929292929292929	; r1 = color for eight pixels
FFFFFFFFFFFFBB3C	E6A00000		; SETLO
FFFFFFFFFFFFBB40	EE800400		; SETMID
FFFFFFFFFFFFBB44	6A0D0C2D		 	lea		r3,BITMAPSCR		; r3 = screen address
FFFFFFFFFFFFBB48	           		 csj4:
FFFFFFFFFFFFBB48	66308000		 	sw		r1,[r3]				; store pixel data
FFFFFFFFFFFFBB4C	0A318008		 	addui	r3,r3,#8			; advance screen address by eight
FFFFFFFFFFFFBB50	BE017FCF		 	loop	r2,csj4				; decrement pixel count and loop back
FFFFFFFFFFFFBB54	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBB58	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBB5C	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBB60	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Clear the screen and the screen color memory
                  	           		 ; We clear the screen to give a visual indication that the system
                  	           		 ; is working at all.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBB64	           		 ClearScreen:
FFFFFFFFFFFFBB64	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFBB68	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBB6C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBB70	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBB74	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFBB78	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFBB7C	E69A0000		; SETLO
FFFFFFFFFFFFBB80	EE800003		; SETMID
FFFFFFFFFFFFBB84	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFBB88	82308000		 	inch	r1,TEXT_COLS[r3]	; calc number to clear
FFFFFFFFFFFFBB8C	82310002		 	inch	r2,TEXT_ROWS[r3]
FFFFFFFFFFFFBB90	04110818		 	mulu	r2,r1,r2			; r2 = # chars to clear
FFFFFFFFFFFFBB94	E0400020		 	setlo	r1,#32			; space char
FFFFFFFFFFFFBB98	42021414		 	lc		r4,ScreenColor
FFFFFFFFFFFFBB9C	31FFEF2B		 	call	AsciiToScreen
FFFFFFFFFFFFBBA0	E6900000		; SETLO
FFFFFFFFFFFFBBA4	EE800003		; SETMID
FFFFFFFFFFFFBBA8	6A0D0C2D		 	lea		r3,TEXTSCR		; text screen address
FFFFFFFFFFFFBBAC	           		 csj4:
FFFFFFFFFFFFBBAC	92308000		 	outc	r1,[r3]
FFFFFFFFFFFFBBB0	E6810000		; SETLO
FFFFFFFFFFFFBBB4	6A3D1029		 	outc	r4,0x10000[r3]	; color screen is 0x10000 higher
FFFFFFFFFFFFBBB8	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFBBBC	BE017F8F		 	loop	r2,csj4
FFFFFFFFFFFFBBC0	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFBBC4	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFBBC8	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBBCC	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBBD0	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBBD4	37EF8028		 	ret		#40
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Scroll text on the screen upwards
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBBD8	           		 ScrollUp:
FFFFFFFFFFFFBBD8	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFBBDC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBBE0	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBBE4	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBBE8	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFBBEC	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFBBF0	E69A0000		; SETLO
FFFFFFFFFFFFBBF4	EE800003		; SETMID
FFFFFFFFFFFFBBF8	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFBBFC	82308000		 	inch	r1,TEXT_COLS[r3]	; r1 = # text columns
FFFFFFFFFFFFBC00	82310002		 	inch	r2,TEXT_ROWS[r3]
FFFFFFFFFFFFBC04	04110818		 	mulu	r2,r1,r2			; calc number of chars to scroll
FFFFFFFFFFFFBC08	04208805		 	subu	r2,r2,r1			; one less row
FFFFFFFFFFFFBC0C	E6900000		; SETLO
FFFFFFFFFFFFBC10	EE800003		; SETMID
FFFFFFFFFFFFBC14	6A0D0C2D		 	lea		r3,TEXTSCR
FFFFFFFFFFFFBC18	           		 scrup1:
FFFFFFFFFFFFBC18	6A309021		 	inch	r4,[r3+r1]			; indexed addressing example
FFFFFFFFFFFFBC1C	92320000		 	outc	r4,[r3]
FFFFFFFFFFFFBC20	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFBC24	BE017FAF		 	loop	r2,scrup1
                  	           		 
FFFFFFFFFFFFBC28	E69A0000		; SETLO
FFFFFFFFFFFFBC2C	EE800003		; SETMID
FFFFFFFFFFFFBC30	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFBC34	82308002		 	inch	r1,TEXT_ROWS[r3]
FFFFFFFFFFFFBC38	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFBC3C	31FFEF16		 	call	BlankLine
FFFFFFFFFFFFBC40	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBC44	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBC48	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBC4C	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFBC50	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFBC54	37EF8028		 	ret		#40
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Blank out a line on the display
                  	           		 ; line number to blank is in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBC58	           		 BlankLine:
FFFFFFFFFFFFBC58	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFBC5C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBC60	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBC64	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBC68	E69A0000		; SETLO
FFFFFFFFFFFFBC6C	EE800003		; SETMID
FFFFFFFFFFFFBC70	6A0D0C2D		 	lea		r3,TEXTREG			; r3 = text register address
FFFFFFFFFFFFBC74	82310000		 	inch	r2,TEXT_COLS[r3]	; r2 = # chars to blank out
FFFFFFFFFFFFBC78	04208C18		 	mulu	r3,r2,r1
FFFFFFFFFFFFBC7C	06318200		 	shli	r3,r3,#1
FFFFFFFFFFFFBC80	E6900000		; SETLO
FFFFFFFFFFFFBC84	EE800003		; SETMID
FFFFFFFFFFFFBC88	043D0C03		 	addui	r3,r3,#TEXTSCR		; r3 = screen address
FFFFFFFFFFFFBC8C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFBC90	           		 blnkln1:
FFFFFFFFFFFFBC90	92308000		 	outc	r1,[r3]
FFFFFFFFFFFFBC94	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFBC98	BE017FCF		 	loop	r2,blnkln1
FFFFFFFFFFFFBC9C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBCA0	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBCA4	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBCA8	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert ASCII character to screen display character.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBCAC	           		 AsciiToScreen:
FFFFFFFFFFFFBCAC	141080FF		 	andi	r1,r1,#0x00ff
FFFFFFFFFFFFBCB0	A8100541		 	bltui	r1,#'A',atoscr1
FFFFFFFFFFFFBCB4	AC10045A		 	bleui	r1,#'Z',atoscr1
FFFFFFFFFFFFBCB8	AE10037A		 	bgtui   r1,#'z',atoscr1
FFFFFFFFFFFFBCBC	A8100261		 	bltui	r1,#'a',atoscr1
FFFFFFFFFFFFBCC0	0C108060		 	subi	r1,r1,#0x60
FFFFFFFFFFFFBCC4	           		 atoscr1:
FFFFFFFFFFFFBCC4	16108100		 	ori		r1,r1,#0x100
FFFFFFFFFFFFBCC8	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert screen character to ascii character
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBCCC	           		 ScreenToAscii:
FFFFFFFFFFFFBCCC	141080FF		 	andi	r1,r1,#0xff
FFFFFFFFFFFFBCD0	AE10021A		 	bgtui	r1,#26,stasc1
FFFFFFFFFFFFBCD4	0A10803C		 	addui	r1,r1,#60
FFFFFFFFFFFFBCD8	           		 stasc1:
FFFFFFFFFFFFBCD8	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Calculate screen memory location from CursorRow,CursorCol.
                  	           		 ; Also refreshes the cursor location.
                  	           		 ; Destroys r1,r2,r3
                  	           		 ; r1 = screen location
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBCDC	           		 CalcScreenLoc:
FFFFFFFFFFFFBCDC	42009416		 	lc		r1,CursorRow
FFFFFFFFFFFFBCE0	1410807F		 	andi	r1,r1,#0x7f
FFFFFFFFFFFFBCE4	E69A0000		; SETLO
FFFFFFFFFFFFBCE8	EE800003		; SETMID
FFFFFFFFFFFFBCEC	6A0D0C2D		 	lea		r3,TEXTREG
FFFFFFFFFFFFBCF0	82310000		 	inch	r2,TEXT_COLS[r3]
FFFFFFFFFFFFBCF4	04208818		 	mulu	r2,r2,r1
FFFFFFFFFFFFBCF8	42009418		 	lc		r1,CursorCol
FFFFFFFFFFFFBCFC	1410807F		 	andi	r1,r1,#0x7f
FFFFFFFFFFFFBD00	04208803		 	addu	r2,r2,r1
FFFFFFFFFFFFBD04	92310016		 	outc	r2,TEXT_CURPOS[r3]
FFFFFFFFFFFFBD08	06210200		 	shli	r2,r2,#1
FFFFFFFFFFFFBD0C	E6900000		; SETLO
FFFFFFFFFFFFBD10	EE800003		; SETMID
FFFFFFFFFFFFBD14	042D0403		 	addui	r1,r2,#TEXTSCR			; r1 = screen location
FFFFFFFFFFFFBD18	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display a character on the screen
                  	           		 ; d1.b = char to display
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBD1C	           		 DisplayChar:
FFFFFFFFFFFFBD1C	B210080D		 	bnei	r1,#'\r',dccr		; carriage return ?
FFFFFFFFFFFFBD20	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBD24	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBD28	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBD2C	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBD30	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBD34	62001418		 	sc		r0,CursorCol		; just set cursor column to zero on a CR
FFFFFFFFFFFFBD38	BE00018A		 	bra		dcx7
FFFFFFFFFFFFBD3C	           		 dccr:
FFFFFFFFFFFFBD3C	E6800091		; SETLO
FFFFFFFFFFFFBD40	BE1D0209		 	bnei	r1,#0x91,dcx6		; cursor right ?
FFFFFFFFFFFFBD44	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBD48	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBD4C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBD50	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBD54	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBD58	42011418		 	lc		r2,CursorCol
FFFFFFFFFFFFBD5C	B0200338		 	beqi	r2,#56,dcx7
FFFFFFFFFFFFBD60	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFBD64	62011418		 	sc		r2,CursorCol
FFFFFFFFFFFFBD68	           		 dcx7:
FFFFFFFFFFFFBD68	31FFEF37		 	call	CalcScreenLoc
FFFFFFFFFFFFBD6C	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFBD70	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBD74	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBD78	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBD7C	37EF8020		 	ret		#32
FFFFFFFFFFFFBD80	           		 dcx6:
FFFFFFFFFFFFBD80	E6800090		; SETLO
FFFFFFFFFFFFBD84	BE1D0169		 	bnei	r1,#0x90,dcx8		; cursor up ?
FFFFFFFFFFFFBD88	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBD8C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBD90	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBD94	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBD98	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBD9C	42011416		 	lc		r2,CursorRow
FFFFFFFFFFFFBDA0	B02FF200		 	beqi	r2,#0,dcx7
FFFFFFFFFFFFBDA4	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFBDA8	62011416		 	sc		r2,CursorRow
FFFFFFFFFFFFBDAC	BE007DEA		 	bra		dcx7
FFFFFFFFFFFFBDB0	           		 dcx8:
FFFFFFFFFFFFBDB0	E6800093		; SETLO
FFFFFFFFFFFFBDB4	BE1D0169		 	bnei	r1,#0x93,dcx9		; cursor left ?
FFFFFFFFFFFFBDB8	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBDBC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBDC0	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBDC4	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBDC8	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBDCC	42011418		 	lc		r2,CursorCol
FFFFFFFFFFFFBDD0	B02FE600		 	beqi	r2,#0,dcx7
FFFFFFFFFFFFBDD4	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFBDD8	62011418		 	sc		r2,CursorCol
FFFFFFFFFFFFBDDC	BE007C6A		 	bra		dcx7
FFFFFFFFFFFFBDE0	           		 dcx9:
FFFFFFFFFFFFBDE0	E6800092		; SETLO
FFFFFFFFFFFFBDE4	BE1D0169		 	bnei	r1,#0x92,dcx10		; cursor down ?
FFFFFFFFFFFFBDE8	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBDEC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBDF0	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBDF4	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBDF8	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBDFC	42011416		 	lc		r2,CursorRow
FFFFFFFFFFFFBE00	B02FDA1E		 	beqi	r2,#30,dcx7
FFFFFFFFFFFFBE04	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFBE08	62011416		 	sc		r2,CursorRow
FFFFFFFFFFFFBE0C	BE007AEA		 	bra		dcx7
FFFFFFFFFFFFBE10	           		 dcx10:
FFFFFFFFFFFFBE10	E6800094		; SETLO
FFFFFFFFFFFFBE14	BE1D0189		 	bnei	r1,#0x94,dcx11			; cursor home ?
FFFFFFFFFFFFBE18	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBE1C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBE20	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBE24	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBE28	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBE2C	42011418		 	lc		r2,CursorCol
FFFFFFFFFFFFBE30	BE200068		 	beq		r2,r0,dcx12
FFFFFFFFFFFFBE34	62001418		 	sc		r0,CursorCol
FFFFFFFFFFFFBE38	BE00798A		 	bra		dcx7
FFFFFFFFFFFFBE3C	           		 dcx12:
FFFFFFFFFFFFBE3C	62001416		 	sc		r0,CursorRow
FFFFFFFFFFFFBE40	BE00794A		 	bra		dcx7
FFFFFFFFFFFFBE44	           		 dcx11:
FFFFFFFFFFFFBE44	0FEF0030		 	subui	sp,sp,#48
FFFFFFFFFFFFBE48	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBE4C	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBE50	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBE54	67E20018		 	sw		r4,24[sp]
FFFFFFFFFFFFBE58	67E28020		 	sw		r5,32[sp]
FFFFFFFFFFFFBE5C	67EF8028		 	sw		lr,40[sp]
FFFFFFFFFFFFBE60	E6800099		; SETLO
FFFFFFFFFFFFBE64	BE1D00A9		 	bnei	r1,#0x99,dcx13		; delete ?
FFFFFFFFFFFFBE68	31FFEF37		 	call	CalcScreenLoc
FFFFFFFFFFFFBE6C	04008C09		 	or		r3,r0,r1			; r3 = screen location
FFFFFFFFFFFFBE70	42009418		 	lc		r1,CursorCol		; r1 = cursor column
FFFFFFFFFFFFBE74	BE00012A		 	bra		dcx5
FFFFFFFFFFFFBE78	           		 dcx13:
FFFFFFFFFFFFBE78	B2101508		 	bnei	r1,#CTRLH,dcx3		; backspace ?
FFFFFFFFFFFFBE7C	42011418		 	lc		r2,CursorCol
FFFFFFFFFFFFBE80	BE2003A8		 	beq		r2,r0,dcx4
FFFFFFFFFFFFBE84	0E210001		 	subui	r2,r2,#1
FFFFFFFFFFFFBE88	62011418		 	sc		r2,CursorCol
FFFFFFFFFFFFBE8C	31FFEF37		 	call	CalcScreenLoc		; a0 = screen location
FFFFFFFFFFFFBE90	04008C09		 	or		r3,r0,r1			; r3 = screen location
FFFFFFFFFFFFBE94	42009418		 	lc		r1,CursorCol
FFFFFFFFFFFFBE98	           		 dcx5:
FFFFFFFFFFFFBE98	82310002		 	inch	r2,2[r3]
FFFFFFFFFFFFBE9C	92310000		 	outc	r2,[r3]
FFFFFFFFFFFFBEA0	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFBEA4	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFBEA8	E69A0000		; SETLO
FFFFFFFFFFFFBEAC	EE800003		; SETMID
FFFFFFFFFFFFBEB0	6A0D102D		 	lea		r4,TEXTREG
FFFFFFFFFFFFBEB4	82428000		 	inch	r5,TEXT_COLS[r4]
FFFFFFFFFFFFBEB8	BE12FF04		 	bltu	r1,r5,dcx5
FFFFFFFFFFFFBEBC	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFBEC0	31FFEF2B		 	call	AsciiToScreen
FFFFFFFFFFFFBEC4	9230FFFE		 	outc	r1,-2[r3]
FFFFFFFFFFFFBEC8	BE00016A		 	bra		dcx4
FFFFFFFFFFFFBECC	           		 dcx3:
FFFFFFFFFFFFBECC	B010090A		 	beqi	r1,#'\n',dclf	; linefeed ?
FFFFFFFFFFFFBED0	04009009		 	or		r4,r0,r1		; save r1 in r4
FFFFFFFFFFFFBED4	31FFEF37		 	call	CalcScreenLoc	; r1 = screen location
FFFFFFFFFFFFBED8	04008C09		 	or		r3,r0,r1		; r3 = screen location
FFFFFFFFFFFFBEDC	04020409		 	or		r1,r0,r4		; restore r1
FFFFFFFFFFFFBEE0	31FFEF2B		 	call	AsciiToScreen	; convert ascii char to screen char
FFFFFFFFFFFFBEE4	92308000		 	outc	r1,[r3]
FFFFFFFFFFFFBEE8	31FFEFC4		 	call	IncCursorPos
FFFFFFFFFFFFBEEC	BE00004A		 	bra		dcx4
FFFFFFFFFFFFBEF0	           		 dclf:
FFFFFFFFFFFFBEF0	31FFEFD2		 	call	IncCursorRow
FFFFFFFFFFFFBEF4	           		 dcx4:
FFFFFFFFFFFFBEF4	47EF8028		 	lw		lr,40[sp]
FFFFFFFFFFFFBEF8	47E28020		 	lw		r5,32[sp]
FFFFFFFFFFFFBEFC	47E20018		 	lw		r4,24[sp]
FFFFFFFFFFFFBF00	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBF04	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBF08	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBF0C	37EF8030		 	ret		#48
                  	           		 
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Increment the cursor position, scroll the screen if needed.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBF10	           		 IncCursorPos:
FFFFFFFFFFFFBF10	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBF14	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBF18	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBF1C	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBF20	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBF24	42009418		 	lc		r1,CursorCol
FFFFFFFFFFFFBF28	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFBF2C	62009418		 	sc		r1,CursorCol
FFFFFFFFFFFFBF30	E69A0000		; SETLO
FFFFFFFFFFFFBF34	EE800003		; SETMID
FFFFFFFFFFFFBF38	6A0D0821		 	inch	r2,TEXTREG+TEXT_COLS
FFFFFFFFFFFFBF3C	BE110246		 	bleu	r1,r2,icc1
FFFFFFFFFFFFBF40	62001418		 	sc		r0,CursorCol		; column = 0
FFFFFFFFFFFFBF44	BE0000CA		 	bra		icr1
FFFFFFFFFFFFBF48	           		 IncCursorRow:
FFFFFFFFFFFFBF48	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFBF4C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBF50	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBF54	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFBF58	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFBF5C	           		 icr1:
FFFFFFFFFFFFBF5C	42009416		 	lc		r1,CursorRow
FFFFFFFFFFFFBF60	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFBF64	62009416		 	sc		r1,CursorRow
FFFFFFFFFFFFBF68	E69A0002		; SETLO
FFFFFFFFFFFFBF6C	EE800003		; SETMID
FFFFFFFFFFFFBF70	6A0D0821		 	inch	r2,TEXTREG+TEXT_ROWS
FFFFFFFFFFFFBF74	BE110086		 	bleu	r1,r2,icc1
FFFFFFFFFFFFBF78	0E210001		 	subui	r2,r2,#1			; backup the cursor row, we are scrolling up
FFFFFFFFFFFFBF7C	62011416		 	sc		r2,CursorRow
FFFFFFFFFFFFBF80	31FFEEF6		 	call	ScrollUp
FFFFFFFFFFFFBF84	           		 icc1:
FFFFFFFFFFFFBF84	31FFEF37		 	call	CalcScreenLoc
FFFFFFFFFFFFBF88	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFBF8C	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFBF90	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBF94	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBF98	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display a string on the screen.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFBF9C	           		 DisplayString:
FFFFFFFFFFFFBF9C	0DEF0018		 	subi	sp,sp,#24
FFFFFFFFFFFFBFA0	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBFA4	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFBFA8	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFBFAC	02110009		 	mov		r2,r1			; r2 = pointer to string
FFFFFFFFFFFFBFB0	           		 dspj1:
FFFFFFFFFFFFBFB0	4A208000		 	lbu		r1,[r2]			; move string char into r1
FFFFFFFFFFFFBFB4	0A210001		 	addui	r2,r2,#1		; increment pointer
FFFFFFFFFFFFBFB8	BE100068		 	beq		r1,r0,dsret		; is it end of string ?
FFFFFFFFFFFFBFBC	31FFEF47		 	call	DisplayChar		; display character
FFFFFFFFFFFFBFC0	BE007F8A		 	bra		dspj1			; go back for next character
FFFFFFFFFFFFBFC4	           		 dsret:
FFFFFFFFFFFFBFC4	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFBFC8	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFBFCC	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFBFD0	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFBFD4	           		 DisplayStringCRLF:
FFFFFFFFFFFFBFD4	0FEF0008		 	subui	r30,r30,#8
FFFFFFFFFFFFBFD8	67EF8000		 	sw		r31,[r30]
FFFFFFFFFFFFBFDC	31FFEFE7		 	call	DisplayString
FFFFFFFFFFFFBFE0	47EF8000		 	lw		r31,[r30]
FFFFFFFFFFFFBFE4	0BEF0008		 	addui	r30,r30,#8
                  	           		 
FFFFFFFFFFFFBFE8	           		 CRLF:
FFFFFFFFFFFFBFE8	0FEF0010		 	subui	r30,r30,#16
FFFFFFFFFFFFBFEC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFBFF0	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFBFF4	E040000D		 	setlo	r1,#'\r'
FFFFFFFFFFFFBFF8	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFBFFC	E040000A		 	setlo	r1,#'\n'
FFFFFFFFFFFFC000	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFC004	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC008	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC00C	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display nybble in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC010	           		 DisplayNybble:
FFFFFFFFFFFFC010	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC014	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC018	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC01C	1410800F		 	andi	r1,r1,#0x0F
FFFFFFFFFFFFC020	0A108030		 	addui	r1,r1,#'0'
FFFFFFFFFFFFC024	AC100239		 	bleui	r1,#'9',dispnyb1
FFFFFFFFFFFFC028	0A108007		 	addui	r1,r1,#7
FFFFFFFFFFFFC02C	           		 dispnyb1:
FFFFFFFFFFFFC02C	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFC030	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC034	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC038	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display the byte in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC03C	           		 DisplayByte:
FFFFFFFFFFFFC03C	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC040	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC044	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC048	06108804		 	rori	r1,r1,#4	
FFFFFFFFFFFFC04C	31FFF004		 	call	DisplayNybble
FFFFFFFFFFFFC050	06108802		 	roli	r1,r1,#4
FFFFFFFFFFFFC054	31FFF004		 	call	DisplayNybble
FFFFFFFFFFFFC058	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC05C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC060	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display the 64 bit word in r1
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC064	           		 DisplayWord:
FFFFFFFFFFFFC064	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC068	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC06C	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFC070	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC074	E0C00007		 	setlo	r3,#7
FFFFFFFFFFFFC078	           		 dspwd1:
FFFFFFFFFFFFC078	06109002		 	roli	r1,r1,#8
FFFFFFFFFFFFC07C	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFC080	BE01FFCF		 	loop	r3,dspwd1
FFFFFFFFFFFFC084	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC088	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFC08C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC090	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Display memory pointed to by r2.
                  	           		 ; destroys r1,r3
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC094	           		 DisplayMem:
FFFFFFFFFFFFC094	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC098	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC09C	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFC0A0	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC0A4	E040003A		 	setlo	r1,#':'
FFFFFFFFFFFFC0A8	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFC0AC	02208009		 	mov		r1,r2
FFFFFFFFFFFFC0B0	31FFF019		 	call	DisplayWord
FFFFFFFFFFFFC0B4	E0C00007		 	setlo	r3,#7
FFFFFFFFFFFFC0B8	           		 dspmem1:
FFFFFFFFFFFFC0B8	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFC0BC	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFC0C0	40208000		 	lb		r1,[r2]
FFFFFFFFFFFFC0C4	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFC0C8	0A210001		 	addui	r2,r2,#1
FFFFFFFFFFFFC0CC	BE01FF6F		 	loop	r3,dspmem1
FFFFFFFFFFFFC0D0	31FFEFFA		 	call	CRLF
FFFFFFFFFFFFC0D4	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC0D8	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFC0DC	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC0E0	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Converts binary number in r1 into BCD number in r2 and r1.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC0E4	           		 BinToBCD:
FFFFFFFFFFFFC0E4	0FEF0030		 	subui	sp,sp,#48
FFFFFFFFFFFFC0E8	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFC0EC	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFC0F0	67E28010		 	sw		r5,16[sp]
FFFFFFFFFFFFC0F4	67E30018		 	sw		r6,24[sp]
FFFFFFFFFFFFC0F8	67E38020		 	sw		r7,32[sp]
FFFFFFFFFFFFC0FC	67E40028		 	sw		r8,40[sp]
FFFFFFFFFFFFC100	E080000A		 	setlo	r2,#10
FFFFFFFFFFFFC104	E2000013		 	setlo	r8,#19		; number of digits to produce - 1
FFFFFFFFFFFFC108	           		 bta1:
FFFFFFFFFFFFC108	04110C1C		 	mod		r3,r1,r2
FFFFFFFFFFFFC10C	0631F800		 	shli	r3,r3,#60	; shift result to uppermost bits
FFFFFFFFFFFFC110	0653F800		 	shli	r7,r5,#60	; copy low order nybble of r5 to r4 topmost nybble
FFFFFFFFFFFFC114	06420801		 	shrui	r4,r4,#4
FFFFFFFFFFFFC118	04439009		 	or		r4,r4,r7
FFFFFFFFFFFFC11C	06528801		 	shrui	r5,r5,#4
FFFFFFFFFFFFC120	04519409		 	or		r5,r5,r3	; copy new bcd digit into uppermost bits of r5
FFFFFFFFFFFFC124	1C108000		 	divui	r1,r1,r2	; r1=r1/10
FFFFFFFFFFFFC128	BE047F0F		 	loop	r8,bta1
FFFFFFFFFFFFC12C	06426001		 	shrui	r4,r4,#48	; right align number in register
FFFFFFFFFFFFC130	06532000		 	shli	r6,r5,#16
FFFFFFFFFFFFC134	04431009		 	or		r4,r4,r6	; copy bits into r4
FFFFFFFFFFFFC138	0652E001		 	shrui	r5,r5,#48
FFFFFFFFFFFFC13C	02408009		 	mov		r1,r4
FFFFFFFFFFFFC140	02510009		 	mov		r2,r5
FFFFFFFFFFFFC144	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFC148	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFC14C	47E28010		 	lw		r5,16[sp]
FFFFFFFFFFFFC150	47E30018		 	lw		r6,24[sp]
FFFFFFFFFFFFC154	47E38020		 	lw		r7,32[sp]
FFFFFFFFFFFFC158	47E40028		 	lw		r8,40[sp]
FFFFFFFFFFFFC15C	37EF8030		 	ret		#48
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Converts BCD number in r1 into Ascii number in r2 and r1.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC160	           		 BCDToAscii:
FFFFFFFFFFFFC160	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFC164	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFC168	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFC16C	67E28010		 	sw		r5,16[sp]
FFFFFFFFFFFFC170	67E40018		 	sw		r8,24[sp]
FFFFFFFFFFFFC174	E200000F		 	setlo	r8,#15
FFFFFFFFFFFFC178	           		 bta2:
FFFFFFFFFFFFC178	1411000F		 	andi	r2,r1,#0x0F
FFFFFFFFFFFFC17C	16210030		 	ori		r2,r2,#0x30
FFFFFFFFFFFFC180	06217000		 	shli	r2,r2,#56
FFFFFFFFFFFFC184	06421001		 	shrui	r4,r4,#8
FFFFFFFFFFFFC188	0632F000		 	shli	r5,r3,#56
FFFFFFFFFFFFC18C	04429009		 	or		r4,r4,r5
FFFFFFFFFFFFC190	06319001		 	shrui	r3,r3,#8
FFFFFFFFFFFFC194	04310C09		 	or		r3,r3,r2
FFFFFFFFFFFFC198	06108801		 	shrui	r1,r1,#4
FFFFFFFFFFFFC19C	BE047EEF		 	loop	r8,bta2
FFFFFFFFFFFFC1A0	02408009		 	mov		r1,r4
FFFFFFFFFFFFC1A4	02310009		 	mov		r2,r3
FFFFFFFFFFFFC1A8	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFC1AC	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFC1B0	47E28010		 	lw		r5,16[sp]
FFFFFFFFFFFFC1B4	47E40018		 	lw		r8,24[sp]
FFFFFFFFFFFFC1B8	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert a binary number into a 20 character ascii string.
                  	           		 ; r1 = number to convert
                  	           		 ; r2 = address of string buffer
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC1BC	           		 BinToStr:
FFFFFFFFFFFFC1BC	0FEF0038		 	subui	sp,sp,#56
FFFFFFFFFFFFC1C0	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFC1C4	67E38008		 	sw		r7,8[sp]
FFFFFFFFFFFFC1C8	67E40010		 	sw		r8,16[sp]
FFFFFFFFFFFFC1CC	67E48018		 	sw		r9,24[sp]
FFFFFFFFFFFFC1D0	67E50020		 	sw		r10,32[sp]
FFFFFFFFFFFFC1D4	67E58028		 	sw		r11,40[sp]
FFFFFFFFFFFFC1D8	67EF8030		 	sw		lr,48[sp]
FFFFFFFFFFFFC1DC	02258009		 	mov		r11,r2
FFFFFFFFFFFFC1E0	31FFF039		 	call	BinToBCD
FFFFFFFFFFFFC1E4	02250009		 	mov		r10,r2	; save off r2
FFFFFFFFFFFFC1E8	31FFF058		 	call	BCDToAscii
FFFFFFFFFFFFC1EC	E2400001		 	setlo	r9,#1
FFFFFFFFFFFFC1F0	           		 btos3:
FFFFFFFFFFFFC1F0	E2000007		 	setlo	r8,#7
FFFFFFFFFFFFC1F4	           		 btos1:
FFFFFFFFFFFFC1F4	06938600		 	shli	r7,r9,#3
FFFFFFFFFFFFC1F8	0A738000		 	addui	r7,r7,r8
FFFFFFFFFFFFC1FC	0A738004		 	addui	r7,r7,#4
FFFFFFFFFFFFC200	141180FF		 	andi	r3,r1,#0xff
FFFFFFFFFFFFC204	6A758C10		 	sb		r3,[r7+r11]
FFFFFFFFFFFFC208	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFC20C	BE047F4F		 	loop	r8,btos1
FFFFFFFFFFFFC210	02208009		 	mov		r1,r2
FFFFFFFFFFFFC214	BE04FEEF		 	loop	r9,btos3
                  	           		 ; the last four digits
FFFFFFFFFFFFC218	02A08009		 	mov		r1,r10	; get back r2
FFFFFFFFFFFFC21C	31FFF058		 	call	BCDToAscii
FFFFFFFFFFFFC220	E2000003		 	setlo	r8,#3
FFFFFFFFFFFFC224	           		 btos2:
FFFFFFFFFFFFC224	141180FF		 	andi	r3,r1,#0xff
FFFFFFFFFFFFC228	6A858C10		 	sb		r3,[r8+r11]
FFFFFFFFFFFFC22C	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFC230	BE047FAF		 	loop	r8,btos2
FFFFFFFFFFFFC234	60B00014		 	sb		r0,20[r11]	; null terminate
FFFFFFFFFFFFC238	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFC23C	47E38008		 	lw		r7,8[sp]
FFFFFFFFFFFFC240	47E40010		 	lw		r8,16[sp]
FFFFFFFFFFFFC244	47E48018		 	lw		r9,24[sp]
FFFFFFFFFFFFC248	47E50020		 	lw		r10,32[sp]
FFFFFFFFFFFFC24C	47E58028		 	lw		r11,40[sp]
FFFFFFFFFFFFC250	47EF8030		 	lw		lr,48[sp]
FFFFFFFFFFFFC254	37EF8038		 	ret		#56
                  	           		 
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
FFFFFFFFFFFFC258	           		 Monitor:
FFFFFFFFFFFFC258	E6BEFFF8		; SETLO
FFFFFFFFFFFFC25C	6A0D782D		 	lea		sp,STACKTOP0	; top of stack; reset the stack pointer
FFFFFFFFFFFFC260	6000141C		 	sb		r0,KeybdEcho	; turn off keyboard echo
FFFFFFFFFFFFC264	           		 PromptLn:
FFFFFFFFFFFFC264	31FFEFFA		 	call	CRLF
FFFFFFFFFFFFC268	E0400024		 	setlo	r1,#'$'
FFFFFFFFFFFFC26C	31FFEF47		 	call	DisplayChar
                  	           		 
                  	           		 ; Get characters until a CR is keyed
                  	           		 ;
FFFFFFFFFFFFC270	           		 Prompt3:
FFFFFFFFFFFFC270	31FFEE08		 	call	KeybdGetChar
FFFFFFFFFFFFC274	B01FFFFF		 	beqi	r1,#-1,Prompt3	; wait for a character
FFFFFFFFFFFFC278	B010030D		 	beqi	r1,#CR,Prompt1
FFFFFFFFFFFFC27C	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFC280	BE007F8A		 	bra		Prompt3
                  	           		 
                  	           		 ; Process the screen line that the CR was keyed on
                  	           		 ;
FFFFFFFFFFFFC284	           		 Prompt1:
FFFFFFFFFFFFC284	62001418		 	sc		r0,CursorCol	; go back to the start of the line
FFFFFFFFFFFFC288	31FFEF37		 	call	CalcScreenLoc	; r1 = screen memory location
FFFFFFFFFFFFC28C	04100C09		 	or		r3,r1,r0
FFFFFFFFFFFFC290	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC294	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC298	31FFEF33		 	call	ScreenToAscii
FFFFFFFFFFFFC29C	B2100424		 	bnei	r1,#'$',Prompt2	; skip over '$' prompt character
FFFFFFFFFFFFC2A0	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC2A4	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC2A8	31FFEF33		 	call	ScreenToAscii
                  	           		 
                  	           		 ; Dispatch based on command character
                  	           		 ;
FFFFFFFFFFFFC2AC	           		 Prompt2:
FFFFFFFFFFFFC2AC	B010563A		 	beqi	r1,#':',Editmem		; $: - edit memory
FFFFFFFFFFFFC2B0	B0106344		 	beqi	r1,#'D',Dumpmem		; $D - dump memory
FFFFFFFFFFFFC2B4	B012EF42		 	beqi	r1,#'B',CSTART		; $B - start tiny basic
FFFFFFFFFFFFC2B8	B0105D4A		 	beqi	r1,#'J',ExecuteCode	; $J - execute code
FFFFFFFFFFFFC2BC	B010914C		 	beqi	r1,#'L',LoadS19		; $L - load S19 file
FFFFFFFFFFFFC2C0	B010153F		 	beqi	r1,#'?',DisplayHelp	; $? - display help
FFFFFFFFFFFFC2C4	B0100743		 	beqi	r1,#'C',TestCLS		; $C - clear screen
FFFFFFFFFFFFC2C8	B0100452		 	beqi	r1,#'R',RandomLinesCall
FFFFFFFFFFFFC2CC	B012B849		 	beqi	r1,#'I',Invaders
FFFFFFFFFFFFC2D0	B011A350		 	beqi	r1,#'P',Piano
FFFFFFFFFFFFC2D4	BE007C2A		 	bra		Monitor
                  	           		 
FFFFFFFFFFFFC2D8	           		 RandomLinesCall:
FFFFFFFFFFFFC2D8	31FFF1BC		 	call	RandomLines
FFFFFFFFFFFFC2DC	BE007BEA		 	bra		Monitor
                  	           		 
FFFFFFFFFFFFC2E0	           		 TestCLS:
FFFFFFFFFFFFC2E0	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC2E4	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC2E8	31FFEF33		 	call	ScreenToAscii
FFFFFFFFFFFFC2EC	B21FDB4C		 	bnei	r1,#'L',Monitor
FFFFFFFFFFFFC2F0	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC2F4	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC2F8	31FFEF33		 	call	ScreenToAscii
FFFFFFFFFFFFC2FC	B21FD753		 	bnei	r1,#'S',Monitor
FFFFFFFFFFFFC300	31FFEED9		 	call	ClearScreen
FFFFFFFFFFFFC304	60001418		 	sb		r0,CursorCol
FFFFFFFFFFFFC308	60001416		 	sb		r0,CursorRow
FFFFFFFFFFFFC30C	31FFEF37		 	call	CalcScreenLoc
FFFFFFFFFFFFC310	BE007A4A		 	bra		Monitor
                  	           		 	
FFFFFFFFFFFFC314	           		 DisplayHelp:
FFFFFFFFFFFFC314	E07FC320		 	setlo	r1,HelpMsg
FFFFFFFFFFFFC318	31FFEFE7		 	call	DisplayString
FFFFFFFFFFFFC31C	BE0079EA		 	bra		Monitor
                  	           		 
FFFFFFFFFFFFC320	           		 	align	16
FFFFFFFFFFFFC320	           		 HelpMsg:
FFFFFFFFFFFFC320 70736944203D203F	 	db	"? = Display help",CR,LF
FFFFFFFFFFFFC328 706C65682079616C
FFFFFFFFFFFFC330 203D20534C430A0D	 	db	"CLS = clear screen",CR,LF
FFFFFFFFFFFFC338 6373207261656C63
FFFFFFFFFFFFC340 203A0A0D6E656572	 	db	": = Edit memory bytes",CR,LF
FFFFFFFFFFFFC348 6D2074696445203D
FFFFFFFFFFFFC350 79622079726F6D65
FFFFFFFFFFFFC358 3D204C0A0D736574	 	db	"L = Load S19 file",CR,LF
FFFFFFFFFFFFC360 31532064616F4C20
FFFFFFFFFFFFC368 0A0D656C69662039
FFFFFFFFFFFFC370 706D7544203D2044	 	db	"D = Dump memory",CR,LF
FFFFFFFFFFFFC378 0D79726F6D656D20
FFFFFFFFFFFFC380 617473203D20420A	 	db	"B = start tiny basic",CR,LF
FFFFFFFFFFFFC388 20796E6974207472
FFFFFFFFFFFFC390 4A0A0D6369736162	 	db	"J = Jump to code",CR,LF
FFFFFFFFFFFFC398 20706D754A203D20
FFFFFFFFFFFFC3A0 0D65646F63206F74
FFFFFFFFFFFFC3A8 766E49203D20490A	 	db	"I = Invaders",CR,LF
FFFFFFFFFFFFC3B0 520A0D7372656461	 	db	"R = Random lines",CR,LF
FFFFFFFFFFFFC3B8 6F646E6152203D20
FFFFFFFFFFFFC3C0 0D73656E696C206D
FFFFFFFFFFFFC3C8 616950203D20500A	 	db	"P = Piano",CR,LF,0
FFFFFFFFFFFFC3D0 000000000A0D6F6E	 	align	16
FFFFFFFFFFFFC3D8 0000000000000000
FFFFFFFFFFFFC3E0	           		 	align	16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Ignore blanks in the input
                  	           		 ; r3 = text pointer
                  	           		 ; r1 destroyed
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC3E0	           		 ignBlanks:
FFFFFFFFFFFFC3E0	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFC3E4	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFC3E8	           		 ignBlanks1:
FFFFFFFFFFFFC3E8	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC3EC	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC3F0	31FFEF33		 	call	ScreenToAscii
FFFFFFFFFFFFC3F4	B01FFD20		 	beqi	r1,#' ',ignBlanks1
FFFFFFFFFFFFC3F8	0E318002		 	subui	r3,r3,#2
FFFFFFFFFFFFC3FC	47EF8000		 	lw		r31,[sp]
FFFFFFFFFFFFC400	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Edit memory byte(s).
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC404	           		 EditMem:
FFFFFFFFFFFFC404	31FFF0F8		 	call	ignBlanks
FFFFFFFFFFFFC408	31FFF11C		 	call	GetHexNumber
FFFFFFFFFFFFC40C	04101409		 	or		r5,r1,r0
FFFFFFFFFFFFC410	E1000007		 	setlo	r4,#7
FFFFFFFFFFFFC414	           		 edtmem1:
FFFFFFFFFFFFC414	31FFF0F8		 	call	ignBlanks
FFFFFFFFFFFFC418	31FFF11C		 	call	GetHexNumber
FFFFFFFFFFFFC41C	60508000		 	sb		r1,[r5]
FFFFFFFFFFFFC420	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFC424	BE027F8F		 	loop	r4,edtmem1
FFFFFFFFFFFFC428	BE00718A		 	bra		Monitor
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Execute code at the specified address.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC42C	           		 ExecuteCode:
FFFFFFFFFFFFC42C	31FFF0F8		 	call	ignBlanks
FFFFFFFFFFFFC430	31FFF11C		 	call	GetHexNumber
FFFFFFFFFFFFC434	341F8000		 	jal		r31,[r1]
FFFFFFFFFFFFC438	BE00710A		 	bra     Monitor
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Do a memory dump of the requested location.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC43C	           		 DumpMem:
FFFFFFFFFFFFC43C	31FFF0F8		 	call	ignBlanks
FFFFFFFFFFFFC440	31FFF11C		 	call	GetHexNumber
FFFFFFFFFFFFC444	02110009		 	mov		r2,r1
FFFFFFFFFFFFC448	31FFEFFA		 	call	CRLF
FFFFFFFFFFFFC44C	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC450	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC454	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC458	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC45C	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC460	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC464	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC468	31FFF025		 	call	DisplayMem
FFFFFFFFFFFFC46C	BE006F6A		 	bra		Monitor
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Get a hexidecimal number. Maximum of sixteen digits.
                  	           		 ; R3 = text pointer (updated)
                  	           		 ; R1 = hex number
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC470	           		 GetHexNumber:
FFFFFFFFFFFFC470	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC474	67E10000		 	sw		r2,[sp]
FFFFFFFFFFFFC478	67E20008		 	sw		r4,8[sp]
FFFFFFFFFFFFC47C	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC480	E0800000		 	setlo	r2,#0
FFFFFFFFFFFFC484	E100000F		 	setlo	r4,#15
FFFFFFFFFFFFC488	           		 gthxn2:
FFFFFFFFFFFFC488	82308000		 	inch	r1,[r3]
FFFFFFFFFFFFC48C	0A318002		 	addui	r3,r3,#2
FFFFFFFFFFFFC490	31FFEF33		 	call	ScreenToAscii
FFFFFFFFFFFFC494	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC498	B01005FF		 	beqi	r1,#-1,gthxn1
FFFFFFFFFFFFC49C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC4A0	1410800F		 	andi	r1,r1,#0x0f
FFFFFFFFFFFFC4A4	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC4A8	BE027F0F		 	loop	r4,gthxn2
FFFFFFFFFFFFC4AC	           		 gthxn1:
FFFFFFFFFFFFC4AC	02208009		 	mov		r1,r2
FFFFFFFFFFFFC4B0	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC4B4	47E20008		 	lw		r4,8[sp]
FFFFFFFFFFFFC4B8	47E10000		 	lw		r2,[sp]
FFFFFFFFFFFFC4BC	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                  	           		 ; to a hex nybble.
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC4C0	           		 AsciiToHexNybble:
FFFFFFFFFFFFC4C0	A8100E30		 	bltui	r1,#'0',gthx3
FFFFFFFFFFFFC4C4	AE100339		 	bgtui	r1,#'9',gthx5
FFFFFFFFFFFFC4C8	0E108030		 	subui	r1,r1,#'0'
FFFFFFFFFFFFC4CC	37EF8000		 	ret
FFFFFFFFFFFFC4D0	           		 gthx5:
FFFFFFFFFFFFC4D0	A8100A41		 	bltui	r1,#'A',gthx3
FFFFFFFFFFFFC4D4	AE100446		 	bgtui	r1,#'F',gthx6
FFFFFFFFFFFFC4D8	0E108041		 	subui	r1,r1,#'A'
FFFFFFFFFFFFC4DC	0A10800A		 	addui	r1,r1,#10
FFFFFFFFFFFFC4E0	37EF8000		 	ret
FFFFFFFFFFFFC4E4	           		 gthx6:
FFFFFFFFFFFFC4E4	A8100561		 	bltui	r1,#'a',gthx3
FFFFFFFFFFFFC4E8	AE100466		 	bgtui	r1,#'f',gthx3
FFFFFFFFFFFFC4EC	0E108061		 	subui	r1,r1,#'a'
FFFFFFFFFFFFC4F0	0A10800A		 	addui	r1,r1,#10
FFFFFFFFFFFFC4F4	37EF8000		 	ret
FFFFFFFFFFFFC4F8	           		 gthx3:
FFFFFFFFFFFFC4F8	E07FFFFF		 	setlo	r1,#-1		; not a hex number
FFFFFFFFFFFFC4FC	37EF8000		 	ret
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Load an S19 format file
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFC500	           		 LoadS19:
FFFFFFFFFFFFC500	BE00006A		 	bra		ProcessRec
FFFFFFFFFFFFC504	           		 NextRec:
FFFFFFFFFFFFC504	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC508	B21FFF0A		 	bne		r1,#LF,NextRec
FFFFFFFFFFFFC50C	           		 ProcessRec:
FFFFFFFFFFFFC50C	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC510	B01F521A		 	beqi	r1,#26,Monitor	; CTRL-Z ?
FFFFFFFFFFFFC514	B21FFC53		 	bnei	r1,#'S',NextRec
FFFFFFFFFFFFC518	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC51C	A01FFA30		 	blt		r1,#'0',NextRec
FFFFFFFFFFFFC520	A61FF939		 	bgt		r1,#'9',NextRec
FFFFFFFFFFFFC524	04101009		 	or		r4,r1,r0		; r4 = record type
FFFFFFFFFFFFC528	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC52C	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC530	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFC534	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC538	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC53C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC540	04208809		 	or		r2,r2,r1		; r2 = byte count
FFFFFFFFFFFFC544	04208C09		 	or		r3,r2,r1		; r3 = byte count
FFFFFFFFFFFFC548	B04FEF30		 	beqi	r4,#'0',NextRec	; manufacturer ID record, ignore
FFFFFFFFFFFFC54C	B0401E31		 	beqi	r4,#'1',ProcessS1
FFFFFFFFFFFFC550	B0401F32		 	beqi	r4,#'2',ProcessS2
FFFFFFFFFFFFC554	B0402033		 	beqi	r4,#'3',ProcessS3
FFFFFFFFFFFFC558	B04FEB35		 	beqi	r4,#'5',NextRec	; record count record, ignore
FFFFFFFFFFFFC55C	B0402037		 	beqi	r4,#'7',ProcessS7
FFFFFFFFFFFFC560	B0402238		 	beqi	r4,#'8',ProcessS8
FFFFFFFFFFFFC564	B0402439		 	beqi	r4,#'9',ProcessS9
FFFFFFFFFFFFC568	BE007CEA		 	bra		NextRec
                  	           		 
FFFFFFFFFFFFC56C	           		 pcssxa:
FFFFFFFFFFFFC56C	143180FF		 	andi	r3,r3,#0xff
FFFFFFFFFFFFC570	0E318001		 	subui	r3,r3,#1		; one less for loop
FFFFFFFFFFFFC574	           		 pcss1a:
FFFFFFFFFFFFC574	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC578	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC57C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC580	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC584	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC588	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC58C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC590	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC594	60510000		 	sb		r2,[r5]
FFFFFFFFFFFFC598	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFC59C	BE01FECF		 	loop	r3,pcss1a
                  	           		 ; Get the checksum byte
FFFFFFFFFFFFC5A0	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC5A4	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC5A8	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC5AC	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC5B0	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC5B4	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC5B8	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC5BC	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC5C0	BE007A2A		 	bra		NextRec
                  	           		 
FFFFFFFFFFFFC5C4	           		 ProcessS1:
FFFFFFFFFFFFC5C4	31FFF180		 	call	S19Get16BitAddress
FFFFFFFFFFFFC5C8	BE007D2A		 	bra		pcssxa
FFFFFFFFFFFFC5CC	           		 ProcessS2:
FFFFFFFFFFFFC5CC	31FFF186		 	call	S19Get24BitAddress
FFFFFFFFFFFFC5D0	BE007CEA		 	bra		pcssxa
FFFFFFFFFFFFC5D4	           		 ProcessS3:
FFFFFFFFFFFFC5D4	31FFF18C		 	call	S19Get32BitAddress
FFFFFFFFFFFFC5D8	BE007CAA		 	bra		pcssxa
FFFFFFFFFFFFC5DC	           		 ProcessS7:
FFFFFFFFFFFFC5DC	31FFF18C		 	call	S19Get32BitAddress
FFFFFFFFFFFFC5E0	66028000		 	sw		r5,S19StartAddress
FFFFFFFFFFFFC5E4	BE0063AA		 	bra		Monitor
FFFFFFFFFFFFC5E8	           		 ProcessS8:
FFFFFFFFFFFFC5E8	31FFF186		 	call	S19Get24BitAddress
FFFFFFFFFFFFC5EC	66028000		 	sw		r5,S19StartAddress
FFFFFFFFFFFFC5F0	BE00634A		 	bra		Monitor
FFFFFFFFFFFFC5F4	           		 ProcessS9:
FFFFFFFFFFFFC5F4	31FFF180		 	call	S19Get16BitAddress
FFFFFFFFFFFFC5F8	66028000		 	sw		r5,S19StartAddress
FFFFFFFFFFFFC5FC	BE0062EA		 	bra		Monitor
                  	           		 
FFFFFFFFFFFFC600	           		 S19Get16BitAddress:
FFFFFFFFFFFFC600	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFC604	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFC608	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC60C	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC610	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFC614	BE00038A		 	bra		S1932b
                  	           		 
FFFFFFFFFFFFC618	           		 S19Get24BitAddress:
FFFFFFFFFFFFC618	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFC61C	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFC620	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC624	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC628	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFC62C	BE0001CA		 	bra		S1932a
                  	           		 
FFFFFFFFFFFFC630	           		 S19Get32BitAddress:
FFFFFFFFFFFFC630	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFC634	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFC638	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC63C	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC640	04100809		 	or		r2,r1,r0
FFFFFFFFFFFFC644	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC648	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC64C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC650	04110809		 	or		r2,r1,r2
FFFFFFFFFFFFC654	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC658	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC65C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC660	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC664	           		 S1932a:
FFFFFFFFFFFFC664	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC668	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC66C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC670	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC674	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC678	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC67C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC680	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC684	           		 S1932b:
FFFFFFFFFFFFC684	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC688	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC68C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC690	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC694	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC698	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC69C	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC6A0	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC6A4	31FFF1B2		 	call	sGetChar
FFFFFFFFFFFFC6A8	31FFF130		 	call	AsciiToHexNybble
FFFFFFFFFFFFC6AC	06210800		 	shli	r2,r2,#4
FFFFFFFFFFFFC6B0	04208809		 	or		r2,r2,r1
FFFFFFFFFFFFC6B4	0442100A		 	xor		r4,r4,r4
FFFFFFFFFFFFC6B8	04201409		 	or		r5,r2,r0
FFFFFFFFFFFFC6BC	47EF8000		 	lw		r31,[sp]
FFFFFFFFFFFFC6C0	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFC6C4	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; Get a character from auxillary input, checking the keyboard status for a
                  	           		 ; CTRL-C
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC6C8	           		 sGetChar:
FFFFFFFFFFFFC6C8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFC6CC	67EF8000		 	sw		r31,[sp]
FFFFFFFFFFFFC6D0	           		 sgc2:
FFFFFFFFFFFFC6D0	31FFEE1D		 	call	KeybdCheckForKey
FFFFFFFFFFFFC6D4	BE106908		 	beq		r1,r0,sgc1
FFFFFFFFFFFFC6D8	31FFEE08		 	call	KeybdGetchar
FFFFFFFFFFFFC6DC	B01EDF00		 	beqi	r1,#CRTLC,Monitor
FFFFFFFFFFFFC6E0	           		 sgc1:
FFFFFFFFFFFFC6E0	31FFF95C		 	call	AUXIN
FFFFFFFFFFFFC6E4	BE107F62		 	ble		r1,r0,sgc2
FFFFFFFFFFFFC6E8	47EF8000		 	lw		r31,[sp]
FFFFFFFFFFFFC6EC	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Draw random lines on the bitmap screen.
                  	           		 ;--------------------------------------------------------------------------
FFFFFFFFFFFFC6F0	           		 RandomLines:
FFFFFFFFFFFFC6F0	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFC6F4	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC6F8	67E18008		 	sw		r3,8[sp]
FFFFFFFFFFFFC6FC	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFC700	           		 rl5:
FFFFFFFFFFFFC700	00000050		 	gran
FFFFFFFFFFFFC704	020088A8		 	mfspr	r1,rand			; select a random color
FFFFFFFFFFFFC708	E69AE000		; SETLO
FFFFFFFFFFFFC70C	EE800003		; SETMID
FFFFFFFFFFFFC710	6A0D042A		 	outh	r1,GACCEL
FFFFFFFFFFFFC714	           		 rl1:						; random X0
FFFFFFFFFFFFC714	00000050		 	gran
FFFFFFFFFFFFC718	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFC71C	16018554		 	lw		r3,#1364
FFFFFFFFFFFFC720	0411841C		 	mod		r1,r1,r3
FFFFFFFFFFFFC724	E69AE008		; SETLO
FFFFFFFFFFFFC728	EE800003		; SETMID
FFFFFFFFFFFFC72C	6A0D042A		 	outh	r1,GACCEL+8
FFFFFFFFFFFFC730	           		 rl2:						; random X1
FFFFFFFFFFFFC730	00000050		 	gran
FFFFFFFFFFFFC734	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFC738	16018554		 	lw		r3,#1364
FFFFFFFFFFFFC73C	0411841C		 	mod		r1,r1,r3
FFFFFFFFFFFFC740	E69AE010		; SETLO
FFFFFFFFFFFFC744	EE800003		; SETMID
FFFFFFFFFFFFC748	6A0D042A		 	outh	r1,GACCEL+16
FFFFFFFFFFFFC74C	           		 rl3:						; random Y0
FFFFFFFFFFFFC74C	00000050		 	gran
FFFFFFFFFFFFC750	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFC754	16018300		 	lw		r3,#768
FFFFFFFFFFFFC758	0411841C		 	mod		r1,r1,r3
FFFFFFFFFFFFC75C	E69AE00C		; SETLO
FFFFFFFFFFFFC760	EE800003		; SETMID
FFFFFFFFFFFFC764	6A0D042A		 	outh	r1,GACCEL+12
FFFFFFFFFFFFC768	           		 rl4:						; random Y1
FFFFFFFFFFFFC768	00000050		 	gran
FFFFFFFFFFFFC76C	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFC770	16018300		 	lw		r3,#768
FFFFFFFFFFFFC774	0411841C		 	mod		r1,r1,r3
FFFFFFFFFFFFC778	E69AE014		; SETLO
FFFFFFFFFFFFC77C	EE800003		; SETMID
FFFFFFFFFFFFC780	6A0D042A		 	outh	r1,GACCEL+20
FFFFFFFFFFFFC784	E0400002		 	setlo	r1,#2			; draw line command
FFFFFFFFFFFFC788	E69AE03C		; SETLO
FFFFFFFFFFFFC78C	EE800003		; SETMID
FFFFFFFFFFFFC790	6A0D042A		 	outh	r1,GACCEL+60
FFFFFFFFFFFFC794	           		 rl8:
FFFFFFFFFFFFC794	31FFEE08		 	call	KeybdGetChar
FFFFFFFFFFFFC798	B0100303		 	beqi	r1,#CTRLC,rl7
FFFFFFFFFFFFC79C	B01FD972		 	beqi	r1,#'r',rl5
FFFFFFFFFFFFC7A0	BE007FAA		 	bra		rl8
FFFFFFFFFFFFC7A4	           		 rl7:
FFFFFFFFFFFFC7A4	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFC7A8	47E18008		 	lw		r3,8[sp]
FFFFFFFFFFFFC7AC	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC7B0	37EF8018		 	ret		#24
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Initialize sprite image caches with random data.
                  	           		 ;--------------------------------------------------------------------------
FFFFFFFFFFFFC7B4	           		 RandomizeSprram:
FFFFFFFFFFFFC7B4	E6980000		; SETLO
FFFFFFFFFFFFC7B8	EE800003		; SETMID
FFFFFFFFFFFFC7BC	6A0D082D		 	lea		r2,SPRRAM
FFFFFFFFFFFFC7C0	E10037FF		 	setlo	r4,#14335		; number of chars to initialize
FFFFFFFFFFFFC7C4	           		 rsr1:
FFFFFFFFFFFFC7C4	00000050		 	gran
FFFFFFFFFFFFC7C8	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFC7CC	92208000		 	outc	r1,[r2]
FFFFFFFFFFFFC7D0	0A210002		 	addui	r2,r2,#2
FFFFFFFFFFFFC7D4	BE027F8F		 	loop	r4,rsr1
FFFFFFFFFFFFC7D8	37EF8000		 	ret
                  	           		 	
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Setup the AC97/LM4550 audio controller. Check keyboard for a CTRL-C
                  	           		 ; interrupt which may be necessary if the audio controller isn't 
                  	           		 ; responding.
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC7DC	           		 SetupAC97:
FFFFFFFFFFFFC7DC	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC7E0	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC7E4	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC7E8	           		 sac974:
FFFFFFFFFFFFC7E8	E69C1026		; SETLO
FFFFFFFFFFFFC7EC	EE800003		; SETMID
FFFFFFFFFFFFC7F0	6A0D0029		 	outc	r0,AC97+0x26	; trigger a read of register 26 (status reg)
FFFFFFFFFFFFC7F4	           		 sac971:						; wait for status to register 0xF (all ready)
FFFFFFFFFFFFC7F4	31FFEE08		 	call	KeybdGetChar	; see if we needed to CTRL-C
FFFFFFFFFFFFC7F8	B0100A03		 	beqi	r1,#CTRLC,sac973
FFFFFFFFFFFFC7FC	E69C1068		; SETLO
FFFFFFFFFFFFC800	EE800003		; SETMID
FFFFFFFFFFFFC804	6A0D0429		 	outc	r1,AC97+0x68	; wait for dirty bit to clear
FFFFFFFFFFFFC808	BE107F69		 	bne		r1,r0,sac971
FFFFFFFFFFFFC80C	E69C1026		; SETLO
FFFFFFFFFFFFC810	EE800003		; SETMID
FFFFFFFFFFFFC814	6A0D0429		 	outc	r1,AC97+0x26	; check status at reg h26, wait for
FFFFFFFFFFFFC818	1410800F		 	andi	r1,r1,#0x0F		; analogue to be ready
FFFFFFFFFFFFC81C	B21FF30F		 	bnei	r1,#0x0F,sac974
FFFFFFFFFFFFC820	           		 sac973:
FFFFFFFFFFFFC820	E69C1002		; SETLO
FFFFFFFFFFFFC824	EE800003		; SETMID
FFFFFFFFFFFFC828	6A0D0029		 	outc	r0,AC97+2		; master volume, 0db attenuation, mute off
FFFFFFFFFFFFC82C	E69C1004		; SETLO
FFFFFFFFFFFFC830	EE800003		; SETMID
FFFFFFFFFFFFC834	6A0D0029		 	outc	r0,AC97+4		; headphone volume, 0db attenuation, mute off
FFFFFFFFFFFFC838	E69C1018		; SETLO
FFFFFFFFFFFFC83C	EE800003		; SETMID
FFFFFFFFFFFFC840	6A0D0029		 	outc	r0,AC97+0x18	; PCM gain (mixer) mute off, no attenuation
FFFFFFFFFFFFC844	E69C100A		; SETLO
FFFFFFFFFFFFC848	EE800003		; SETMID
FFFFFFFFFFFFC84C	6A0D0029		 	outc	r0,AC97+0x0A	; mute PC beep
FFFFFFFFFFFFC850	E07F8000		 	setlo	r1,#0x8000		; bypass 3D sound
FFFFFFFFFFFFC854	E69C1020		; SETLO
FFFFFFFFFFFFC858	EE800003		; SETMID
FFFFFFFFFFFFC85C	6A0D0429		 	outc	r1,AC97+0x20
FFFFFFFFFFFFC860	           		 sac972:
FFFFFFFFFFFFC860	31FFEE08		 	call	KeybdGetChar
FFFFFFFFFFFFC864	B0100503		 	beqi	r1,#CTRLC,sac975
FFFFFFFFFFFFC868	E69C1068		; SETLO
FFFFFFFFFFFFC86C	EE800003		; SETMID
FFFFFFFFFFFFC870	6A0D0429		 	outc	r1,AC97+0x68	; wait for dirty bits to clear
FFFFFFFFFFFFC874	BE107F69		 	bne		r1,r0,sac972	; wait a while for the settings to take effect
FFFFFFFFFFFFC878	           		 sac975:
FFFFFFFFFFFFC878	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC87C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC880	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; Sound a 800 Hz beep
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFC884	           		 Beep:
FFFFFFFFFFFFC884	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC888	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC88C	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC890	E0400008		 	setlo	r1,#8
FFFFFFFFFFFFC894	E69C0600		; SETLO
FFFFFFFFFFFFC898	EE800003		; SETMID
FFFFFFFFFFFFC89C	6A0D0428		 	outb	r1,LED
FFFFFFFFFFFFC8A0	1600800F		 	ori		r1,r0,#15		; master volume to max
FFFFFFFFFFFFC8A4	E6950080		; SETLO
FFFFFFFFFFFFC8A8	EE800003		; SETMID
FFFFFFFFFFFFC8AC	6A0D0429		 	outc	r1,PSG+128
FFFFFFFFFFFFC8B0	1600B46E		 	ori		r1,r0,#13422	; 800Hz
FFFFFFFFFFFFC8B4	E6950000		; SETLO
FFFFFFFFFFFFC8B8	EE800003		; SETMID
FFFFFFFFFFFFC8BC	6A0D0429		 	outc	r1,PSGFREQ0
FFFFFFFFFFFFC8C0	E0400009		 	setlo	r1,#9
FFFFFFFFFFFFC8C4	E69C0600		; SETLO
FFFFFFFFFFFFC8C8	EE800003		; SETMID
FFFFFFFFFFFFC8CC	6A0D0428		 	outb	r1,LED
                  	           		 	; decay  (16.384 ms)2
                  	           		 	; attack (8.192 ms)1
                  	           		 	; release (1.024 s)A
                  	           		 	; sustain level C
FFFFFFFFFFFFC8D0	E07FCA12		 	setlo	r1,#0xCA12
FFFFFFFFFFFFC8D4	E6950006		; SETLO
FFFFFFFFFFFFC8D8	EE800003		; SETMID
FFFFFFFFFFFFC8DC	6A0D0429		 	outc	r1,PSGADSR0
FFFFFFFFFFFFC8E0	16009104		 	ori		r1,r0,#0x1104	; gate, output enable, triangle waveform
FFFFFFFFFFFFC8E4	E6950004		; SETLO
FFFFFFFFFFFFC8E8	EE800003		; SETMID
FFFFFFFFFFFFC8EC	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFC8F0	E6BD7840		; SETLO
FFFFFFFFFFFFC8F4	EE800005		; SETMID
FFFFFFFFFFFFC8F8	040D0409		 	ori		r1,r0,#25000000	; delay about 1s
FFFFFFFFFFFFC8FC	           		 beep1:
FFFFFFFFFFFFC8FC	BE00800F		 	loop	r1,beep1
FFFFFFFFFFFFC900	E040000D		 	setlo	r1,#13
FFFFFFFFFFFFC904	E69C0600		; SETLO
FFFFFFFFFFFFC908	EE800003		; SETMID
FFFFFFFFFFFFC90C	6A0D0428		 	outb	r1,LED
FFFFFFFFFFFFC910	16008104		 	ori		r1,r0,#0x0104	; gate off, output enable, triangle waveform
FFFFFFFFFFFFC914	E6950004		; SETLO
FFFFFFFFFFFFC918	EE800003		; SETMID
FFFFFFFFFFFFC91C	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFC920	E6BD7840		; SETLO
FFFFFFFFFFFFC924	EE800005		; SETMID
FFFFFFFFFFFFC928	040D0409		 	ori		r1,r0,#25000000	; delay about 1s
FFFFFFFFFFFFC92C	           		 beep2:
FFFFFFFFFFFFC92C	BE00800F		 	loop	r1,beep2
FFFFFFFFFFFFC930	E0400010		 	setlo	r1,#16
FFFFFFFFFFFFC934	E69C0600		; SETLO
FFFFFFFFFFFFC938	EE800003		; SETMID
FFFFFFFFFFFFC93C	6A0D0428		 	outb	r1,LED
FFFFFFFFFFFFC940	16008000		 	ori		r1,r0,#0x0000	; gate off, output enable off, no waveform
FFFFFFFFFFFFC944	E6950004		; SETLO
FFFFFFFFFFFFC948	EE800003		; SETMID
FFFFFFFFFFFFC94C	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFC950	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFC954	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFC958	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ;--------------------------------------------------------------------------
                  	           		 ; 
FFFFFFFFFFFFC95C	           		 Piano:
FFFFFFFFFFFFC95C	1600800F		 	ori		r1,r0,#15		; master volume to max
FFFFFFFFFFFFC960	E6950080		; SETLO
FFFFFFFFFFFFC964	EE800003		; SETMID
FFFFFFFFFFFFC968	6A0D0429		 	outc	r1,PSG+128
FFFFFFFFFFFFC96C	           		 playnt:
FFFFFFFFFFFFC96C	31FFEE08		 	call	KeybdGetChar
FFFFFFFFFFFFC970	B01E3A03		 	beqi	r1,#CTRLC,Monitor
FFFFFFFFFFFFC974	B0100861		 	beqi	r1,#'a',playnt1a
FFFFFFFFFFFFC978	B0100A62		 	beqi	r1,#'b',playnt1b
FFFFFFFFFFFFC97C	B0100C63		 	beqi	r1,#'c',playnt1c
FFFFFFFFFFFFC980	B0100E64		 	beqi	r1,#'d',playnt1d
FFFFFFFFFFFFC984	B0101065		 	beqi	r1,#'e',playnt1e
FFFFFFFFFFFFC988	B0101266		 	beqi	r1,#'f',playnt1f
FFFFFFFFFFFFC98C	B0101467		 	beqi	r1,#'g',playnt1g
FFFFFFFFFFFFC990	BE007EEA		 	bra		playnt
                  	           		 
FFFFFFFFFFFFC994	           		 playnt1a:
FFFFFFFFFFFFC994	E0401C31		 	setlo	r1,#7217
FFFFFFFFFFFFC998	31FFF27A		 	call	Tone
FFFFFFFFFFFFC99C	BE007E8A		 	bra		playnt
FFFFFFFFFFFFC9A0	           		 playnt1b:
FFFFFFFFFFFFC9A0	E0401FA5		 	setlo	r1,#8101
FFFFFFFFFFFFC9A4	31FFF27A		 	call	Tone
FFFFFFFFFFFFC9A8	BE007E2A		 	bra		playnt
FFFFFFFFFFFFC9AC	           		 playnt1c:
FFFFFFFFFFFFC9AC	E04010C3		 	setlo	r1,#4291
FFFFFFFFFFFFC9B0	31FFF27A		 	call	Tone
FFFFFFFFFFFFC9B4	BE007DCA		 	bra		playnt
FFFFFFFFFFFFC9B8	           		 playnt1d:
FFFFFFFFFFFFC9B8	E04012D1		 	setlo	r1,#4817
FFFFFFFFFFFFC9BC	31FFF27A		 	call	Tone
FFFFFFFFFFFFC9C0	BE007D6A		 	bra		playnt
FFFFFFFFFFFFC9C4	           		 playnt1e:
FFFFFFFFFFFFC9C4	E040151F		 	setlo	r1,#5407
FFFFFFFFFFFFC9C8	31FFF27A		 	call	Tone
FFFFFFFFFFFFC9CC	BE007D0A		 	bra		playnt
FFFFFFFFFFFFC9D0	           		 playnt1f:
FFFFFFFFFFFFC9D0	E0401660		 	setlo	r1,#5728
FFFFFFFFFFFFC9D4	31FFF27A		 	call	Tone
FFFFFFFFFFFFC9D8	BE007CAA		 	bra		playnt
FFFFFFFFFFFFC9DC	           		 playnt1g:
FFFFFFFFFFFFC9DC	E040191E		 	setlo	r1,#6430
FFFFFFFFFFFFC9E0	31FFF27A		 	call	Tone
FFFFFFFFFFFFC9E4	BE007C4A		 	bra		playnt
                  	           		 
FFFFFFFFFFFFC9E8	           		 Tone:
FFFFFFFFFFFFC9E8	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFC9EC	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFC9F0	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFC9F4	E6950000		; SETLO
FFFFFFFFFFFFC9F8	EE800003		; SETMID
FFFFFFFFFFFFC9FC	6A0D0429		 	outc	r1,PSGFREQ0
                  	           		 	; decay  (16.384 ms)2
                  	           		 	; attack (8.192 ms)1
                  	           		 	; release (1.024 s)A
                  	           		 	; sustain level C
FFFFFFFFFFFFCA00	E07FCA12		 	setlo	r1,#0xCA12
FFFFFFFFFFFFCA04	E6950006		; SETLO
FFFFFFFFFFFFCA08	EE800003		; SETMID
FFFFFFFFFFFFCA0C	6A0D0429		 	outc	r1,PSGADSR0
FFFFFFFFFFFFCA10	16009104		 	ori		r1,r0,#0x1104	; gate, output enable, triangle waveform
FFFFFFFFFFFFCA14	E6950004		; SETLO
FFFFFFFFFFFFCA18	EE800003		; SETMID
FFFFFFFFFFFFCA1C	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFCA20	E683D090		; SETLO
FFFFFFFFFFFFCA24	040D0409		 	ori		r1,r0,#250000	; delay about 10ms
FFFFFFFFFFFFCA28	           		 tone1:
FFFFFFFFFFFFCA28	BE00800F		 	loop	r1,tone1
FFFFFFFFFFFFCA2C	16008104		 	ori		r1,r0,#0x0104	; gate off, output enable, triangle waveform
FFFFFFFFFFFFCA30	E6950004		; SETLO
FFFFFFFFFFFFCA34	EE800003		; SETMID
FFFFFFFFFFFFCA38	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFCA3C	E683D090		; SETLO
FFFFFFFFFFFFCA40	040D0409		 	ori		r1,r0,#250000	; delay about 10ms
FFFFFFFFFFFFCA44	           		 tone2:
FFFFFFFFFFFFCA44	BE00800F		 	loop	r1,tone2
FFFFFFFFFFFFCA48	16008000		 	ori		r1,r0,#0x0000	; gate off, output enable off, no waveform
FFFFFFFFFFFFCA4C	E6950004		; SETLO
FFFFFFFFFFFFCA50	EE800003		; SETMID
FFFFFFFFFFFFCA54	6A0D0429		 	outc	r1,PSGCTRL0
FFFFFFFFFFFFCA58	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFCA5C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFCA60	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
FFFFFFFFFFFFCA64	           		 SetupRasterIRQ:
FFFFFFFFFFFFCA64	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCA68	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFCA6C	E04000C8		 	setlo	r1,#200
FFFFFFFFFFFFCA70	E69A0100		; SETLO
FFFFFFFFFFFFCA74	EE800003		; SETMID
FFFFFFFFFFFFCA78	6A0D0429		 	outc	r1,RASTERIRQ
FFFFFFFFFFFFCA7C	E04000F0		 	setlo	r1,#240
FFFFFFFFFFFFCA80	E69A0102		; SETLO
FFFFFFFFFFFFCA84	EE800003		; SETMID
FFFFFFFFFFFFCA88	6A0D0429		 	outc	r1,RASTERIRQ+2
FFFFFFFFFFFFCA8C	E0400118		 	setlo	r1,#280
FFFFFFFFFFFFCA90	E69A0104		; SETLO
FFFFFFFFFFFFCA94	EE800003		; SETMID
FFFFFFFFFFFFCA98	6A0D0429		 	outc	r1,RASTERIRQ+4
FFFFFFFFFFFFCA9C	E0400140		 	setlo	r1,#320
FFFFFFFFFFFFCAA0	E69A0106		; SETLO
FFFFFFFFFFFFCAA4	EE800003		; SETMID
FFFFFFFFFFFFCAA8	6A0D0429		 	outc	r1,RASTERIRQ+6
FFFFFFFFFFFFCAAC	E0400168		 	setlo	r1,#360
FFFFFFFFFFFFCAB0	E69A0108		; SETLO
FFFFFFFFFFFFCAB4	EE800003		; SETMID
FFFFFFFFFFFFCAB8	6A0D0429		 	outc	r1,RASTERIRQ+8
FFFFFFFFFFFFCABC	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFCAC0	37EF8008		 	ret		#8
                  	           		 
FFFFFFFFFFFFCAC4	           		 RasterIRQfn:
FFFFFFFFFFFFCAC4	E69A011E		; SETLO
FFFFFFFFFFFFCAC8	EE800003		; SETMID
FFFFFFFFFFFFCACC	6A0D0421		 	inch	r1,RASTERIRQ+30		; get the raster compare register # (clears IRQ)
FFFFFFFFFFFFCAD0	B0100901		 	beqi	r1,#1,rirq1
FFFFFFFFFFFFCAD4	B0100802		 	beqi	r1,#2,rirq2
FFFFFFFFFFFFCAD8	B0100703		 	beqi	r1,#3,rirq3
FFFFFFFFFFFFCADC	B0100604		 	beqi	r1,#4,rirq4
FFFFFFFFFFFFCAE0	B0100505		 	beqi	r1,#5,rirq5
FFFFFFFFFFFFCAE4	B0100406		 	beqi	r1,#6,rirq6
FFFFFFFFFFFFCAE8	B0100307		 	beqi	r1,#7,rirq7
FFFFFFFFFFFFCAEC	B0100208		 	beqi	r1,#8,rirq8
FFFFFFFFFFFFCAF0	37EF8000		 	ret
FFFFFFFFFFFFCAF4	           		 rirq1:
FFFFFFFFFFFFCAF4	           		 rirq2:
FFFFFFFFFFFFCAF4	           		 rirq3:
FFFFFFFFFFFFCAF4	           		 rirq4:
FFFFFFFFFFFFCAF4	           		 rirq5:
FFFFFFFFFFFFCAF4	           		 rirq6:
FFFFFFFFFFFFCAF4	           		 rirq7:
FFFFFFFFFFFFCAF4	           		 rirq8:
FFFFFFFFFFFFCAF4	1A108028		 	mului	r1,r1,#40
FFFFFFFFFFFFCAF8	0A1080CC		 	addui	r1,r1,#204
FFFFFFFFFFFFCAFC	E69AD002		; SETLO
FFFFFFFFFFFFCB00	EE800003		; SETMID
FFFFFFFFFFFFCB04	6A0D0429		 	outc	r1,SPRITEREGS+2
FFFFFFFFFFFFCB08	E69AD012		; SETLO
FFFFFFFFFFFFCB0C	EE800003		; SETMID
FFFFFFFFFFFFCB10	6A0D0429		 	outc	r1,SPRITEREGS+18
FFFFFFFFFFFFCB14	E69AD022		; SETLO
FFFFFFFFFFFFCB18	EE800003		; SETMID
FFFFFFFFFFFFCB1C	6A0D0429		 	outc	r1,SPRITEREGS+34
FFFFFFFFFFFFCB20	E69AD032		; SETLO
FFFFFFFFFFFFCB24	EE800003		; SETMID
FFFFFFFFFFFFCB28	6A0D0429		 	outc	r1,SPRITEREGS+50
FFFFFFFFFFFFCB2C	E69AD042		; SETLO
FFFFFFFFFFFFCB30	EE800003		; SETMID
FFFFFFFFFFFFCB34	6A0D0429		 	outc	r1,SPRITEREGS+66
FFFFFFFFFFFFCB38	E69AD052		; SETLO
FFFFFFFFFFFFCB3C	EE800003		; SETMID
FFFFFFFFFFFFCB40	6A0D0429		 	outc	r1,SPRITEREGS+82
FFFFFFFFFFFFCB44	E69AD062		; SETLO
FFFFFFFFFFFFCB48	EE800003		; SETMID
FFFFFFFFFFFFCB4C	6A0D0429		 	outc	r1,SPRITEREGS+98
FFFFFFFFFFFFCB50	E69AD072		; SETLO
FFFFFFFFFFFFCB54	EE800003		; SETMID
FFFFFFFFFFFFCB58	6A0D0429		 	outc	r1,SPRITEREGS+114
FFFFFFFFFFFFCB5C	37EF8000		 	ret
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;------------------------------------------------------------------------------
FFFFFFFFFFFFCB60	           		 DisplayDatetime:
FFFFFFFFFFFFCB60	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFCB64	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFCB68	67E10008		 	sw		r2,8[sp]
FFFFFFFFFFFFCB6C	67E18010		 	sw		r3,16[sp]
FFFFFFFFFFFFCB70	67EF8018		 	sw		lr,24[sp]
FFFFFFFFFFFFCB74	31FFEEBA		 	call	CursorOff
FFFFFFFFFFFFCB78	42011416		 	lc		r2,CursorRow
FFFFFFFFFFFFCB7C	42019418		 	lc		r3,CursorCol
FFFFFFFFFFFFCB80	E69C0418		; SETLO
FFFFFFFFFFFFCB84	EE800003		; SETMID
FFFFFFFFFFFFCB88	6A0D002B		 	outw	r0,DATETIME+24		; trigger a snapshot
FFFFFFFFFFFFCB8C	1600802E		 	lw		r1,#46				; move cursor down to last display line
FFFFFFFFFFFFCB90	62009416		 	sc		r1,CursorRow
FFFFFFFFFFFFCB94	16008040		 	lw		r1,#64
FFFFFFFFFFFFCB98	62009418		 	sc		r1,CursorCol
FFFFFFFFFFFFCB9C	E69C0400		; SETLO
FFFFFFFFFFFFCBA0	EE800003		; SETMID
FFFFFFFFFFFFCBA4	6A0D0423		 	inw		r1,DATETIME			; get the snapshotted date and time
FFFFFFFFFFFFCBA8	31FFF019		 	call	DisplayWord			; display on screen
FFFFFFFFFFFFCBAC	62011416		 	sc		r2,CursorRow		; restore cursor position
FFFFFFFFFFFFCBB0	62019418		 	sc		r3,CursorCol
FFFFFFFFFFFFCBB4	31FFEF37		 	call	CalcScreenLoc
FFFFFFFFFFFFCBB8	31FFEEBF		 	call	CursorOn
FFFFFFFFFFFFCBBC	47EF8018		 	lw		lr,24[sp]
FFFFFFFFFFFFCBC0	47E18010		 	lw		r3,16[sp]
FFFFFFFFFFFFCBC4	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFCBC8	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFCBCC	37EF8020		 	ret		#32
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
FFFFFFFFFFFFCBD0	           		 InitializeGame:
FFFFFFFFFFFFCBD0	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFCBD4	27F40000004		 	sm		[sp],r3/lr
FFFFFFFFFFFFCBD8	E0C00140		 	setlo	r3,#320
FFFFFFFFFFFFCBDC	62019508		 	sc		r3,Manpos
FFFFFFFFFFFFCBE0	62001500		 	sc		r0,Score
FFFFFFFFFFFFCBE4	60001510		 	sb		r0,MissileActive
FFFFFFFFFFFFCBE8	62001512		 	sc		r0,MissileX
FFFFFFFFFFFFCBEC	62001514		 	sc		r0,MissileY
FFFFFFFFFFFFCBF0	27740000004		 	lm		[sp],r3/lr
FFFFFFFFFFFFCBF4	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFCBF8	           		 DrawScore:
FFFFFFFFFFFFCBF8	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFCBFC	27F40000005		 	sm		[sp],r1/r3/lr
FFFFFFFFFFFFCC00	E0C00001		 	setlo	r3,#1
FFFFFFFFFFFFCC04	60019416		 	sb		r3,CursorRow
FFFFFFFFFFFFCC08	E0C00028		 	setlo	r3,#40
FFFFFFFFFFFFCC0C	60019418		 	sb		r3,CursorCol
FFFFFFFFFFFFCC10	40009500		 	lb		r1,Score
FFFFFFFFFFFFCC14	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCC18	40009501		 	lb		r1,Score+1
FFFFFFFFFFFFCC1C	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCC20	27740000005		 	lm		[sp],r1/r3/lr
FFFFFFFFFFFFCC24	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFCC28	           		 DrawMissile:
FFFFFFFFFFFFCC28	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFCC2C	27F40000001		 	sm		[sp],r1/lr
FFFFFFFFFFFFCC30	42009514		 	lc		r1,MissileY
FFFFFFFFFFFFCC34	AC101402		 	bleu	r1,#2,MissileOff
FFFFFFFFFFFFCC38	42009512		 	lc		r1,MissileX
FFFFFFFFFFFFCC3C	06108601		 	shrui	r1,r1,#3
FFFFFFFFFFFFCC40	60009418		 	sb		r1,CursorCol
FFFFFFFFFFFFCC44	42009514		 	lc		r1,MissileY
FFFFFFFFFFFFCC48	60009416		 	sb		r1,CursorRow
FFFFFFFFFFFFCC4C	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFCC50	62009514		 	sc		r1,MissileY
FFFFFFFFFFFFCC54	E040005E		 	setlo	r1,#'^'
FFFFFFFFFFFFCC58	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCC5C	40009418		 	lb		r1,CursorCol
FFFFFFFFFFFFCC60	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFCC64	60009418		 	sb		r1,CursorCol
FFFFFFFFFFFFCC68	40009416		 	lb		r1,CursorRow
FFFFFFFFFFFFCC6C	0E108001		 	subui	r1,r1,#1
FFFFFFFFFFFFCC70	60009416		 	sb		r1,CursorRow
FFFFFFFFFFFFCC74	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCC78	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCC7C	27740000001		 	lm		[sp],r1/lr
FFFFFFFFFFFFCC80	37EF8010		 	ret		#16
FFFFFFFFFFFFCC84	           		 MissileOff:
FFFFFFFFFFFFCC84	60001510		 	sb		r0,MissileActive
FFFFFFFFFFFFCC88	42009512		 	lc		r1,MissileX
FFFFFFFFFFFFCC8C	06108601		 	shrui	r1,r1,#3
FFFFFFFFFFFFCC90	60009418		 	sb		r1,CursorCol
FFFFFFFFFFFFCC94	42009514		 	lc		r1,MissileY
FFFFFFFFFFFFCC98	60009416		 	sb		r1,CursorRow
FFFFFFFFFFFFCC9C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCCA0	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCCA4	27740000001		 	lm		[sp],r1/lr
FFFFFFFFFFFFCCA8	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFCCAC	           		 DrawMan:
FFFFFFFFFFFFCCAC	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFCCB0	27F40000005		 	sm		[sp],r1/r3/lr
FFFFFFFFFFFFCCB4	E0C0002E		 	setlo	r3,#46
FFFFFFFFFFFFCCB8	60019416		 	sb		r3,CursorRow
FFFFFFFFFFFFCCBC	42019508		 	lc		r3,Manpos
FFFFFFFFFFFFCCC0	06318601		 	shrui	r3,r3,#3
FFFFFFFFFFFFCCC4	60019418		 	sb		r3,CursorCol
FFFFFFFFFFFFCCC8	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCCCC	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCCD0	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFCCD4	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCCD8	E0400041		 	setlo	r1,#'A'
FFFFFFFFFFFFCCDC	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCCE0	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFCCE4	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCCE8	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCCEC	31FFEF47		 	call	DisplayChar
FFFFFFFFFFFFCCF0	27740000005		 	lm		[sp],r1/r3/lr
FFFFFFFFFFFFCCF4	37EF8018		 	ret		#24
                  	           		 
FFFFFFFFFFFFCCF8	           		 DrawInvader:
FFFFFFFFFFFFCCF8	46018000		 	lw		r3,InvaderPos
FFFFFFFFFFFFCCFC	160080E9		 	lw		r1,#233
FFFFFFFFFFFFCD00	62308000		 	sc		r1,[r3]
FFFFFFFFFFFFCD04	160080F2		 	lw		r1,#242
FFFFFFFFFFFFCD08	62308001		 	sc		r1,1[r3]
FFFFFFFFFFFFCD0C	160080DF		 	lw		r1,#223
FFFFFFFFFFFFCD10	62308002		 	sc		r1,2[r3]
FFFFFFFFFFFFCD14	37EF8000		 	ret
                  	           		 
FFFFFFFFFFFFCD18	           		 DrawInvaders:
FFFFFFFFFFFFCD18	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFCD1C	27F4000000F		 	sm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFCD20	42009520		 	lc		r1,InvadersRow1
FFFFFFFFFFFFCD24	42021570		 	lc		r4,InvadersColpos
FFFFFFFFFFFFCD28	14110001		 	andi	r2,r1,#1
FFFFFFFFFFFFCD2C	BE2003A8		 	beq		r2,r0,dinv1
FFFFFFFFFFFFCD30	40019571		 	lb		r3,InvadersRowpos
FFFFFFFFFFFFCD34	60019416		 	sb		r3,CursorRow
FFFFFFFFFFFFCD38	60021418		 	sb		r4,CursorCol
FFFFFFFFFFFFCD3C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCD40	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD44	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFCD48	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD4C	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFCD50	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD54	E0400023		 	setlo	r1,#'#'
FFFFFFFFFFFFCD58	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD5C	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCD60	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD64	40009416		 	lb		r1,CursorRow
FFFFFFFFFFFFCD68	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFCD6C	60009416		 	sb		r1,CursorRow
FFFFFFFFFFFFCD70	40009418		 	lb		r1,CursorCol
FFFFFFFFFFFFCD74	0E108005		 	subui	r1,r1,#5
FFFFFFFFFFFFCD78	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCD7C	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD80	E0400058		 	setlo	r1,#'X'
FFFFFFFFFFFFCD84	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD88	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCD8C	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD90	E0400058		 	setlo	r1,#'X'
FFFFFFFFFFFFCD94	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCD98	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFCD9C	31FFF00F		 	call	DisplayByte
FFFFFFFFFFFFCDA0	           		 dinv1:
FFFFFFFFFFFFCDA0	2774000000F		 	lm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFCDA4	37EF8028		 	ret		#40
FFFFFFFFFFFFCDA8	           		 DrawBombs:
FFFFFFFFFFFFCDA8	37EF8000		 	ret
                  	           		 
FFFFFFFFFFFFCDAC	           		 Invaders:
FFFFFFFFFFFFCDAC	FFFFFFFFFFFF0000		 	subui	sp,#240
FFFFFFFFFFFFCDB0	27F4000000F		 	sm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFCDB4	31FFF2F4		 	call	InitializeGame
FFFFFFFFFFFFCDB8	           		 InvadersLoop:
FFFFFFFFFFFFCDB8	31FFF2FE		 	call	DrawScore
FFFFFFFFFFFFCDBC	31FFF346		 	call	DrawInvaders
FFFFFFFFFFFFCDC0	31FFF36A		 	call	DrawBombs
FFFFFFFFFFFFCDC4	31FFF30A		 	call	DrawMissile
FFFFFFFFFFFFCDC8	31FFF32B		 	call	DrawMan
FFFFFFFFFFFFCDCC	           		 TestMoveMan:
FFFFFFFFFFFFCDCC	31FFEE08		 	call	KeybdGetChar
FFFFFFFFFFFFCDD0	B010046B		 	beqi	r1,#'k',MoveManRight
FFFFFFFFFFFFCDD4	B010096A		 	beqi	r1,#'j',MoveManLeft
FFFFFFFFFFFFCDD8	B0100D20		 	beqi	r1,#' ',FireMissile
FFFFFFFFFFFFCDDC	BE0002AA		 	bra		Invaders1
FFFFFFFFFFFFCDE0	           		 MoveManRight:
FFFFFFFFFFFFCDE0	42011508		 	lc		r2,Manpos
FFFFFFFFFFFFCDE4	E6800280		; SETLO
FFFFFFFFFFFFCDE8	BE2D0247		 	bgtu	r2,#640,Invaders1
FFFFFFFFFFFFCDEC	0A210008		 	addui	r2,r2,#8
FFFFFFFFFFFFCDF0	62011508		 	sc		r2,Manpos
FFFFFFFFFFFFCDF4	BE0001EA		 	bra		Invaders1
FFFFFFFFFFFFCDF8	           		 MoveManLeft:
FFFFFFFFFFFFCDF8	42011508		 	lc		r2,Manpos
FFFFFFFFFFFFCDFC	BE2001A2		 	ble		r2,r0,Invaders1
FFFFFFFFFFFFCE00	0E210008		 	subui	r2,r2,#8
FFFFFFFFFFFFCE04	62011508		 	sc		r2,Manpos
FFFFFFFFFFFFCE08	BE00014A		 	bra		Invaders1
FFFFFFFFFFFFCE0C	           		 FireMissile:
FFFFFFFFFFFFCE0C	40011510		 	lb		r2,MissileActive
FFFFFFFFFFFFCE10	BE200109		 	bne		r2,r0,Invaders1
FFFFFFFFFFFFCE14	E0800001		 	setlo	r2,#1
FFFFFFFFFFFFCE18	60011510		 	sb		r2,MissileActive
FFFFFFFFFFFFCE1C	42011508		 	lc		r2,Manpos
FFFFFFFFFFFFCE20	62011512		 	sc		r2,MissileX
FFFFFFFFFFFFCE24	E080002E		 	setlo	r2,#46
FFFFFFFFFFFFCE28	62011514		 	sc		r2,MissileY
FFFFFFFFFFFFCE2C	BE00002A		 	bra		Invaders1
FFFFFFFFFFFFCE30	           		 Invaders1:
FFFFFFFFFFFFCE30	B0100203		 	beqi	r1,#CTRLC,InvadersEnd
FFFFFFFFFFFFCE34	BE007C2A		 	bra		InvadersLoop
FFFFFFFFFFFFCE38	           		 InvadersEnd:
FFFFFFFFFFFFCE38	2774000000F		 	lm		[sp],r1/r2/r3/r4/lr
FFFFFFFFFFFFCE3C	0BEF00F0		 	addui	sp,sp,#240
FFFFFFFFFFFFCE40	BE0020CA		 	bra		Monitor
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ;==============================================================================
                  	           		 ;****************************************************************;
                  	           		 ;                                                                ;
                  	           		 ;		Tiny BASIC for the Raptor64                              ;
                  	           		 ;                                                                ;
                  	           		 ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                  	           		 ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                  	           		 ; Adapted to the 68000 by:                                       ;
                  	           		 ;	Gordon brndly						                         ;
                  	           		 ;	12147 - 51 Street					                         ;
                  	           		 ;	Edmonton AB  T5W 3G8					                     ;
                  	           		 ;	Canada							                             ;
                  	           		 ;	(updated mailing address for 1996)			                 ;
                  	           		 ;                                                                ;
                  	           		 ; Adapted to the Raptor64 by:                                    ;
                  	           		 ;    Robert Finch                                                ;
                  	           		 ;    Ontario, Canada                                             ;
                  	           		 ;	 robfinch<remove>@opencores.org	                             ;  
                  	           		 ;****************************************************************;
                  	           		 ;    Copyright (C) 2012 by Robert Finch. This program may be	 ;
                  	           		 ;    freely distributed for personal use only. All commercial	 ;
                  	           		 ;		       rights are reserved.			                     ;
                  	           		 ;****************************************************************;
                  	           		 ;
                  	           		 ; Register Usage
                  	           		 ; r8 = text pointer (global usage)
                  	           		 ; r3,r4 = inputs parameters to subroutines
                  	           		 ; r2 = return value
                  	           		 ;
                  	           		 ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                  	           		 ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                  	           		 ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                  	           		 
                  	           		 ;
                  	           		 ; Standard jump table. You can change these addresses if you are
                  	           		 ; customizing this interpreter for a different environment.
                  	           		 ;
FFFFFFFFFFFFCE44	           		 GOSTART:	
FFFFFFFFFFFFCE44	33FFF39C		 		jmp	CSTART	;	Cold Start entry point
FFFFFFFFFFFFCE48	           		 GOWARM:	
FFFFFFFFFFFFCE48	33FFF3BE		 		jmp	WSTART	;	Warm Start entry point
FFFFFFFFFFFFCE4C	           		 GOOUT:	
FFFFFFFFFFFFCE4C	33FFF95A		 		jmp	OUTC	;	Jump to character-out routine
FFFFFFFFFFFFCE50	           		 GOIN:	
FFFFFFFFFFFFCE50	33FFF95B		 		jmp	INC		;Jump to character-in routine
FFFFFFFFFFFFCE54	           		 GOAUXO:	
FFFFFFFFFFFFCE54	33FFF962		 		jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFFFFFFFFFFCE58	           		 GOAUXI:	
FFFFFFFFFFFFCE58	33FFF95C		 		jmp	AUXIN	;	Jump to auxiliary-in routine
FFFFFFFFFFFFCE5C	           		 GOBYE:	
FFFFFFFFFFFFCE5C	33FFF9EA		 		jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                  	           		 ;
                  	           		 ; Modifiable system constants:
                  	           		 ;
FFFFFFFFFFFFCE60	           		 		align	8
FFFFFFFFFFFFCE60 0000000010060000	 TXTBGN	dw	0x000000001_00600000	;TXT		;beginning of program memory
FFFFFFFFFFFFCE68 00000000107FFFF8	 ENDMEM	dw	0x000000001_07FFFFF8	;	end of available memory
                  	           		 ;
                  	           		 ; The main interpreter starts here:
                  	           		 ;
                  	           		 ; Usage
                  	           		 ; r1 = temp
                  	           		 ; r8 = text buffer pointer
                  	           		 ; r12 = end of text in text buffer
                  	           		 ;
FFFFFFFFFFFFCE70	           		 	align	16
FFFFFFFFFFFFCE70	           		 CSTART:
                  	           		 	; First save off the link register and OS sp value
FFFFFFFFFFFFCE70	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCE74	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFCE78	660F1088		 	sw		sp,OSSP
FFFFFFFFFFFFCE7C	460F4E68		 	lw		sp,ENDMEM	; initialize stack pointer
FFFFFFFFFFFFCE80	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFCE84	67EF8000		 	sw      lr,[sp]    ; save off return address
FFFFFFFFFFFFCE88	62001416		 	sc		r0,CursorRow	; set screen output
FFFFFFFFFFFFCE8C	62001418		 	sc		r0,CursorCol
FFFFFFFFFFFFCE90	6000141A		 	sb		r0,CursorFlash
FFFFFFFFFFFFCE94	6600103C		 	sw		r0,pos
FFFFFFFFFFFFCE98	E6800020		; SETLO
FFFFFFFFFFFFCE9C	EE800040		; SETMID
FFFFFFFFFFFFCEA0	040D0809		 	lw		r2,#0x10000020	; black chars, yellow background
FFFFFFFFFFFFCEA4	64011040		 	sh		r2,charToPrint
FFFFFFFFFFFFCEA8	31FFEED9		 	call	ClearScreen
FFFFFFFFFFFFCEAC	9A00E5C0		 	lea		r1,msgInit	;	tell who we are
FFFFFFFFFFFFCEB0	31FFF94D		 	call	PRMESGAUX
FFFFFFFFFFFFCEB4	9A00E5C0		 	lea		r1,msgInit	;	tell who we are
FFFFFFFFFFFFCEB8	31FFF940		 	call	PRMESG
FFFFFFFFFFFFCEBC	4600CE60		 	lw		r1,TXTBGN	;	init. end-of-program pointer
FFFFFFFFFFFFCEC0	660090D0		 	sw		r1,TXTUNF
FFFFFFFFFFFFCEC4	4600CE68		 	lw		r1,ENDMEM	;	get address of end of memory
FFFFFFFFFFFFCEC8	0E108800		 	subui	r1,r1,#2048	; 	reserve 2K for the stack
FFFFFFFFFFFFCECC	660090F8		 	sw		r1,STKBOT
FFFFFFFFFFFFCED0	0E10A000		 	subui   r1,r1,#8192 ;   1000 vars
FFFFFFFFFFFFCED4	660090D8		 	sw      r1,VARBGN
FFFFFFFFFFFFCED8	31FFF4C3		 	call    clearVars   ; clear the variable area
FFFFFFFFFFFFCEDC	460090D8		 	lw      r1,VARBGN   ; calculate number of bytes free
FFFFFFFFFFFFCEE0	460190D0		 	lw		r3,TXTUNF
FFFFFFFFFFFFCEE4	04118404		 	sub     r1,r1,r3
FFFFFFFFFFFFCEE8	E0800000		 	setlo	r2,#0
FFFFFFFFFFFFCEEC	31FFF88D		 	call	PRTNUM
FFFFFFFFFFFFCEF0	9A00E668		 	lea		r1,msgBytesFree
FFFFFFFFFFFFCEF4	31FFF940		 	call	PRMESG
FFFFFFFFFFFFCEF8	           		 WSTART:
FFFFFFFFFFFFCEF8	660010A8		 	sw		r0,LOPVAR   ; initialize internal variables
FFFFFFFFFFFFCEFC	66001098		 	sw		r0,STKGOS
FFFFFFFFFFFFCF00	66001090		 	sw		r0,CURRNT	;	current line number pointer = 0
FFFFFFFFFFFFCF04	460F4E68		 	lw		sp,ENDMEM	;	init S.P. again, just in case
FFFFFFFFFFFFCF08	9A00E676		 	lea		r1,msgReady	;	display "Ready"
FFFFFFFFFFFFCF0C	31FFF940		 	call	PRMESG
FFFFFFFFFFFFCF10	           		 ST3:
FFFFFFFFFFFFCF10	E040003E		 	setlo	r1,#'>'		; Prompt with a '>' and
FFFFFFFFFFFFCF14	31FFF7D8		 	call	GETLN		; read a line.
FFFFFFFFFFFFCF18	31FFF91D		 	call	TOUPBUF 	; convert to upper case
FFFFFFFFFFFFCF1C	02860009		 	mov		r12,r8		; save pointer to end of line
FFFFFFFFFFFFCF20	9A04111B		 	lea		r8,BUFFER	; point to the beginning of line
FFFFFFFFFFFFCF24	31FFF8FF		 	call	TSTNUM		; is there a number there?
FFFFFFFFFFFFCF28	31FFF914		 	call	IGNBLK		; skip trailing blanks
                  	           		 ; does line no. exist? (or nonzero?)
FFFFFFFFFFFFCF2C	BE101728		 	beq		r1,r0,DIRECT		; if not, it's a direct statement
FFFFFFFFFFFFCF30	AC1003FF		 	bleu	r1,#0xFFFF,ST2	; see if line no. is <= 16 bits
FFFFFFFFFFFFCF34	9A00E694		 	lea		r1,msgLineRange	; if not, we've overflowed
FFFFFFFFFFFFCF38	BE007F4A		 	bra		ERROR
FFFFFFFFFFFFCF3C	           		 ST2:
                  	           		     ; ugliness - store a character at potentially an
                  	           		     ; odd address (unaligned).
FFFFFFFFFFFFCF3C	02110009		 	mov		r2,r1       ; r2 = line number
FFFFFFFFFFFFCF40	60817FFE		 	sb		r2,-2[r8]
FFFFFFFFFFFFCF44	06211001		 	shrui	r2,r2,#8
FFFFFFFFFFFFCF48	60817FFF		 	sb		r2,-1[r8]	; store the binary line no.
FFFFFFFFFFFFCF4C	0E840002		 	subui	r8,r8,#2
FFFFFFFFFFFFCF50	31FFF80C		 	call	FNDLN		; find this line in save area
FFFFFFFFFFFFCF54	02968009		 	mov		r13,r9		; save possible line pointer
FFFFFFFFFFFFCF58	BE1001C8		 	beq		r1,r0,ST4	; if not found, insert
                  	           		 	; here we found the line, so we're replacing the line
                  	           		 	; in the text area
                  	           		 	; first step - delete the line
FFFFFFFFFFFFCF5C	E0400000		 	setlo	r1,#0
FFFFFFFFFFFFCF60	31FFF820		 	call	FNDNXT		; find the next line (into r9)
FFFFFFFFFFFFCF64	BE100049		 	bne		r1,r0,ST7
FFFFFFFFFFFFCF68	BE900108		 	beq		r9,r0,ST6	; no more lines
FFFFFFFFFFFFCF6C	           		 ST7:
FFFFFFFFFFFFCF6C	02908009		 	mov		r1,r9		; r1 = pointer to next line
FFFFFFFFFFFFCF70	02D10009		 	mov		r2,r13		; pointer to line to be deleted
FFFFFFFFFFFFCF74	460190D0		 	lw		r3,TXTUNF	; points to top of save area
FFFFFFFFFFFFCF78	31FFF829		 	call	MVUP		; move up to delete
FFFFFFFFFFFFCF7C	660110D0		 	sw		r2,TXTUNF	; update the end pointer
                  	           		 	; we moved the lines of text after the line being
                  	           		 	; deleted down, so the pointer to the next line
                  	           		 	; needs to be reset
FFFFFFFFFFFFCF80	02D48009		 	mov		r9,r13
FFFFFFFFFFFFCF84	BE00006A		 	bra		ST4
                  	           		 	; here there were no more lines, so just move the
                  	           		 	; end of text pointer down
FFFFFFFFFFFFCF88	           		 ST6:
FFFFFFFFFFFFCF88	660690D0		 	sw		r13,TXTUNF
FFFFFFFFFFFFCF8C	02D48009		 	mov		r9,r13
FFFFFFFFFFFFCF90	           		 ST4:
                  	           		 	; here we're inserting because the line wasn't found
                  	           		 	; or it was deleted	from the text area
FFFFFFFFFFFFCF90	02C08009		 	mov		r1,r12		; calculate the length of new line
FFFFFFFFFFFFCF94	04140404		 	sub		r1,r1,r8
FFFFFFFFFFFFCF98	A41FDE03		 	blei	r1,#3,ST3	; is it just a line no. & CR? if so, it was just a delete
                  	           		 
FFFFFFFFFFFFCF9C	460590D0		 	lw		r11,TXTUNF	; compute new end of text
FFFFFFFFFFFFCFA0	02B50009		 	mov		r10,r11		; r10 = old TXTUNF
FFFFFFFFFFFFCFA4	04B0AC02		 	add		r11,r11,r1		; r11 = new top of TXTUNF (r1=line length)
                  	           		 
FFFFFFFFFFFFCFA8	460090D8		 	lw		r1,VARBGN	; see if there's enough room
FFFFFFFFFFFFCFAC	BEB08064		 	bltu	r11,r1,ST5
FFFFFFFFFFFFCFB0	9A00E76F		 	lea		r1,msgTooBig	; if not, say so
FFFFFFFFFFFFCFB4	33FFF7C8		 	jmp		ERROR
                  	           		 
                  	           		 	; open a space in the text area
FFFFFFFFFFFFCFB8	           		 ST5:
FFFFFFFFFFFFCFB8	660590D0		 	sw		r11,TXTUNF	; if so, store new end position
FFFFFFFFFFFFCFBC	02A08009		 	mov		r1,r10		; points to old end of text
FFFFFFFFFFFFCFC0	02B10009		 	mov		r2,r11		; points to new end of text
FFFFFFFFFFFFCFC4	02918009		 	mov		r3,r9       ; points to start of line after insert line
FFFFFFFFFFFFCFC8	31FFF82F		 	call	MVDOWN		; move things out of the way
                  	           		 
                  	           		 	; copy line into text space
FFFFFFFFFFFFCFCC	02808009		 	mov		r1,r8		; set up to do the insertion; move from buffer
FFFFFFFFFFFFCFD0	02D10009		 	mov		r2,r13		; to vacated space
FFFFFFFFFFFFCFD4	02C18009		 	mov		r3,r12		; until end of buffer
FFFFFFFFFFFFCFD8	31FFF829		 	call	MVUP		; do it
FFFFFFFFFFFFCFDC	BE0079AA		 	bra		ST3			; go back and get another line
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** Tables *** DIRECT *** EXEC ***
                  	           		 ;
                  	           		 ; This section of the code tests a string against a table. When
                  	           		 ; a match is found, control is transferred to the section of
                  	           		 ; code according to the table.
                  	           		 ;
                  	           		 ; At 'EXEC', r8 should point to the string, r9 should point to
                  	           		 ; the character table, and r10 should point to the execution
                  	           		 ; table. At 'DIRECT', r8 should point to the string, r9 and
                  	           		 ; r10 will be set up to point to TAB1 and TAB1_1, which are
                  	           		 ; the tables of all direct and statement commands.
                  	           		 ;
                  	           		 ; A '.' in the string will terminate the test and the partial
                  	           		 ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                  	           		 ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                  	           		 ;
                  	           		 ; There are two tables: the character table and the execution
                  	           		 ; table. The character table consists of any number of text items.
                  	           		 ; Each item is a string of characters with the last character's
                  	           		 ; high bit set to one. The execution table holds a 32-bit
                  	           		 ; execution addresses that correspond to each entry in the
                  	           		 ; character table.
                  	           		 ;
                  	           		 ; The end of the character table is a 0 byte which corresponds
                  	           		 ; to the default routine in the execution table, which is
                  	           		 ; executed if none of the other table items are matched.
                  	           		 ;
                  	           		 ; Character-matching tables:
FFFFFFFFFFFFCFE0	           		 	align	8
FFFFFFFFFFFFCFE0	           		 TAB1:
FFFFFFFFFFFFCFE0 C4414F4CD453494C	 	db	"LOA",'D'+0x80
FFFFFFFFFFFFCFE8 4153CE5552D7454E	 	db	"SAV",'E'+0x80
FFFFFFFFFFFFCFF2	           		 TAB2:
FFFFFFFFFFFFCFF0 454CD458454EC556	 	db	"LE",'T'+0x80
FFFFFFFFFFFFCFF8 47CF544F47C649D4	 	db	"GOSU",'B'+0x80
FFFFFFFFFFFFD000 55544552C255534F	 	db	"RETUR",'N'+0x80
FFFFFFFFFFFFD008 D24F46CD4552CE52	 	db	"FO",'R'+0x80
FFFFFFFFFFFFD010 495250D455504E49	 	db	"PRIN",'T'+0x80
FFFFFFFFFFFFD018 50C3454B4F50D44E	 	db	"POKE",'H'+0x80
FFFFFFFFFFFFD020 454B4F50C8454B4F	 	db	"POKE",'W'+0x80
FFFFFFFFFFFFD028 4F5453C54B4F50D7	 	db	"STO",'P'+0x80
FFFFFFFFFFFFD030 43D35953C55942D0	 	db	"CL",'S'+0x80
FFFFFFFFFFFFD038 434452D24C43D34C	     db	"RDC",'F'+0x80
FFFFFFFFFFFFD042	           		 TAB4:
FFFFFFFFFFFFD040 50C34B45455000C6	 	db	"PEEK",'H'+0x80        ;Functions
FFFFFFFFFFFFD048 4B454550C84B4545	 	db	"PEEK",'W'+0x80        ;Functions
FFFFFFFFFFFFD050 C44E52CB454550D7	 	db	"RN",'D'+0x80
FFFFFFFFFFFFD058 55C55A4953D34241	 	db  "US",'R'+0x80
FFFFFFFFFFFFD063	           		 TAB5:
FFFFFFFFFFFFD066	           		 TAB6:
FFFFFFFFFFFFD060 545300CF5400D253	 	db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFFFFFFFFFFD06B	           		 TAB8:
FFFFFFFFFFFFD068 BEBE3CBD3E00D045	 	db	'>'+0x80
FFFFFFFFFFFFD075	           		 TAB9:
FFFFFFFFFFFFD070 C44E4100BCBD3CBD	     db  "AN",'D'+0x80
FFFFFFFFFFFFD079	           		 TAB10:
                  	           		 
FFFFFFFFFFFFD080	           		 	.align	8
                  	           		 
                  	           		 ;* Execution address tables:
FFFFFFFFFFFFD080	           		 TAB1_1:
FFFFFFFFFFFFD080 FFFFFFFFFFFFD338	 	dw	LISTX			;Direct commands
FFFFFFFFFFFFD088 FFFFFFFFFFFFD67C	 	dw	LOAD
FFFFFFFFFFFFD090 FFFFFFFFFFFFD284	 	dw	NEW
FFFFFFFFFFFFD098 FFFFFFFFFFFFD29C	 	dw	RUN
FFFFFFFFFFFFD0A0 FFFFFFFFFFFFD728	 	dw	SAVE
FFFFFFFFFFFFD0A8	           		 TAB2_1:
FFFFFFFFFFFFD0A8 FFFFFFFFFFFFD508	 	dw	NEXT		;	Direct / statement
FFFFFFFFFFFFD0B0 FFFFFFFFFFFFD664	 	dw	LET
FFFFFFFFFFFFD0B8 FFFFFFFFFFFFD578	 	dw	IF
FFFFFFFFFFFFD0C0 FFFFFFFFFFFFD2E4	 	dw	GOTO
FFFFFFFFFFFFD0C8 FFFFFFFFFFFFD418	 	dw	GOSUB
FFFFFFFFFFFFD0D0 FFFFFFFFFFFFD454	 	dw	RETURN
FFFFFFFFFFFFD0D8 FFFFFFFFFFFFD580	 	dw	IF2			; REM
FFFFFFFFFFFFD0E0 FFFFFFFFFFFFD48C	 	dw	FOR
FFFFFFFFFFFFD0E8 FFFFFFFFFFFFD5A8	 	dw	INPUT
FFFFFFFFFFFFD0F0 FFFFFFFFFFFFD380	 	dw	PRINT
FFFFFFFFFFFFD0F8 FFFFFFFFFFFFD83C	 	dw	POKEC
FFFFFFFFFFFFD100 FFFFFFFFFFFFD868	 	dw	POKEH
FFFFFFFFFFFFD108 FFFFFFFFFFFFD894	 	dw	POKEW
FFFFFFFFFFFFD110 FFFFFFFFFFFFD808	 	dw	POKE
FFFFFFFFFFFFD118 FFFFFFFFFFFFD294	 	dw	STOP
FFFFFFFFFFFFD120 FFFFFFFFFFFFCE5C	 	dw	GOBYE
FFFFFFFFFFFFD128 FFFFFFFFFFFFD8C0	 	dw	SYSX
FFFFFFFFFFFFD130 FFFFFFFFFFFFE58C	 	dw	_cls
FFFFFFFFFFFFD138 FFFFFFFFFFFFD304	 	dw  _clr
FFFFFFFFFFFFD140 FFFFFFFFFFFFE5A0	 	dw	_rdcf
FFFFFFFFFFFFD148 FFFFFFFFFFFFD65C	 	dw	DEFLT
FFFFFFFFFFFFD150	           		 TAB4_1:
FFFFFFFFFFFFD150 FFFFFFFFFFFFDD3C	 	dw  PEEKC
FFFFFFFFFFFFD158 FFFFFFFFFFFFDD50	 	dw  PEEKH
FFFFFFFFFFFFD160 FFFFFFFFFFFFDD64	 	dw  PEEKW
FFFFFFFFFFFFD168 FFFFFFFFFFFFDD2C	 	dw	PEEK			;Functions
FFFFFFFFFFFFD170 FFFFFFFFFFFFDD94	 	dw	RND
FFFFFFFFFFFFD178 FFFFFFFFFFFFDE2C	 	dw	ABS
FFFFFFFFFFFFD180 FFFFFFFFFFFFDE4C	 	dw	SIZEX
FFFFFFFFFFFFD188 FFFFFFFFFFFFDD78	 	dw  USRX
FFFFFFFFFFFFD190 FFFFFFFFFFFFDB50	 	dw	XP40
FFFFFFFFFFFFD198	           		 TAB5_1
FFFFFFFFFFFFD198 FFFFFFFFFFFFD4A4	 	dw	FR1			;"TO" in "FOR"
FFFFFFFFFFFFD1A0 FFFFFFFFFFFFDF1C	 	dw	QWHAT
FFFFFFFFFFFFD1A8	           		 TAB6_1
FFFFFFFFFFFFD1A8 FFFFFFFFFFFFD4B8	 	dw	FR2			;"STEP" in "FOR"
FFFFFFFFFFFFD1B0 FFFFFFFFFFFFD4C0	 	dw	FR3
FFFFFFFFFFFFD1B8	           		 TAB8_1
FFFFFFFFFFFFD1B8 FFFFFFFFFFFFD9D0	 	dw	XP11	;>=		Relational operators
FFFFFFFFFFFFD1C0 FFFFFFFFFFFFD9E0	 	dw	XP12	;<>
FFFFFFFFFFFFD1C8 FFFFFFFFFFFFD9F0	 	dw	XP13	;>
FFFFFFFFFFFFD1D0 FFFFFFFFFFFFDA10	 	dw	XP15	;=
FFFFFFFFFFFFD1D8 FFFFFFFFFFFFDA00	 	dw	XP14	;<=
FFFFFFFFFFFFD1E0 FFFFFFFFFFFFDA20	 	dw	XP16	;<
FFFFFFFFFFFFD1E8 FFFFFFFFFFFFDA48	 	dw	XP17
FFFFFFFFFFFFD1F0	           		 TAB9_1
FFFFFFFFFFFFD1F0 FFFFFFFFFFFFD93C	     dw  XP_AND
FFFFFFFFFFFFD1F8 FFFFFFFFFFFFD94C	     dw  XP_ANDX
FFFFFFFFFFFFD200	           		 TAB10_1
FFFFFFFFFFFFD200 FFFFFFFFFFFFD904	     dw  XP_OR
FFFFFFFFFFFFD208 FFFFFFFFFFFFD914	     dw  XP_ORX
                  	           		 
FFFFFFFFFFFFD210	           		 	.align	16
                  	           		 
                  	           		 ;*
                  	           		 ; r3 = match flag (trashed)
                  	           		 ; r9 = text table
                  	           		 ; r10 = exec table
                  	           		 ; r11 = trashed
FFFFFFFFFFFFD210	           		 DIRECT:
FFFFFFFFFFFFD210	9A04CFE0		 	lea		r9,TAB1
FFFFFFFFFFFFD214	9A055080		 	lea		r10,TAB1_1
FFFFFFFFFFFFD218	           		 EXEC:
FFFFFFFFFFFFD218	03F58009		 	mov		r11,lr		; save link reg
FFFFFFFFFFFFD21C	31FFF914		 	call	IGNBLK		; ignore leading blanks
FFFFFFFFFFFFD220	02BF8009		 	mov		lr,r11		; restore link reg
FFFFFFFFFFFFD224	02858009		 	mov		r11,r8		; save the pointer
FFFFFFFFFFFFD228	E0C00000		 	setlo	r3,#0		; clear match flag
FFFFFFFFFFFFD22C	           		 EXLP:
FFFFFFFFFFFFD22C	4A808000		 	lbu		r1,[r8]		; get the program character
FFFFFFFFFFFFD230	0A840001		 	addui	r8,r8,#1
FFFFFFFFFFFFD234	4A910000		 	lbu		r2,[r9]		; get the table character
FFFFFFFFFFFFD238	BE200069		 	bne		r2,r0,EXNGO		; If end of table,
FFFFFFFFFFFFD23C	02B40009		 	mov		r8,r11		;	restore the text pointer and...
FFFFFFFFFFFFD240	BE0001EA		 	bra		EXGO		;   execute the default.
FFFFFFFFFFFFD244	           		 EXNGO:
FFFFFFFFFFFFD244	BE1181C8		 	beq		r1,r3,EXGO	; Else check for period... if so, execute
FFFFFFFFFFFFD248	1421007F		 	andi	r2,r2,#0x7f	; ignore the table's high bit
FFFFFFFFFFFFD24C	BE208108		 	beq		r2,r1,EXMAT;		is there a match?
FFFFFFFFFFFFD250	0AA50008		 	addui	r10,r10,#8	;if not, try the next entry
FFFFFFFFFFFFD254	02B40009		 	mov		r8,r11		; reset the program pointer
FFFFFFFFFFFFD258	E0C00000		 	setlo	r3,#0		; sorry, no match
FFFFFFFFFFFFD25C	           		 EX1:
FFFFFFFFFFFFD25C	0A948001		 	addui	r9,r9,#1
FFFFFFFFFFFFD260	4090FFFF		 	lb		r1,-1[r9]	; get to the end of the entry
FFFFFFFFFFFFD264	BE107FC3		 	bgt		r1,r0,EX1
FFFFFFFFFFFFD268	BE007E2A		 	bra		EXLP		; back for more matching
FFFFFFFFFFFFD26C	           		 EXMAT:
FFFFFFFFFFFFD26C	E0C0002E		 	setlo	r3,#'.'		; we've got a match so far
FFFFFFFFFFFFD270	0A948001		 	addui	r9,r9,#1
FFFFFFFFFFFFD274	4090FFFF		 	lb		r1,-1[r9]	; end of table entry?
FFFFFFFFFFFFD278	BE107DA3		 	bgt		r1,r0,EXLP		; if not, go back for more
FFFFFFFFFFFFD27C	           		 EXGO:
FFFFFFFFFFFFD27C	46A58000		 	lw		r11,[r10]	; execute the appropriate routine
FFFFFFFFFFFFD280	34B00000		 	jal		r0,[r11]
                  	           		 
                  	           		 ;    lb      r1,[r8]     ; get token from text space
                  	           		 ;    bpl
                  	           		 ;    and     r1,#0x7f
                  	           		 ;    shl     r1,#2       ; * 4 - word offset
                  	           		 ;    add     r1,r1,#TAB1_1
                  	           		 ;    lw      r1,[r1]
                  	           		 ;    jmp     [r1]
                  	           		 
                  	           		     
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; What follows is the code to execute direct and statement
                  	           		 ; commands. Control is transferred to these points via the command
                  	           		 ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                  	           		 ; After the command is executed, control is transferred to other
                  	           		 ; sections as follows:
                  	           		 ;
                  	           		 ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                  	           		 ; For 'RUN': go execute the first stored line if any; else go
                  	           		 ; back to the warm start point.
                  	           		 ; For 'GOTO' and 'GOSUB': go execute the target line.
                  	           		 ; For 'RETURN' and 'NEXT'; go back to saved return line.
                  	           		 ; For all others: if 'CURRNT' is 0, go to warm start; else go
                  	           		 ; execute next command. (This is done in 'FINISH'.)
                  	           		 ;
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                  	           		 ;
                  	           		 ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                  	           		 ;
                  	           		 ; 'STOP<CR>' goes back to WSTART
                  	           		 ;
                  	           		 ; 'RUN<CR>' finds the first stored line, stores its address
                  	           		 ; in CURRNT, and starts executing it. Note that only those
                  	           		 ; commands in TAB2 are legal for a stored program.
                  	           		 ;
                  	           		 ; There are 3 more entries in 'RUN':
                  	           		 ; 'RUNNXL' finds next line, stores it's address and executes it.
                  	           		 ; 'RUNTSL' stores the address of this line and executes it.
                  	           		 ; 'RUNSML' continues the execution on same line.
                  	           		 ;
                  	           		 ; 'GOTO expr<CR>' evaluates the expression, finds the target
                  	           		 ; line, and jumps to 'RUNTSL' to do it.
                  	           		 ;
FFFFFFFFFFFFD284	           		 NEW:
FFFFFFFFFFFFD284	31FFF7B9		 	call	ENDCHK
FFFFFFFFFFFFD288	4600CE60		 	lw		r1,TXTBGN
FFFFFFFFFFFFD28C	660090D0		 	sw		r1,TXTUNF	;	set the end pointer
FFFFFFFFFFFFD290	31FFF4C3		 	call    clearVars
                  	           		 
FFFFFFFFFFFFD294	           		 STOP:
FFFFFFFFFFFFD294	31FFF7B9		 	call	ENDCHK
FFFFFFFFFFFFD298	BE00630A		 	bra		WSTART		; WSTART will reset the stack
                  	           		 
FFFFFFFFFFFFD29C	           		 RUN:
FFFFFFFFFFFFD29C	31FFF7B9		 	call	ENDCHK
FFFFFFFFFFFFD2A0	46044E60		 	lw		r8,TXTBGN	;	set pointer to beginning
FFFFFFFFFFFFD2A4	66041090		 	sw		r8,CURRNT
FFFFFFFFFFFFD2A8	31FFF4C3		 	call    clearVars
                  	           		 
FFFFFFFFFFFFD2AC	           		 RUNNXL:					; RUN <next line>
FFFFFFFFFFFFD2AC	46009090		 	lw		r1,CURRNT	; executing a program?
FFFFFFFFFFFFD2B0	BE106248		 	beq		r1,r0,WSTART	; if not, we've finished a direct stat.
FFFFFFFFFFFFD2B4	E0400000		 	setlo	r1,#0	    ; else find the next line number
FFFFFFFFFFFFD2B8	02848009		 	mov		r9,r8
FFFFFFFFFFFFD2BC	31FFF810		 	call	FNDLNP		; search for the next line
FFFFFFFFFFFFD2C0	BE100069		 	bne		r1,r0,RUNTSL
FFFFFFFFFFFFD2C4	BE900049		 	bne		r9,r0,RUNTSL
FFFFFFFFFFFFD2C8	BE00618A		 	bra		WSTART		; if we've fallen off the end, stop
                  	           		 
FFFFFFFFFFFFD2CC	           		 RUNTSL:					; RUN <this line>
FFFFFFFFFFFFD2CC	66049090		 	sw		r9,CURRNT	; set CURRNT to point to the line no.
FFFFFFFFFFFFD2D0	9A940002		 	lea		r8,2[r9]	; set the text pointer to
                  	           		 
FFFFFFFFFFFFD2D4	           		 RUNSML:                 ; RUN <same line>
FFFFFFFFFFFFD2D4	31FFF936		 	call	CHKIO		; see if a control-C was pressed
FFFFFFFFFFFFD2D8	9A04CFF2		 	lea		r9,TAB2		; find command in TAB2
FFFFFFFFFFFFD2DC	9A0550A8		 	lea		r10,TAB2_1
FFFFFFFFFFFFD2E0	BE0079CA		 	bra		EXEC		; and execute it
                  	           		 
FFFFFFFFFFFFD2E4	           		 GOTO:
FFFFFFFFFFFFD2E4	31FFF63A		 	call	OREXPR		;evaluate the following expression
FFFFFFFFFFFFD2E8	02128009		 	mov     r5,r1
FFFFFFFFFFFFD2EC	31FFF7B9		 	call	ENDCHK		;must find end of line
FFFFFFFFFFFFD2F0	02508009		 	mov     r1,r5
FFFFFFFFFFFFD2F4	31FFF80C		 	call	FNDLN		; find the target line
FFFFFFFFFFFFD2F8	BE107EA9		 	bne		r1,r0,RUNTSL		; go do it
FFFFFFFFFFFFD2FC	9A00E73B		 	lea		r1,msgBadGotoGosub
FFFFFFFFFFFFD300	BE00610A		 	bra		ERROR		; no such line no.
                  	           		 
FFFFFFFFFFFFD304	           		 _clr:
FFFFFFFFFFFFD304	31FFF4C3		     call    clearVars
FFFFFFFFFFFFD308	BE00084A		     bra     FINISH
                  	           		 
                  	           		 ; Clear the variable area of memory
FFFFFFFFFFFFD30C	           		 clearVars:
FFFFFFFFFFFFD30C	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFD310	67E30000		     sw		r6,[sp]
FFFFFFFFFFFFD314	67EF8008		     sw		lr,8[sp]
FFFFFFFFFFFFD318	E1800800		     setlo   r6,#2048    ; number of words to clear
FFFFFFFFFFFFD31C	460090D8		     lw      r1,VARBGN
FFFFFFFFFFFFD320	           		 cv1:
FFFFFFFFFFFFD320	66100000		     sw      r0,[r1]
FFFFFFFFFFFFD324	08108008		     add     r1,r1,#8
FFFFFFFFFFFFD328	BE037FCF		     loop	r6,cv1
FFFFFFFFFFFFD32C	47EF8008		     lw		lr,8[sp]
FFFFFFFFFFFFD330	47E30000		     lw		r6,[sp]
FFFFFFFFFFFFD334	37EF8010		     ret		#16
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; LIST
                  	           		 ;
                  	           		 ; LISTX has two forms:
                  	           		 ; 'LIST<CR>' lists all saved lines
                  	           		 ; 'LIST #<CR>' starts listing at the line #
                  	           		 ; Control-S pauses the listing, control-C stops it.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD338	           		 LISTX:
FFFFFFFFFFFFD338	31FFF8FF		 	call	TSTNUM		; see if there's a line no.
FFFFFFFFFFFFD33C	02128009		 	mov     r5,r1
FFFFFFFFFFFFD340	31FFF7B9		 	call	ENDCHK		; if not, we get a zero
FFFFFFFFFFFFD344	02508009		 	mov     r1,r5
FFFFFFFFFFFFD348	31FFF80C		 	call	FNDLN		; find this or next line
FFFFFFFFFFFFD34C	           		 LS1:
FFFFFFFFFFFFD34C	BE100049		 	bne		r1,r0,LS4
FFFFFFFFFFFFD350	BE905D48		 	beq		r9,r0,WSTART	; warm start if we passed the end
FFFFFFFFFFFFD354	           		 LS4:
FFFFFFFFFFFFD354	02908009		 	mov		r1,r9
FFFFFFFFFFFFD358	31FFF8DF		 	call	PRTLN		; print the line
FFFFFFFFFFFFD35C	02148009		 	mov		r9,r1		; set pointer for next
FFFFFFFFFFFFD360	31FFF936		 	call	CHKIO		; check for listing halt request
FFFFFFFFFFFFD364	BE100088		 	beq		r1,r0,LS3
FFFFFFFFFFFFD368	B2100313		 	bnei	r1,#CTRLS,LS3	; pause the listing?
FFFFFFFFFFFFD36C	           		 LS2:
FFFFFFFFFFFFD36C	31FFF936		 	call	CHKIO		; if so, wait for another keypress
FFFFFFFFFFFFD370	BE107FE8		 	beq		r1,r0,LS2
FFFFFFFFFFFFD374	           		 LS3:
FFFFFFFFFFFFD374	E0400000		 	setlo	r1,#0
FFFFFFFFFFFFD378	31FFF810		 	call	FNDLNP		; find the next line
FFFFFFFFFFFFD37C	BE007E8A		 	bra		LS1
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                  	           		 ; where '....' is a list of expressions, formats, back-arrows,
                  	           		 ; and strings.	These items a separated by commas.
                  	           		 ;
                  	           		 ; A format is a pound sign followed by a number.  It controls
                  	           		 ; the number of spaces the value of an expression is going to
                  	           		 ; be printed in.  It stays effective for the rest of the print
                  	           		 ; command unless changed by another format.  If no format is
                  	           		 ; specified, 11 positions will be used.
                  	           		 ;
                  	           		 ; A string is quoted in a pair of single- or double-quotes.
                  	           		 ;
                  	           		 ; An underline (back-arrow) means generate a <CR> without a <LF>
                  	           		 ;
                  	           		 ; A <CR LF> is generated after the entire list has been printed
                  	           		 ; or if the list is empty.  If the list ends with a semicolon,
                  	           		 ; however, no <CR LF> is generated.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD380	           		 PRINT:
FFFFFFFFFFFFD380	1602800B		 	lw		r5,#11		; D4 = number of print spaces
FFFFFFFFFFFFD384	E0C0003A		 	setlo	r3,#':'
FFFFFFFFFFFFD388	9A025398		 	lea		r4,PR2
FFFFFFFFFFFFD38C	31FFF8F1		 	call	TSTC		; if null list and ":"
FFFFFFFFFFFFD390	31FFEFFA		 	call	CRLF		; give CR-LF and continue
FFFFFFFFFFFFD394	BE007A0A		 	bra		RUNSML		;		execution on the same line
FFFFFFFFFFFFD398	           		 PR2:
FFFFFFFFFFFFD398	E0C0000D		 	setlo	r3,#CR
FFFFFFFFFFFFD39C	9A0253AC		 	lea		r4,PR0
FFFFFFFFFFFFD3A0	31FFF8F1		 	call	TSTC		;if null list and <CR>
FFFFFFFFFFFFD3A4	31FFEFFA		 	call	CRLF		;also give CR-LF and
FFFFFFFFFFFFD3A8	BE00782A		 	bra		RUNNXL		;execute the next line
FFFFFFFFFFFFD3AC	           		 PR0:
FFFFFFFFFFFFD3AC	E0C00023		 	setlo	r3,#'#'
FFFFFFFFFFFFD3B0	9A0253C4		 	lea		r4,PR1
FFFFFFFFFFFFD3B4	31FFF8F1		 	call	TSTC		;else is it a format?
FFFFFFFFFFFFD3B8	31FFF63A		 	call	OREXPR		; yes, evaluate expression
FFFFFFFFFFFFD3BC	04101409		 	lw		r5,r1		; and save it as print width
FFFFFFFFFFFFD3C0	BE00012A		 	bra		PR3		; look for more to print
FFFFFFFFFFFFD3C4	           		 PR1:
FFFFFFFFFFFFD3C4	E0C00024		 	setlo	r3,#'$'
FFFFFFFFFFFFD3C8	9A0253DC		 	lea		r4,PR4
FFFFFFFFFFFFD3CC	31FFF8F1		 	call	TSTC	;	is character expression? (MRL)
FFFFFFFFFFFFD3D0	31FFF63A		 	call	OREXPR	;	yep. Evaluate expression (MRL)
FFFFFFFFFFFFD3D4	31FFF393		 	call	GOOUT	;	print low byte (MRL)
FFFFFFFFFFFFD3D8	BE00006A		 	bra		PR3		;look for more. (MRL)
FFFFFFFFFFFFD3DC	           		 PR4:
FFFFFFFFFFFFD3DC	31FFF867		 	call	QTSTG	;	is it a string?
                  	           		 	; the following branch must occupy only two bytes!
FFFFFFFFFFFFD3E0	BE00010A		 	bra		PR8		;	if not, must be an expression
FFFFFFFFFFFFD3E4	           		 PR3:
FFFFFFFFFFFFD3E4	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFD3E8	9A0253F8		 	lea		r4,PR6
FFFFFFFFFFFFD3EC	31FFF8F1		 	call	TSTC	;	if ",", go find next
FFFFFFFFFFFFD3F0	31FFF7AA		 	call	FIN		;in the list.
FFFFFFFFFFFFD3F4	BE007DCA		 	bra		PR0
FFFFFFFFFFFFD3F8	           		 PR6:
FFFFFFFFFFFFD3F8	31FFEFFA		 	call	CRLF		;list ends here
FFFFFFFFFFFFD3FC	BE0000AA		 	bra		FINISH
FFFFFFFFFFFFD400	           		 PR8:
FFFFFFFFFFFFD400	31FFF63A		 	call	OREXPR		; evaluate the expression
FFFFFFFFFFFFD404	04500809		 	lw		r2,r5		; set the width
FFFFFFFFFFFFD408	31FFF88D		 	call	PRTNUM		; print its value
FFFFFFFFFFFFD40C	BE007ECA		 	bra		PR3			; more to print?
                  	           		 
FFFFFFFFFFFFD410	           		 FINISH:
FFFFFFFFFFFFD410	31FFF7AA		 	call	FIN		; Check end of command
FFFFFFFFFFFFD414	33FFF7C7		 	jmp		QWHAT	; print "What?" if wrong
                  	           		 
                  	           		 
                  	           		 ;*******************************************************************
                  	           		 ;
                  	           		 ; *** GOSUB *** & RETURN ***
                  	           		 ;
                  	           		 ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                  	           		 ; except that the current text pointer, stack pointer, etc. are
                  	           		 ; saved so that execution can be continued after the subroutine
                  	           		 ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                  	           		 ; recursive), the save area must be stacked.  The stack pointer
                  	           		 ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                  	           		 ; If we are in the main routine, 'STKGOS' is zero (this was done
                  	           		 ; in the initialization section of the interpreter), but we still
                  	           		 ; save it as a flag for no further 'RETURN's.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD418	           		 GOSUB:
FFFFFFFFFFFFD418	31FFF83E		 	call	PUSHA		; save the current 'FOR' parameters
FFFFFFFFFFFFD41C	31FFF63A		 	call	OREXPR		; get line number
FFFFFFFFFFFFD420	31FFF80C		 	call	FNDLN		; find the target line
FFFFFFFFFFFFD424	BE100069		 	bne		r1,r0,gosub1
FFFFFFFFFFFFD428	9A00E73B		 	lea		r1,msgBadGotoGosub
FFFFFFFFFFFFD42C	BE0057AA		 	bra		ERROR		; if not there, say "How?"
FFFFFFFFFFFFD430	           		 gosub1:
FFFFFFFFFFFFD430	0DEF0018		 	sub		sp,sp,#24
FFFFFFFFFFFFD434	67E40000		 	sw		r8,[sp]		; save text pointer
FFFFFFFFFFFFD438	46009090		 	lw		r1,CURRNT
FFFFFFFFFFFFD43C	67E08008		 	sw		r1,8[sp]	; found it, save old 'CURRNT'...
FFFFFFFFFFFFD440	46009098		 	lw		r1,STKGOS
FFFFFFFFFFFFD444	67E08010		 	sw		r1,16[sp]	; and 'STKGOS'
FFFFFFFFFFFFD448	660010A8		 	sw		r0,LOPVAR	; load new values
FFFFFFFFFFFFD44C	660F1098		 	sw		sp,STKGOS
FFFFFFFFFFFFD450	BE0073EA		 	bra		RUNTSL
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                  	           		 ; returns the execution to the command after the most recent
                  	           		 ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                  	           		 ; a 'GOSUB' and is thus an error.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD454	           		 RETURN:
FFFFFFFFFFFFD454	31FFF7B9		 	call	ENDCHK		; there should be just a <CR>
FFFFFFFFFFFFD458	46009098		 	lw		r1,STKGOS	; get old stack pointer
FFFFFFFFFFFFD45C	BE100069		 	bne		r1,r0,return1
FFFFFFFFFFFFD460	9A00E758		 	lea		r1,msgRetWoGosub
FFFFFFFFFFFFD464	BE0055EA		 	bra		ERROR		; if zero, it doesn't exist
FFFFFFFFFFFFD468	           		 return1:
FFFFFFFFFFFFD468	021F0009		 	mov		sp,r1		; else restore it
FFFFFFFFFFFFD46C	47E08010		 	lw		r1,16[sp]
FFFFFFFFFFFFD470	66009098		 	sw		r1,STKGOS	; and the old 'STKGOS'
FFFFFFFFFFFFD474	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFD478	66009090		 	sw		r1,CURRNT	; and the old 'CURRNT'
FFFFFFFFFFFFD47C	47E40000		 	lw		r8,[sp]		; and the old text pointer
FFFFFFFFFFFFD480	09EF0018		 	add		sp,sp,#24
FFFFFFFFFFFFD484	31FFF831		 	call	POPA		;and the old 'FOR' parameters
FFFFFFFFFFFFD488	BE007C4A		 	bra		FINISH		;and we are back home
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** FOR *** & NEXT ***
                  	           		 ;
                  	           		 ; 'FOR' has two forms:
                  	           		 ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                  	           		 ; The second form means the same thing as the first form with a
                  	           		 ; STEP of positive 1.  The interpreter will find the variable 'var'
                  	           		 ; and set its value to the current value of 'exp1'.  It also
                  	           		 ; evaluates 'exp2' and 'exp1' and saves all these together with
                  	           		 ; the text pointer, etc. in the 'FOR' save area, which consists of
                  	           		 ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                  	           		 ; already something in the save area (indicated by a non-zero
                  	           		 ; 'LOPVAR'), then the old save area is saved on the stack before
                  	           		 ; the new values are stored.  The interpreter will then dig in the
                  	           		 ; stack and find out if this same variable was used in another
                  	           		 ; currently active 'FOR' loop.  If that is the case, then the old
                  	           		 ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD48C	           		 FOR:
FFFFFFFFFFFFD48C	31FFF83E		 	call	PUSHA		; save the old 'FOR' save area
FFFFFFFFFFFFD490	31FFF798		 	call	SETVAL		; set the control variable
FFFFFFFFFFFFD494	660090A8		 	sw		r1,LOPVAR	; save its address
FFFFFFFFFFFFD498	9A04D063		 	lea		r9,TAB5
FFFFFFFFFFFFD49C	9A055198		 	lea		r10,TAB5_1; use 'EXEC' to test for 'TO'
FFFFFFFFFFFFD4A0	33FFF486		 	jmp		EXEC
FFFFFFFFFFFFD4A4	           		 FR1:
FFFFFFFFFFFFD4A4	31FFF63A		 	call	OREXPR		; evaluate the limit
FFFFFFFFFFFFD4A8	660090B8		 	sw		r1,LOPLMT	; save that
FFFFFFFFFFFFD4AC	9A04D066		 	lea		r9,TAB6
FFFFFFFFFFFFD4B0	9A0551A8		 	lea		r10,TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFFFFFFFFFFD4B4	33FFF486		 	jmp		EXEC
FFFFFFFFFFFFD4B8	           		 FR2:
FFFFFFFFFFFFD4B8	31FFF63A		 	call	OREXPR		; found it, get the step value
FFFFFFFFFFFFD4BC	BE00004A		 	bra		FR4
FFFFFFFFFFFFD4C0	           		 FR3:
FFFFFFFFFFFFD4C0	E0400001		 	setlo	r1,#1		; not found, step defaults to 1
FFFFFFFFFFFFD4C4	           		 FR4:
FFFFFFFFFFFFD4C4	660090B0		 	sw		r1,LOPINC	; save that too
FFFFFFFFFFFFD4C8	           		 FR5:
FFFFFFFFFFFFD4C8	46011090		 	lw		r2,CURRNT
FFFFFFFFFFFFD4CC	660110C0		 	sw		r2,LOPLN	; save address of current line number
FFFFFFFFFFFFD4D0	660410C8		 	sw		r8,LOPPT	; and text pointer
FFFFFFFFFFFFD4D4	05E00C09		 	lw		r3,sp		; dig into the stack to find 'LOPVAR'
FFFFFFFFFFFFD4D8	460310A8		 	lw		r6,LOPVAR
FFFFFFFFFFFFD4DC	BE00004A		 	bra		FR7
FFFFFFFFFFFFD4E0	           		 FR6:
FFFFFFFFFFFFD4E0	0A318028		 	addui	r3,r3,#40	; look at next stack frame
FFFFFFFFFFFFD4E4	           		 FR7:
FFFFFFFFFFFFD4E4	46310000		 	lw		r2,[r3]		; is it zero?
FFFFFFFFFFFFD4E8	BE2000E8		 	beq		r2,r0,FR8	; if so, we're done
FFFFFFFFFFFFD4EC	BE237FA9		 	bne		r2,r6,FR6	; same as current LOPVAR? nope, look some more
                  	           		 
FFFFFFFFFFFFD4F0	04300409		     lw      r1,r3       ; Else remove 5 long words from...
FFFFFFFFFFFFD4F4	0A310028		 	addui	r2,r3,#40   ; inside the stack.
FFFFFFFFFFFFD4F8	05E00C09		 	lw		r3,sp		
FFFFFFFFFFFFD4FC	31FFF82F		 	call	MVDOWN
FFFFFFFFFFFFD500	09EF0028		 	add		sp,sp,#40	; set the SP 5 long words up
FFFFFFFFFFFFD504	           		 FR8:
FFFFFFFFFFFFD504	BE00786A		     bra	    FINISH		; and continue execution
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'NEXT var' serves as the logical (not necessarily physical) end
                  	           		 ; of the 'FOR' loop.  The control variable 'var' is checked with
                  	           		 ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                  	           		 ; the stack to find the right one and purges all those that didn't
                  	           		 ; match.  Either way, it then adds the 'STEP' to that variable and
                  	           		 ; checks the result with against the limit value.  If it is within
                  	           		 ; the limit, control loops back to the command following the
                  	           		 ; 'FOR'.  If it's outside the limit, the save area is purged and
                  	           		 ; execution continues.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD508	           		 NEXT:
FFFFFFFFFFFFD508	E0400000		 	setlo	r1,#0		; don't allocate it
FFFFFFFFFFFFD50C	31FFF6EC		 	call	TSTV		; get address of variable
FFFFFFFFFFFFD510	BE100069		 	bne		r1,r0,NX4
FFFFFFFFFFFFD514	9A00E717		 	lea		r1,msgNextVar
FFFFFFFFFFFFD518	BE00504A		 	bra		ERROR		; if no variable, say "What?"
FFFFFFFFFFFFD51C	           		 NX4:
FFFFFFFFFFFFD51C	02148009		 	mov		r9,r1		; save variable's address
FFFFFFFFFFFFD520	           		 NX0:
FFFFFFFFFFFFD520	460090A8		 	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFFFFFFFFFFD524	BE100069		 	bne		r1,r0,NX5   ; had a FOR loop
FFFFFFFFFFFFD528	9A00E704		 	lea		r1,msgNextFor
FFFFFFFFFFFFD52C	BE004FAA		 	bra		ERROR
FFFFFFFFFFFFD530	           		 NX5:
FFFFFFFFFFFFD530	BE148068		 	beq		r1,r9,NX2	; else we check them OK, they agree
FFFFFFFFFFFFD534	31FFF831		 	call	POPA		; nope, let's see the next frame
FFFFFFFFFFFFD538	BE007F4A		 	bra		NX0
FFFFFFFFFFFFD53C	           		 NX2:
FFFFFFFFFFFFD53C	46908000		 	lw		r1,[r9]		; get control variable's value
FFFFFFFFFFFFD540	460110B0		 	lw		r2,LOPINC
FFFFFFFFFFFFD544	04110403		 	addu	r1,r1,r2	; add in loop increment
                  	           		 ;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFFFFFFFFFFD548	66908000		 	sw		r1,[r9]		; save control variable's new value
FFFFFFFFFFFFD54C	460190B8		 	lw		r3,LOPLMT	; get loop's limit value
FFFFFFFFFFFFD550	BE200063		 	bgt		r2,r0,NX1	; check loop increment, branch if loop increment is positive
FFFFFFFFFFFFD554	BE1180E0		 	blt		r1,r3,NXPurge	; test against limit
FFFFFFFFFFFFD558	BE00004A		 	bra     NX3
FFFFFFFFFFFFD55C	           		 NX1:
FFFFFFFFFFFFD55C	BE1180A3		 	bgt		r1,r3,NXPurge
FFFFFFFFFFFFD560	           		 NX3:
FFFFFFFFFFFFD560	460410C0		 	lw		r8,LOPLN	; Within limit, go back to the...
FFFFFFFFFFFFD564	66041090		 	sw		r8,CURRNT
FFFFFFFFFFFFD568	460410C8		 	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
FFFFFFFFFFFFD56C	BE00752A		 	bra		FINISH
FFFFFFFFFFFFD570	           		 NXPurge:
FFFFFFFFFFFFD570	31FFF831		     call    POPA        ; purge this loop
FFFFFFFFFFFFD574	BE0074EA		     bra     FINISH
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                  	           		 ;
                  	           		 ; 'REM' can be followed by anything and is ignored by the
                  	           		 ; interpreter.
                  	           		 ;
                  	           		 ;REM
                  	           		 ;    br	    IF2		    ; skip the rest of the line
                  	           		 ; 'IF' is followed by an expression, as a condition and one or
                  	           		 ; more commands (including other 'IF's) separated by colons.
                  	           		 ; Note that the word 'THEN' is not used.  The interpreter evaluates
                  	           		 ; the expression.  If it is non-zero, execution continues.  If it
                  	           		 ; is zero, the commands that follow are ignored and execution
                  	           		 ; continues on the next line.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD578	           		 IF:
FFFFFFFFFFFFD578	31FFF63A		     call	OREXPR		; evaluate the expression
FFFFFFFFFFFFD57C	           		 IF1:
FFFFFFFFFFFFD57C	BE106AC9		     bne	    r1,r0,RUNSML		; is it zero? if not, continue
FFFFFFFFFFFFD580	           		 IF2:
FFFFFFFFFFFFD580	02848009		     mov		r9,r8		; set lookup pointer
FFFFFFFFFFFFD584	E0400000		 	setlo	r1,#0		; find line #0 (impossible)
FFFFFFFFFFFFD588	31FFF821		 	call	FNDSKP		; if so, skip the rest of the line
FFFFFFFFFFFFD58C	BE104B63		 	bgt		r1,r0,WSTART	; if no next line, do a warm start
FFFFFFFFFFFFD590	           		 IF3:
FFFFFFFFFFFFD590	BE0069EA		 	bra		RUNTSL		; run the next line
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; INPUT is called first and establishes a stack frame
FFFFFFFFFFFFD594	           		 INPERR:
FFFFFFFFFFFFD594	460F10A0		 	lw		sp,STKINP	; restore the old stack pointer
FFFFFFFFFFFFD598	47E40010		 	lw		r8,16[sp]
FFFFFFFFFFFFD59C	66041090		 	sw		r8,CURRNT	; and old 'CURRNT'
FFFFFFFFFFFFD5A0	47E40008		 	lw		r8,8[sp]	; and old text pointer
FFFFFFFFFFFFD5A4	0BEF0028		 	addui	sp,sp,#40	; fall through will subtract 40
                  	           		 
                  	           		 ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                  	           		 ; of items.  If the item is a string in single or double quotes,
                  	           		 ; or is an underline (back arrow), it has the same effect as in
                  	           		 ; 'PRINT'.  If an item is a variable, this variable name is
                  	           		 ; printed out followed by a colon, then the interpreter waits for
                  	           		 ; an expression to be typed in.  The variable is then set to the
                  	           		 ; value of this expression.  If the variable is preceeded by a
                  	           		 ; string (again in single or double quotes), the string will be
                  	           		 ; displayed followed by a colon.  The interpreter the waits for an
                  	           		 ; expression to be entered and sets the variable equal to the
                  	           		 ; expression's value.  If the input expression is invalid, the
                  	           		 ; interpreter will print "What?", "How?", or "Sorry" and reprint
                  	           		 ; the prompt and redo the input.  The execution will not terminate
                  	           		 ; unless you press control-C.  This is handled in 'INPERR'.
                  	           		 ;
FFFFFFFFFFFFD5A8	           		 INPUT:
FFFFFFFFFFFFD5A8	0FEF0028		 	subui	sp,sp,#40	; allocate stack frame
FFFFFFFFFFFFD5AC	67E28020		 	sw      r5,32[sp]
FFFFFFFFFFFFD5B0	           		 IP6:
FFFFFFFFFFFFD5B0	67E40000		 	sw		r8,[sp]		; save in case of error
FFFFFFFFFFFFD5B4	31FFF867		 	call	QTSTG		; is next item a string?
FFFFFFFFFFFFD5B8	BE0000CA		 	bra		IP2			; nope - this branch must take only two bytes
FFFFFFFFFFFFD5BC	E0400001		 	setlo	r1,#1		; allocate var
FFFFFFFFFFFFD5C0	31FFF6EC		 	call	TSTV		; yes, but is it followed by a variable?
FFFFFFFFFFFFD5C4	BE1003E8		 	beq     r1,r0,IP4   ; if not, brnch
FFFFFFFFFFFFD5C8	02150009		 	mov		r10,r1		; put away the variable's address
FFFFFFFFFFFFD5CC	BE0001AA		 	bra		IP3			; if so, input to variable
FFFFFFFFFFFFD5D0	           		 IP2:
FFFFFFFFFFFFD5D0	67E40008		 	sw		r8,8[sp]	; save for 'PRTSTG'
FFFFFFFFFFFFD5D4	E0400001		 	setlo	r1,#1
FFFFFFFFFFFFD5D8	31FFF6EC		 	call	TSTV		; must be a variable now
FFFFFFFFFFFFD5DC	BE100069		 	bne		r1,r0,IP7
FFFFFFFFFFFFD5E0	9A00E6E7		 	lea		r1,msgInputVar
FFFFFFFFFFFFD5E4	BE0049EA		 	bra		ERROR		; "What?" it isn't?
FFFFFFFFFFFFD5E8	           		 IP7:
FFFFFFFFFFFFD5E8	02150009		 	mov		r10,r1		; put away the variable's address
FFFFFFFFFFFFD5EC	40828000		 	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
FFFFFFFFFFFFD5F0	60800000		 	sb		r0,[r8]
FFFFFFFFFFFFD5F4	47E08008		 	lw		r1,8[sp]	; get back text pointer
FFFFFFFFFFFFD5F8	31FFF851		 	call	PRTSTG		; print string as prompt
FFFFFFFFFFFFD5FC	60828000		 	sb		r5,[r8]		; un-null terminate
FFFFFFFFFFFFD600	           		 IP3
FFFFFFFFFFFFD600	67E40008		 	sw		r8,8[sp]	; save in case of error
FFFFFFFFFFFFD604	46009090		 	lw		r1,CURRNT
FFFFFFFFFFFFD608	67E08010		 	sw		r1,16[sp]	; also save 'CURRNT'
FFFFFFFFFFFFD60C	E07FFFFF		 	setlo	r1,#-1
FFFFFFFFFFFFD610	66009090		 	sw		r1,CURRNT	; flag that we are in INPUT
FFFFFFFFFFFFD614	660F10A0		 	sw		sp,STKINP	; save the stack pointer too
FFFFFFFFFFFFD618	67E50018		 	sw		r10,24[sp]	; save the variable address
FFFFFFFFFFFFD61C	E040003A		 	setlo	r1,#':'		; print a colon first
FFFFFFFFFFFFD620	31FFF7D8		 	call	GETLN		; then get an input line
FFFFFFFFFFFFD624	9A04111B		 	lea		r8,BUFFER	; point to the buffer
FFFFFFFFFFFFD628	31FFF63A		 	call	OREXPR		; evaluate the input
FFFFFFFFFFFFD62C	47E50018		 	lw		r10,24[sp]	; restore the variable address
FFFFFFFFFFFFD630	66A08000		 	sw		r1,[r10]	; save value in variable
FFFFFFFFFFFFD634	47E08010		 	lw		r1,16[sp]	; restore old 'CURRNT'
FFFFFFFFFFFFD638	66009090		 	sw		r1,CURRNT
FFFFFFFFFFFFD63C	47E40008		 	lw		r8,8[sp]	; and the old text pointer
FFFFFFFFFFFFD640	           		 IP4:
FFFFFFFFFFFFD640	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFD644	9A025650		 	lea		r4,IP5		; is the next thing a comma?
FFFFFFFFFFFFD648	31FFF8F1		 	call	TSTC
FFFFFFFFFFFFD64C	BE007B2A		 	bra		IP6			; yes, more items
FFFFFFFFFFFFD650	           		 IP5:
FFFFFFFFFFFFD650	47E28020		     lw      r5,32[sp]
FFFFFFFFFFFFD654	09EF0028		 	add		sp,sp,#40	; clean up the stack
FFFFFFFFFFFFD658	33FFF504		 	jmp		FINISH
                  	           		 
                  	           		 
FFFFFFFFFFFFD65C	           		 DEFLT:
FFFFFFFFFFFFD65C	40808000		     lb      r1,[r8]
FFFFFFFFFFFFD660	B01F6C0D		 	beq	    r1,#CR,FINISH	    ; empty line is OK else it is 'LET'
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'LET' is followed by a list of items separated by commas.
                  	           		 ; Each item consists of a variable, an equals sign, and an
                  	           		 ; expression.  The interpreter evaluates the expression and sets
                  	           		 ; the variable to that value.  The interpreter will also handle
                  	           		 ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD664	           		 LET:
FFFFFFFFFFFFD664	31FFF798		     call	SETVAL		; do the assignment
FFFFFFFFFFFFD668	E0C0002C		     setlo	r3,#','
FFFFFFFFFFFFD66C	9A025410		     lea		r4,FINISH
FFFFFFFFFFFFD670	31FFF8F1		 	call	TSTC		; check for more 'LET' items
FFFFFFFFFFFFD674	BE007F8A		 	bra	    LET
FFFFFFFFFFFFD678	           		 LT1:
FFFFFFFFFFFFD678	BE006CCA		     bra	    FINISH		; until we are finished.
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** LOAD *** & SAVE ***
                  	           		 ;
                  	           		 ; These two commands transfer a program to/from an auxiliary
                  	           		 ; device such as a cassette, another computer, etc.  The program
                  	           		 ; is converted to an easily-stored format: each line starts with
                  	           		 ; a colon, the line no. as 4 hex digits, and the rest of the line.
                  	           		 ; At the end, a line starting with an '@' sign is sent.  This
                  	           		 ; format can be read back with a minimum of processing time by
                  	           		 ; the Butterfly.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD67C	           		 LOAD
FFFFFFFFFFFFD67C	46044E60		 	lw		r8,TXTBGN	; set pointer to start of prog. area
FFFFFFFFFFFFD680	E040000D		 	setlo	r1,#CR		; For a CP/M host, tell it we're ready...
FFFFFFFFFFFFD684	31FFF395		 	call	GOAUXO		; by sending a CR to finish PIP command.
FFFFFFFFFFFFD688	           		 LOD1:
FFFFFFFFFFFFD688	31FFF396		 	call	GOAUXI		; look for start of line
FFFFFFFFFFFFD68C	BE107FE2		 	ble		r1,r0,LOD1
FFFFFFFFFFFFD690	B0100E40		 	beq		r1,#'@',LODEND	; end of program?
FFFFFFFFFFFFD694	B0100D1A		 	beq     r1,#0x1A,LODEND	; or EOF marker
FFFFFFFFFFFFD698	B21FFC3A		 	bne		r1,#':',LOD1	; if not, is it start of line? if not, wait for it
FFFFFFFFFFFFD69C	31FFF5B4		 	call	GCHAR		; get line number
FFFFFFFFFFFFD6A0	60808000		 	sb		r1,[r8]		; store it
FFFFFFFFFFFFD6A4	06109001		 	shrui	r1,r1,#8
FFFFFFFFFFFFD6A8	60808001		 	sb		r1,1[r8]
FFFFFFFFFFFFD6AC	0A840002		 	addui	r8,r8,#2
FFFFFFFFFFFFD6B0	           		 LOD2:
FFFFFFFFFFFFD6B0	31FFF396		 	call	GOAUXI		; get another text char.
FFFFFFFFFFFFD6B4	BE107FE2		 	ble		r1,r0,LOD2
FFFFFFFFFFFFD6B8	60808000		 	sb		r1,[r8]
FFFFFFFFFFFFD6BC	0A840001		 	addui	r8,r8,#1	; store it
FFFFFFFFFFFFD6C0	B21FFC0D		 	bne		r1,#CR,LOD2		; is it the end of the line? if not, go back for more
FFFFFFFFFFFFD6C4	BE007E2A		 	bra		LOD1		; if so, start a new line
FFFFFFFFFFFFD6C8	           		 LODEND:
FFFFFFFFFFFFD6C8	660410D0		 	sw		r8,TXTUNF	; set end-of program pointer
FFFFFFFFFFFFD6CC	BE00416A		 	bra		WSTART		; back to direct mode
                  	           		 
                  	           		 
                  	           		 ; get character from input (16 bit value)
FFFFFFFFFFFFD6D0	           		 GCHAR:
FFFFFFFFFFFFD6D0	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFD6D4	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFD6D8	67E30008		 	sw		r6,8[sp]
FFFFFFFFFFFFD6DC	67EF8010		 	sw		lr,16[sp]
FFFFFFFFFFFFD6E0	E1800003		 	setlo   r6,#3       ; repeat four times
FFFFFFFFFFFFD6E4	E1400000		 	setlo	r5,#0
FFFFFFFFFFFFD6E8	           		 GCHAR1:
FFFFFFFFFFFFD6E8	31FFF396		 	call	GOAUXI		; get a char
FFFFFFFFFFFFD6EC	BE107FE2		 	ble		r1,r0,GCHAR1
FFFFFFFFFFFFD6F0	31FFF5C5		 	call	asciiToHex
FFFFFFFFFFFFD6F4	06528800		 	shli	r5,r5,#4
FFFFFFFFFFFFD6F8	04509409		 	or		r5,r5,r1
FFFFFFFFFFFFD6FC	BE037F6F		 	loop	r6,GCHAR1
FFFFFFFFFFFFD700	02508009		 	mov		r1,r5
FFFFFFFFFFFFD704	47EF8010		 	lw		lr,16[sp]
FFFFFFFFFFFFD708	47E30008		 	lw		r6,8[sp]
FFFFFFFFFFFFD70C	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFD710	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; convert an ascii char to hex code
                  	           		 ; input
                  	           		 ;	r1 = char to convert
                  	           		 
FFFFFFFFFFFFD714	           		 asciiToHex:
FFFFFFFFFFFFD714	A4100239		 	blei	r1,#'9',a2h1	; less than '9'
FFFFFFFFFFFFD718	0E108007		 	subui	r1,r1,#7	; shift 'A' to '9'+1
FFFFFFFFFFFFD71C	           		 a2h1:
FFFFFFFFFFFFD71C	0E108030		 	subui	r1,r1,#'0'	;
FFFFFFFFFFFFD720	1410800F		 	andi	r1,r1,#15	; make sure a nybble
FFFFFFFFFFFFD724	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 
FFFFFFFFFFFFD728	           		 SAVE:
FFFFFFFFFFFFD728	46044E60		 	lw		r8,TXTBGN	;set pointer to start of prog. area
FFFFFFFFFFFFD72C	460490D0		 	lw		r9,TXTUNF	;set pointer to end of prog. area
FFFFFFFFFFFFD730	           		 SAVE1:
FFFFFFFFFFFFD730	31FFF5E1		 	call    AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFFFFFFFFFFD734	BE8481C5		 	bgeu	r8,r9,SAVEND	; are we finished?
FFFFFFFFFFFFD738	E040003A		 	setlo	r1,#':'		; if not, start a line
FFFFFFFFFFFFD73C	31FFF395		 	call	GOAUXO
FFFFFFFFFFFFD740	4A808000		 	lbu		r1,[r8]		; get line number
FFFFFFFFFFFFD744	4A810001		 	lbu		r2,1[r8]
FFFFFFFFFFFFD748	06211000		 	shli	r2,r2,#8
FFFFFFFFFFFFD74C	04110409		 	or		r1,r1,r2
FFFFFFFFFFFFD750	0A840002		 	addui	r8,r8,#2
FFFFFFFFFFFFD754	31FFF5E9		 	call	PWORD       ; output line number as 4-digit hex
FFFFFFFFFFFFD758	           		 SAVE2:
FFFFFFFFFFFFD758	40808000		 	lb		r1,[r8]		; get a text char.
FFFFFFFFFFFFD75C	0A840001		 	addui	r8,r8,#1
FFFFFFFFFFFFD760	B01FF40D		 	beqi	r1,#CR,SAVE1		; is it the end of the line? if so, send CR & LF and start new line
FFFFFFFFFFFFD764	31FFF395		 	call	GOAUXO		; send it out
FFFFFFFFFFFFD768	BE007F8A		 	bra		SAVE2		; go back for more text
FFFFFFFFFFFFD76C	           		 SAVEND:
FFFFFFFFFFFFD76C	E0400040		 	setlo	r1,#'@'		; send end-of-program indicator
FFFFFFFFFFFFD770	31FFF395		 	call	GOAUXO
FFFFFFFFFFFFD774	31FFF5E1		 	call    AUXOCRLF    ; followed by a CR & LF
FFFFFFFFFFFFD778	E040001A		 	setlo	r1,#0x1A	; and a control-Z to end the CP/M file
FFFFFFFFFFFFD77C	31FFF395		 	call	GOAUXO
FFFFFFFFFFFFD780	BE003BCA		 	bra		WSTART		; then go do a warm start
                  	           		 
                  	           		 
                  	           		 ; output a CR LF sequence to auxillary output
                  	           		 ; Registers Affected
                  	           		 ;   r3 = LF
FFFFFFFFFFFFD784	           		 AUXOCRLF:
FFFFFFFFFFFFD784	0FEF0008		     subui   sp,sp,#8
FFFFFFFFFFFFD788	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFD78C	E040000D		     setlo   r1,#CR
FFFFFFFFFFFFD790	31FFF395		     call    GOAUXO
FFFFFFFFFFFFD794	E040000A		     setlo   r1,#LF
FFFFFFFFFFFFD798	31FFF395		     call    GOAUXO
FFFFFFFFFFFFD79C	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFD7A0	37EF8008		     ret		#8
                  	           		 
                  	           		 
                  	           		 ; output a word in hex format
                  	           		 ; tricky because of the need to reverse the order of the chars
FFFFFFFFFFFFD7A4	           		 PWORD:
FFFFFFFFFFFFD7A4	0DEF0010		 	sub		sp,sp,#16
FFFFFFFFFFFFD7A8	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD7AC	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFD7B0	9A02910F		 	lea		r5,NUMWKA+15
FFFFFFFFFFFFD7B4	02120009		 	mov		r4,r1		; r4 = value
FFFFFFFFFFFFD7B8	           		 pword1:
FFFFFFFFFFFFD7B8	02408009		     mov     r1,r4	    ; r1 = value
FFFFFFFFFFFFD7BC	06420801		     shrui	r4,r4,#4	; shift over to next nybble
FFFFFFFFFFFFD7C0	31FFF5FD		     call    toAsciiHex  ; convert LS nybble to ascii hex
FFFFFFFFFFFFD7C4	60508000		     sb      r1,[r5]     ; save in work area
FFFFFFFFFFFFD7C8	0E528001		     subui   r5,r5,#1
FFFFFFFFFFFFD7CC	12509100		     cmpui   r1,r5,#NUMWKA
FFFFFFFFFFFFD7D0	BE107F41		     bge     r1,r0,pword1
FFFFFFFFFFFFD7D4	           		 pword2:
FFFFFFFFFFFFD7D4	0A528001		     addui   r5,r5,#1
FFFFFFFFFFFFD7D8	40508000		     lb      r1,[r5]     ; get char to output
FFFFFFFFFFFFD7DC	31FFF395		 	call	GOAUXO		; send it
FFFFFFFFFFFFD7E0	1250910F		 	cmpui   r1,r5,#NUMWKA+15
FFFFFFFFFFFFD7E4	BE107F80		 	blt     r1,r0,pword2
FFFFFFFFFFFFD7E8	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFD7EC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFD7F0	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; convert nybble in r2 to ascii hex char2
                  	           		 ; r2 = character to convert
                  	           		 
FFFFFFFFFFFFD7F4	           		 toAsciiHex:
FFFFFFFFFFFFD7F4	1410800F		 	andi	r1,r1,#15	; make sure it's a nybble
FFFFFFFFFFFFD7F8	A010020A		 	blti	r1,#10,tah1	; > 10 ?
FFFFFFFFFFFFD7FC	08108007		 	addi	r1,r1,#7	; bump it up to the letter 'A'
FFFFFFFFFFFFD800	           		 tah1:
FFFFFFFFFFFFD800	0A108030		 	addui	r1,r1,#'0'	; bump up to ascii '0'
FFFFFFFFFFFFD804	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** POKE *** & SYSX ***
                  	           		 ;
                  	           		 ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                  	           		 ; address specified by 'expr1'.
                  	           		 ;
                  	           		 ; 'SYSX expr' jumps to the machine language subroutine whose
                  	           		 ; starting address is specified by 'expr'.  The subroutine can use
                  	           		 ; all registers but must leave the stack the way it found it.
                  	           		 ; The subroutine returns to the interpreter by executing an RET.
                  	           		 ;******************************************************************
                  	           		 ;
FFFFFFFFFFFFD808	           		 POKE:
FFFFFFFFFFFFD808	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFD80C	31FFF63A		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFD810	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFD814	9A025834		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFD818	31FFF8F1		 	call	TSTC		; it must be followed by a comma
FFFFFFFFFFFFD81C	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFD820	31FFF63A		 	call	OREXPR		; get the byte to be POKE'd
FFFFFFFFFFFFD824	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFD828	60208000		 	sb		r1,[r2]		; store the byte in memory
FFFFFFFFFFFFD82C	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFD830	BE005F0A		 	bra		FINISH
FFFFFFFFFFFFD834	           		 PKER:
FFFFFFFFFFFFD834	9A00E680		 	lea		r1,msgComma
FFFFFFFFFFFFD838	BE00374A		 	bra		ERROR		; if no comma, say "What?"
                  	           		 
FFFFFFFFFFFFD83C	           		 POKEC:
FFFFFFFFFFFFD83C	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFD840	31FFF63A		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFD844	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFD848	9A025834		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFD84C	31FFF8F1		 	call	TSTC		; it must be followed by a comma
FFFFFFFFFFFFD850	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFD854	31FFF63A		 	call	OREXPR		; get the byte to be POKE'd
FFFFFFFFFFFFD858	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFD85C	62208000		 	sc		r1,[r2]		; store the char in memory
FFFFFFFFFFFFD860	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFD864	33FFF504		 	jmp		FINISH
                  	           		 
FFFFFFFFFFFFD868	           		 POKEH:
FFFFFFFFFFFFD868	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFD86C	31FFF63A		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFD870	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFD874	9A025834		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFD878	31FFF8F1		 	call	TSTC
FFFFFFFFFFFFD87C	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFD880	31FFF63A		 	call	OREXPR		; get the byte to be POKE'd
FFFFFFFFFFFFD884	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFD888	64208000		 	sh		r1,[r2]		; store the word in memory
FFFFFFFFFFFFD88C	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFD890	33FFF504		 	jmp		FINISH
                  	           		 
FFFFFFFFFFFFD894	           		 POKEW:
FFFFFFFFFFFFD894	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFD898	31FFF63A		 	call	OREXPR		; get the memory address
FFFFFFFFFFFFD89C	E0C0002C		 	setlo	r3,#','
FFFFFFFFFFFFD8A0	9A025834		 	lea		r4,PKER		; it must be followed by a comma
FFFFFFFFFFFFD8A4	31FFF8F1		 	call	TSTC
FFFFFFFFFFFFD8A8	67E08000		 	sw		r1,[sp]	    ; save the address
FFFFFFFFFFFFD8AC	31FFF63A		 	call	OREXPR		; get the word to be POKE'd
FFFFFFFFFFFFD8B0	47E10000		 	lw		r2,[sp]	    ; get the address back
FFFFFFFFFFFFD8B4	66208000		 	sw		r1,[r2]		; store the word in memory
FFFFFFFFFFFFD8B8	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFD8BC	33FFF504		 	jmp		FINISH
                  	           		 
FFFFFFFFFFFFD8C0	           		 SYSX:
FFFFFFFFFFFFD8C0	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFD8C4	31FFF63A		 	call	OREXPR		; get the subroutine's address
FFFFFFFFFFFFD8C8	BE100069		 	bne		r1,r0,sysx1	; make sure we got a valid address
FFFFFFFFFFFFD8CC	9A00E6D5		 	lea		r1,msgSYSBad
FFFFFFFFFFFFD8D0	BE00328A		 	bra		ERROR
FFFFFFFFFFFFD8D4	           		 sysx1:
FFFFFFFFFFFFD8D4	67E40000		 	sw		r8,[sp]	    ; save the text pointer
FFFFFFFFFFFFD8D8	341F8000		 	jal		r31,[r1]	; jump to the subroutine
FFFFFFFFFFFFD8DC	47E40000		 	lw		r8,[sp]	    ; restore the text pointer
FFFFFFFFFFFFD8E0	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFD8E4	BE00596A		 	bra		FINISH
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; *** EXPR ***
                  	           		 ;
                  	           		 ; 'EXPR' evaluates arithmetical or logical expressions.
                  	           		 ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                  	           		 ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                  	           		 ; <EXPR>::=<EXPR2>
                  	           		 ;	   <EXPR2><rel.op.><EXPR2>
                  	           		 ; where <rel.op.> is one of the operators in TAB8 and the result
                  	           		 ; of these operations is 1 if true and 0 if false.
                  	           		 ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                  	           		 ; where () are optional and (... are optional repeats.
                  	           		 ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                  	           		 ; <EXPR4>::=<variable>
                  	           		 ;	    <function>
                  	           		 ;	    (<EXPR>)
                  	           		 ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                  	           		 ; as an index, functions can have an <EXPR> as arguments, and
                  	           		 ; <EXPR4> can be an <EXPR> in parenthesis.
                  	           		 ;
                  	           		 
                  	           		 ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                  	           		 ;
FFFFFFFFFFFFD8E8	           		 OREXPR:
FFFFFFFFFFFFD8E8	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFD8EC	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD8F0	31FFF648		 	call	ANDEXPR		; get first <ANDEXPR>
FFFFFFFFFFFFD8F4	           		 XP_OR1:
FFFFFFFFFFFFD8F4	67E08004		 	sw		r1,4[sp]	; save <ANDEXPR> value
FFFFFFFFFFFFD8F8	9A04D079		 	lea		r9,TAB10	; look up a logical operator
FFFFFFFFFFFFD8FC	9A055200		 	lea		r10,TAB10_1
FFFFFFFFFFFFD900	33FFF486		 	jmp		EXEC		; go do it
FFFFFFFFFFFFD904	           		 XP_OR:
FFFFFFFFFFFFD904	31FFF648		     call    ANDEXPR
FFFFFFFFFFFFD908	47E10008		     lw      r2,8[sp]
FFFFFFFFFFFFD90C	04110409		     or      r1,r1,r2
FFFFFFFFFFFFD910	BE007F2A		     bra     XP_OR1
FFFFFFFFFFFFD914	           		 XP_ORX:
FFFFFFFFFFFFD914	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFD918	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFD91C	37EF8010		     ret		#16
                  	           		 
                  	           		 
                  	           		 ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                  	           		 ;
FFFFFFFFFFFFD920	           		 ANDEXPR:
FFFFFFFFFFFFD920	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFD924	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD928	31FFF66D		 	call	EXPR		; get first <EXPR>
FFFFFFFFFFFFD92C	           		 XP_AND1:
FFFFFFFFFFFFD92C	67E08008		 	sw		r1,8[sp]	; save <EXPR> value
FFFFFFFFFFFFD930	9A04D075		 	lea		r9,TAB9		; look up a logical operator
FFFFFFFFFFFFD934	9A0551F0		 	lea		r10,TAB9_1
FFFFFFFFFFFFD938	33FFF486		 	jmp		EXEC		; go do it
FFFFFFFFFFFFD93C	           		 XP_AND:
FFFFFFFFFFFFD93C	31FFF66D		     call    EXPR
FFFFFFFFFFFFD940	47E10008		     lw      r2,8[sp]
FFFFFFFFFFFFD944	04110408		     and     r1,r1,r2
FFFFFFFFFFFFD948	BE007F2A		     bra     XP_AND1
FFFFFFFFFFFFD94C	           		 XP_ANDX:
FFFFFFFFFFFFD94C	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFD950	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFD954	37EF8010		     ret		#16
                  	           		 
                  	           		 
                  	           		 ; Determine if the character is a digit
                  	           		 ;   Parameters
                  	           		 ;       r1 = char to test
                  	           		 ;   Returns
                  	           		 ;       r1 = 1 if digit, otherwise 0
                  	           		 ;
FFFFFFFFFFFFD958	           		 isDigit:
FFFFFFFFFFFFD958	A0100430		     blt     r1,#'0',isDigitFalse
FFFFFFFFFFFFD95C	A6100339		     bgt     r1,#'9',isDigitFalse
FFFFFFFFFFFFD960	E0400001		     setlo   r1,#1
FFFFFFFFFFFFD964	37EF8000		     ret
FFFFFFFFFFFFD968	           		 isDigitFalse:
FFFFFFFFFFFFD968	E0400000		     setlo   r1,#0
FFFFFFFFFFFFD96C	37EF8000		     ret
                  	           		 
                  	           		 
                  	           		 ; Determine if the character is a alphabetic
                  	           		 ;   Parameters
                  	           		 ;       r1 = char to test
                  	           		 ;   Returns
                  	           		 ;       r1 = 1 if alpha, otherwise 0
                  	           		 ;
FFFFFFFFFFFFD970	           		 isAlpha:
FFFFFFFFFFFFD970	A0100641		     blt     r1,#'A',isAlphaFalse
FFFFFFFFFFFFD974	A410035A		     ble     r1,#'Z',isAlphaTrue
FFFFFFFFFFFFD978	A0100461		     blt     r1,#'a',isAlphaFalse
FFFFFFFFFFFFD97C	A610037A		     bgt     r1,#'z',isAlphaFalse
FFFFFFFFFFFFD980	           		 isAlphaTrue:
FFFFFFFFFFFFD980	E0400001		     setlo   r1,#1
FFFFFFFFFFFFD984	37EF8000		     ret
FFFFFFFFFFFFD988	           		 isAlphaFalse:
FFFFFFFFFFFFD988	E0400000		     setlo   r1,#0
FFFFFFFFFFFFD98C	37EF8000		     ret
                  	           		 
                  	           		 
                  	           		 ; Determine if the character is a alphanumeric
                  	           		 ;   Parameters
                  	           		 ;       r1 = char to test
                  	           		 ;   Returns
                  	           		 ;       r1 = 1 if alpha, otherwise 0
                  	           		 ;
FFFFFFFFFFFFD990	           		 isAlnum:
FFFFFFFFFFFFD990	0FEF0008		     subui   sp,sp,#8
FFFFFFFFFFFFD994	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFD998	04100809		     or      r2,r1,r0		; save test char
FFFFFFFFFFFFD99C	31FFF656		     call    isDigit
FFFFFFFFFFFFD9A0	BE100069		     bne		r1,r0,isDigitx	; if it is a digit
FFFFFFFFFFFFD9A4	04200409		     or      r1,r2,r0		; get back test char
FFFFFFFFFFFFD9A8	31FFF65C		     call    isAlpha
FFFFFFFFFFFFD9AC	           		 isDigitx:
FFFFFFFFFFFFD9AC	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFD9B0	37EF8008		     ret		#8
                  	           		 
                  	           		 
FFFFFFFFFFFFD9B4	           		 EXPR:
FFFFFFFFFFFFD9B4	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFD9B8	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFD9BC	31FFF69C		 	call	EXPR2
FFFFFFFFFFFFD9C0	67E08008		 	sw		r1,8[sp]	; save <EXPR2> value
FFFFFFFFFFFFD9C4	9A04D06B		 	lea		r9,TAB8		; look up a relational operator
FFFFFFFFFFFFD9C8	9A0551B8		 	lea		r10,TAB8_1
FFFFFFFFFFFFD9CC	33FFF486		 	jmp		EXEC		; go do it
FFFFFFFFFFFFD9D0	           		 XP11:
FFFFFFFFFFFFD9D0	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFD9D4	31FFF695		 	call	XP18	; is it ">="?
FFFFFFFFFFFFD9D8	BE208321		 	bge		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFD9DC	BE0002AA		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFD9E0	           		 XP12:
FFFFFFFFFFFFD9E0	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFD9E4	31FFF695		 	call	XP18	; is it "<>"?
FFFFFFFFFFFFD9E8	BE2082A9		 	bne		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFD9EC	BE00022A		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFD9F0	           		 XP13:
FFFFFFFFFFFFD9F0	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFD9F4	31FFF695		 	call	XP18	; is it ">"?
FFFFFFFFFFFFD9F8	BE208223		 	bgt		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFD9FC	BE0001AA		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFDA00	           		 XP14:
FFFFFFFFFFFFDA00	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFDA04	31FFF695		 	call	XP18	; is it "<="?
FFFFFFFFFFFFDA08	BE2081A2		 	ble		r2,r1,XPRT1	; no, return r2=1
FFFFFFFFFFFFDA0C	BE00012A		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFDA10	           		 XP15:
FFFFFFFFFFFFDA10	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFDA14	31FFF695		 	call	XP18	; is it "="?
FFFFFFFFFFFFDA18	BE208128		 	beq		r2,r1,XPRT1	; if not, return r2=1
FFFFFFFFFFFFDA1C	BE0000AA		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFDA20	           		 XP16:
FFFFFFFFFFFFDA20	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFDA24	31FFF695		 	call	XP18	; is it "<"?
FFFFFFFFFFFFDA28	BE2080A0		 	blt		r2,r1,XPRT1	; if not, return r2=1
FFFFFFFFFFFFDA2C	BE00002A		 	bra		XPRT0	; else return r2=0
FFFFFFFFFFFFDA30	           		 XPRT0:
FFFFFFFFFFFFDA30	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDA34	E0400000		 	setlo	r1,#0   ; return r1=0 (false)
FFFFFFFFFFFFDA38	37EF8010		 	ret		#16
FFFFFFFFFFFFDA3C	           		 XPRT1:
FFFFFFFFFFFFDA3C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDA40	E0400001		 	setlo	r1,#1	; return r1=1 (true)
FFFFFFFFFFFFDA44	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFDA48	           		 XP17:				; it's not a rel. operator
FFFFFFFFFFFFDA48	47E08008		 	lw		r1,8[sp]	; return r2=<EXPR2>
FFFFFFFFFFFFDA4C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDA50	37EF8010		 	ret		#16
                  	           		 
FFFFFFFFFFFFDA54	           		 XP18:
FFFFFFFFFFFFDA54	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFDA58	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDA5C	67E08008		 	sw		r1,8[sp]
FFFFFFFFFFFFDA60	31FFF69C		 	call	EXPR2		; do a second <EXPR2>
FFFFFFFFFFFFDA64	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFDA68	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDA6C	37EF8010		 	ret		#16
                  	           		 
                  	           		 ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                  	           		 
FFFFFFFFFFFFDA70	           		 EXPR2:
FFFFFFFFFFFFDA70	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFDA74	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDA78	E0C0002D		 	setlo	r3,#'-'
FFFFFFFFFFFFDA7C	9A025A90		 	lea		r4,XP21
FFFFFFFFFFFFDA80	31FFF8F1		 	call	TSTC		; negative sign?
FFFFFFFFFFFFDA84	E0400000		 	setlo	r1,#0		; yes, fake '0-'
FFFFFFFFFFFFDA88	67E00008		 	sw		r0,8[sp]
FFFFFFFFFFFFDA8C	BE00020A		 	bra		XP26
FFFFFFFFFFFFDA90	           		 XP21:
FFFFFFFFFFFFDA90	E0C0002B		 	setlo	r3,#'+'
FFFFFFFFFFFFDA94	9A025A9C		 	lea		r4,XP22
FFFFFFFFFFFFDA98	31FFF8F1		 	call	TSTC		; positive sign? ignore it
FFFFFFFFFFFFDA9C	           		 XP22:
FFFFFFFFFFFFDA9C	31FFF6B9		 	call	EXPR3		; first <EXPR3>
FFFFFFFFFFFFDAA0	           		 XP23:
FFFFFFFFFFFFDAA0	67E08008		 	sw		r1,8[sp]	; yes, save the value
FFFFFFFFFFFFDAA4	E0C0002B		 	setlo	r3,#'+'
FFFFFFFFFFFFDAA8	9A025AC0		 	lea		r4,XP25
FFFFFFFFFFFFDAAC	31FFF8F1		 	call	TSTC		; add?
FFFFFFFFFFFFDAB0	31FFF6B9		 	call	EXPR3		; get the second <EXPR3>
FFFFFFFFFFFFDAB4	           		 XP24:
FFFFFFFFFFFFDAB4	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFDAB8	04110402		 	add		r1,r1,r2	; add it to the first <EXPR3>
                  	           		 ;	BVS.L	QHOW		brnch if there's an overflow
FFFFFFFFFFFFDABC	BE007F2A		 	bra		XP23		; else go back for more operations
FFFFFFFFFFFFDAC0	           		 XP25:
FFFFFFFFFFFFDAC0	E0C0002D		 	setlo	r3,#'-'
FFFFFFFFFFFFDAC4	9A025AD8		 	lea		r4,XP45
FFFFFFFFFFFFDAC8	31FFF8F1		 	call	TSTC		; subtract?
FFFFFFFFFFFFDACC	           		 XP26:
FFFFFFFFFFFFDACC	31FFF6B9		 	call	EXPR3		; get second <EXPR3>
FFFFFFFFFFFFDAD0	02108006		 	neg		r1,r1		; change its sign
FFFFFFFFFFFFDAD4	BE007F0A		 	bra		XP24		; and do an addition
FFFFFFFFFFFFDAD8	           		 XP45:
FFFFFFFFFFFFDAD8	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFDADC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDAE0	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                  	           		 
FFFFFFFFFFFFDAE4	           		 EXPR3:
FFFFFFFFFFFFDAE4	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFDAE8	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDAEC	31FFF6CF		 	call	EXPR4		; get first <EXPR4>
FFFFFFFFFFFFDAF0	           		 XP31:
FFFFFFFFFFFFDAF0	67E08008		 	sw		r1,8[sp]	; yes, save that first result
FFFFFFFFFFFFDAF4	E0C0002A		 	setlo	r3,#'*'
FFFFFFFFFFFFDAF8	9A025B10		 	lea		r4,XP34
FFFFFFFFFFFFDAFC	31FFF8F1		 	call	TSTC		; multiply?
FFFFFFFFFFFFDB00	31FFF6CF		 	call	EXPR4		; get second <EXPR4>
FFFFFFFFFFFFDB04	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFDB08	04110419		 	muls	r1,r1,r2	; multiply the two
FFFFFFFFFFFFDB0C	BE007F2A		 	bra		XP31        ; then look for more terms
FFFFFFFFFFFFDB10	           		 XP34:
FFFFFFFFFFFFDB10	E0C0002F		 	setlo	r3,#'/'
FFFFFFFFFFFFDB14	9A025B30		 	lea		r4,XP47
FFFFFFFFFFFFDB18	31FFF8F1		 	call	TSTC		; divide?
FFFFFFFFFFFFDB1C	31FFF6CF		 	call	EXPR4		; get second <EXPR4>
FFFFFFFFFFFFDB20	04100809		 	or      r2,r1,r0
FFFFFFFFFFFFDB24	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFDB28	0411041B		 	divs	r1,r1,r2	; do the division
FFFFFFFFFFFFDB2C	BE007E2A		 	bra		XP31		; go back for any more terms
FFFFFFFFFFFFDB30	           		 XP47:
FFFFFFFFFFFFDB30	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFDB34	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDB38	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; Functions are called through EXPR4
                  	           		 ; <EXPR4>::=<variable>
                  	           		 ;	    <function>
                  	           		 ;	    (<EXPR>)
                  	           		 
FFFFFFFFFFFFDB3C	           		 EXPR4:
FFFFFFFFFFFFDB3C	0FEF0018		     subui   sp,sp,#24
FFFFFFFFFFFFDB40	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFDB44	9A04D042		     lea		r9,TAB4		; find possible function
FFFFFFFFFFFFDB48	9A055150		     lea		r10,TAB4_1
FFFFFFFFFFFFDB4C	33FFF486		 	jmp		EXEC        ; branch to function which does subsequent ret for EXPR4
FFFFFFFFFFFFDB50	           		 XP40:                   ; we get here if it wasn't a function
FFFFFFFFFFFFDB50	E0400000		 	setlo	r1,#0
FFFFFFFFFFFFDB54	31FFF6EC		 	call	TSTV		
FFFFFFFFFFFFDB58	BE100088		 	beq     r1,r0,XP41  ; nor a variable
FFFFFFFFFFFFDB5C	46108000		 	lw		r1,[r1]		; if a variable, return its value in r1
FFFFFFFFFFFFDB60	47EF8000		 	lw      lr,[sp]
FFFFFFFFFFFFDB64	37EF8018		 	ret		#24
FFFFFFFFFFFFDB68	           		 XP41:
FFFFFFFFFFFFDB68	31FFF8FF		 	call	TSTNUM		; or is it a number?
FFFFFFFFFFFFDB6C	BE200049		 	bne		r2,r0,XP46	; (if not, # of digits will be zero) if so, return it in r1
FFFFFFFFFFFFDB70	31FFF6DF		 	call    PARN        ; check for (EXPR)
FFFFFFFFFFFFDB74	           		 XP46:
FFFFFFFFFFFFDB74	47EF8000		 	lw      lr,[sp]
FFFFFFFFFFFFDB78	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; Check for a parenthesized expression
FFFFFFFFFFFFDB7C	           		 PARN:
FFFFFFFFFFFFDB7C	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFDB80	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDB84	E0C00028		 	setlo	r3,#'('
FFFFFFFFFFFFDB88	9A025BA8		 	lea		r4,XP43
FFFFFFFFFFFFDB8C	31FFF8F1		 	call	TSTC		; else look for ( OREXPR )
FFFFFFFFFFFFDB90	31FFF63A		 	call	OREXPR
FFFFFFFFFFFFDB94	E0C00029		 	setlo	r3,#')'
FFFFFFFFFFFFDB98	9A025BA8		 	lea		r4,XP43
FFFFFFFFFFFFDB9C	31FFF8F1		 	call	TSTC
FFFFFFFFFFFFDBA0	           		 XP42:
FFFFFFFFFFFFDBA0	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDBA4	37EF8008		 	ret		#8
FFFFFFFFFFFFDBA8	           		 XP43:
FFFFFFFFFFFFDBA8	9A00E5FD		 	lea		r1,msgWhat
FFFFFFFFFFFFDBAC	BE001BAA		 	bra		ERROR
                  	           		 
                  	           		 
                  	           		 ; ===== Test for a valid variable name.  Returns Z=1 if not
                  	           		 ;	found, else returns Z=0 and the address of the
                  	           		 ;	variable in r1.
                  	           		 ; Parameters
                  	           		 ;	r1 = 1 = allocate if not found
                  	           		 ; Returns
                  	           		 ;	r1 = address of variable, zero if not found
                  	           		 
FFFFFFFFFFFFDBB0	           		 TSTV:
FFFFFFFFFFFFDBB0	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFDBB4	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDBB8	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFDBBC	04101409		 	or		r5,r1,r0	; allocate flag
FFFFFFFFFFFFDBC0	31FFF914		 	call	IGNBLK
FFFFFFFFFFFFDBC4	4A808000		 	lbu		r1,[r8]		; look at the program text
FFFFFFFFFFFFDBC8	A0101740		 	blt     r1,#'@',tstv_notfound   ; C=1: not a variable
FFFFFFFFFFFFDBCC	B2100F40		 	bne		r1,#'@',TV1	; brnch if not "@" array
FFFFFFFFFFFFDBD0	0A840001		 	addui	r8,r8,#1	; If it is, it should be
FFFFFFFFFFFFDBD4	31FFF6DF		 	call	PARN		; followed by (EXPR) as its index.
FFFFFFFFFFFFDBD8	06108600		 	shli	r1,r1,#3
                  	           		 ;	BCS.L	QHOW		say "How?" if index is too big
FFFFFFFFFFFFDBDC	0FEF0018		 	subui	sp,sp,#24
FFFFFFFFFFFFDBE0	67E08008		     sw      r1,8[sp]    ; save the index
FFFFFFFFFFFFDBE4	67EF8000		     sw		lr,[sp]
FFFFFFFFFFFFDBE8	31FFF793		 	call	SIZEX		; get amount of free memory
FFFFFFFFFFFFDBEC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDBF0	47E10008		 	lw      r2,8[sp]    ; get back the index
FFFFFFFFFFFFDBF4	BE208044		 	bltu	r2,r1,TV2	; see if there's enough memory
FFFFFFFFFFFFDBF8	33FFF7C5		 	jmp    	QSORRY		; if not, say "Sorry"
FFFFFFFFFFFFDBFC	           		 TV2:
FFFFFFFFFFFFDBFC	9A0090D8		 	lea		r1,VARBGN   ; put address of array element...
FFFFFFFFFFFFDC00	04110405		 	subu    r1,r1,r2       ; into r1 (neg. offset is used)
FFFFFFFFFFFFDC04	BE0000AA		 	bra     TSTVRT
FFFFFFFFFFFFDC08	           		 TV1:	
FFFFFFFFFFFFDC08	31FFF70D		     call    getVarName      ; get variable name
FFFFFFFFFFFFDC0C	BE100068		     beq     r1,r0,TSTVRT    ; if not, return r1=0
FFFFFFFFFFFFDC10	02510009		     mov		r2,r5
FFFFFFFFFFFFDC14	31FFF733		     call    findVar     ; find or allocate
FFFFFFFFFFFFDC18	           		 TSTVRT:
FFFFFFFFFFFFDC18	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFDC1C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDC20	37EF8018		 	ret		#24			; r1<>0 (found)
FFFFFFFFFFFFDC24	           		 tstv_notfound:
FFFFFFFFFFFFDC24	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFDC28	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFDC2C	E0400000		     setlo   r1,#0       ; r1=0 if not found
FFFFFFFFFFFFDC30	37EF8018		     ret		#24
                  	           		 
                  	           		 
                  	           		 ; Returns
                  	           		 ;   r1 = 6 character variable name + type
                  	           		 ;
FFFFFFFFFFFFDC34	           		 getVarName:
FFFFFFFFFFFFDC34	0FEF0018		     subui   sp,sp,#24
FFFFFFFFFFFFDC38	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFDC3C	67E28010		     sw		r5,16[sp]
                  	           		 
FFFFFFFFFFFFDC40	40808000		     lb      r1,[r8]     ; get first character
FFFFFFFFFFFFDC44	67E08008		     sw		r1,8[sp]	; save off current name
FFFFFFFFFFFFDC48	31FFF65C		     call    isAlpha
FFFFFFFFFFFFDC4C	BE100388		     beq     r1,r0,gvn1
FFFFFFFFFFFFDC50	E1400005		     setlo   r5,#5       ; loop six more times
                  	           		 
                  	           		 	; check for second/third character
FFFFFFFFFFFFDC54	           		 gvn4:
FFFFFFFFFFFFDC54	0A840001		 	addui   r8,r8,#1
FFFFFFFFFFFFDC58	40808000		 	lb      r1,[r8]     ; do we have another char ?
FFFFFFFFFFFFDC5C	31FFF664		 	call    isAlnum
FFFFFFFFFFFFDC60	BE100168		 	beq     r1,r0,gvn2  ; nope
FFFFFFFFFFFFDC64	47E08008		 	lw      r1,8[sp]    ; get varname
FFFFFFFFFFFFDC68	06109000		 	shli	r1,r1,#8
FFFFFFFFFFFFDC6C	40810000		 	lb      r2,[r8]
FFFFFFFFFFFFDC70	04110409		 	or      r1,r1,r2   ; add in new char
FFFFFFFFFFFFDC74	67E08008		     sw      r1,8[sp]   ; save off name again
FFFFFFFFFFFFDC78	BE02FEEF		     loop	r5,gvn4
                  	           		 
                  	           		     ; now ignore extra variable name characters
FFFFFFFFFFFFDC7C	           		 gvn6:
FFFFFFFFFFFFDC7C	0A840001		     addui   r8,r8,#1
FFFFFFFFFFFFDC80	40808000		     lb      r1,[r8]
FFFFFFFFFFFFDC84	31FFF664		     call    isAlnum
FFFFFFFFFFFFDC88	BE107FA9		     bne     r1,r0,gvn6	; keep looping as long as we have identifier chars
                  	           		 
                  	           		     ; check for a variable type
FFFFFFFFFFFFDC8C	           		 gvn2:
FFFFFFFFFFFFDC8C	40808000		 	lb		r1,[r8]
FFFFFFFFFFFFDC90	B0100425		     beq     r1,#'%',gvn3
FFFFFFFFFFFFDC94	B0100324		     beq     r1,#'$',gvn3
FFFFFFFFFFFFDC98	E0400000		     setlo   r1,#0
FFFFFFFFFFFFDC9C	0E840001		     subui   r8,r8,#1
                  	           		 
                  	           		     ; insert variable type indicator and return
FFFFFFFFFFFFDCA0	           		 gvn3:
FFFFFFFFFFFFDCA0	0A840001		     addui   r8,r8,#1
FFFFFFFFFFFFDCA4	47E10008		     lw      r2,8[sp]
FFFFFFFFFFFFDCA8	06211000		     shli	r2,r2,#8
FFFFFFFFFFFFDCAC	04110409		     or      r1,r1,r2    ; add in variable type
FFFFFFFFFFFFDCB0	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFDCB4	47E28010		     lw		r5,16[sp]
FFFFFFFFFFFFDCB8	37EF8018		     ret		#24			; return Z = 0, r1 = varname
                  	           		 
                  	           		     ; not a variable name
FFFFFFFFFFFFDCBC	           		 gvn1:
FFFFFFFFFFFFDCBC	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFDCC0	47E28010		     lw		r5,16[sp]
FFFFFFFFFFFFDCC4	E0400000		     setlo   r1,#0       ; return Z = 1 if not a varname
FFFFFFFFFFFFDCC8	37EF8018		     ret		#24
                  	           		 
                  	           		 
                  	           		 ; Find variable
                  	           		 ;   r1 = varname
                  	           		 ;	r2 = allocate flag
                  	           		 ; Returns
                  	           		 ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                  	           		 
FFFFFFFFFFFFDCCC	           		 findVar:
FFFFFFFFFFFFDCCC	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFDCD0	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFDCD4	67E38008		     sw      r7,8[sp]
FFFFFFFFFFFFDCD8	460190D8		     lw      r3,VARBGN
FFFFFFFFFFFFDCDC	           		 fv4:
FFFFFFFFFFFFDCDC	46338000		     lw      r7,[r3]     ; get varname / type
FFFFFFFFFFFFDCE0	BE700108		     beq     r7,r0,fv3   ; no more vars ?
FFFFFFFFFFFFDCE4	BE138128		     beq     r1,r7,fv1	; match ?
FFFFFFFFFFFFDCE8	08318008		     add     r3,r3,#8    ; move to next var
FFFFFFFFFFFFDCEC	460390F8		     lw      r7,STKBOT
FFFFFFFFFFFFDCF0	BE33FF60		     blt     r3,r7,fv4   ; loop back to look at next var
                  	           		 
                  	           		     ; variable not found
                  	           		     ; no more memory
FFFFFFFFFFFFDCF4	E07FE650		     setlo	r1,#<msgVarSpace
FFFFFFFFFFFFDCF8	F04FFFFF		     sethi	r1,#>msgVarSpace
FFFFFFFFFFFFDCFC	BE00112A		     bra     ERROR
                  	           		 ;    lw      lr,[sp]
                  	           		 ;    lw      r7,4[sp]
                  	           		 ;    add     sp,sp,#8
                  	           		 ;    lw      r1,#0
                  	           		 ;    ret
                  	           		 
                  	           		     ; variable not found
                  	           		     ; allocate new ?
FFFFFFFFFFFFDD00	           		 fv3:
FFFFFFFFFFFFDD00	BE2000C8		 	beq		r2,r0,fv2
FFFFFFFFFFFFDD04	66308000		     sw      r1,[r3]     ; save varname / type
                  	           		     ; found variable
                  	           		     ; return address
FFFFFFFFFFFFDD08	           		 fv1:
FFFFFFFFFFFFDD08	0A308008		     addui   r1,r3,#8
FFFFFFFFFFFFDD0C	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFDD10	47E38008		     lw      r7,8[sp]
FFFFFFFFFFFFDD14	37EF8010		     ret		#16    ; Z = 0, r1 = address
                  	           		 
                  	           		     ; didn't find var and not allocating
FFFFFFFFFFFFDD18	           		 fv2:
FFFFFFFFFFFFDD18	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFDD1C	47E38008		     lw      r7,8[sp]
FFFFFFFFFFFFDD20	0BEF0010		     addui   sp,sp,#16   ; Z = 0, r1 = address
FFFFFFFFFFFFDD24	E0400000		 	setlo	r1,#0		; Z = 1, r1 = 0
FFFFFFFFFFFFDD28	37EF8000		     ret
                  	           		 
                  	           		 
                  	           		 ; ===== Multiplies the 32 bit values in r1 and r2, returning
                  	           		 ;	the 32 bit result in r1.
                  	           		 ;
                  	           		 
                  	           		 ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                  	           		 ;	Returns the 32 bit quotient in r1, remainder in r2
                  	           		 ;
                  	           		 ; r2 = a
                  	           		 ; r3 = b
                  	           		 ; r6 = remainder
                  	           		 ; r7 = iteration count
                  	           		 ; r8 = sign
                  	           		 ;
                  	           		 
                  	           		 ; q = a / b
                  	           		 ; a = r1
                  	           		 ; b = r2
                  	           		 ; q = r2
                  	           		 
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFDD2C	           		 PEEK:
FFFFFFFFFFFFDD2C	31FFF6DF		 	call	PARN		; get the memory address
FFFFFFFFFFFFDD30	4A108000		 	lbu		r1,[r1]		; get the addressed byte
FFFFFFFFFFFFDD34	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFDD38	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFDD3C	           		 PEEKC:
FFFFFFFFFFFFDD3C	31FFF6DF		 	call	PARN		; get the memory address
FFFFFFFFFFFFDD40	1410FFFE		 	andi	r1,r1,#-2	; align to char address
FFFFFFFFFFFFDD44	4C108000		 	lcu		r1,[r1]		; get the addressed char
FFFFFFFFFFFFDD48	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFDD4C	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFDD50	           		 PEEKH:
FFFFFFFFFFFFDD50	31FFF6DF		 	call	PARN		; get the memory address
FFFFFFFFFFFFDD54	1410FFFC		 	andi	r1,r1,#-4	; align to half-word address
FFFFFFFFFFFFDD58	4E108000		 	lhu		r1,[r1]		; get the addressed char
FFFFFFFFFFFFDD5C	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFDD60	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The PEEK function returns the byte stored at the address
                  	           		 ;	contained in the following expression.
                  	           		 ;
FFFFFFFFFFFFDD64	           		 PEEKW:
FFFFFFFFFFFFDD64	31FFF6DF		 	call	PARN		; get the memory address
FFFFFFFFFFFFDD68	1410FFF8		 	andi	r1,r1,#-8		; align to word address
FFFFFFFFFFFFDD6C	46108000		 	lw		r1,[r1]		; get the addressed word
FFFFFFFFFFFFDD70	47EF8000		 	lw		lr,[sp]		; and return it
FFFFFFFFFFFFDD74	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; user function call
                  	           		 ; call the user function with argument in r1
FFFFFFFFFFFFDD78	           		 USRX:
FFFFFFFFFFFFDD78	31FFF6DF		 	call	PARN		; get expression value
FFFFFFFFFFFFDD7C	67E40008		 	sw		r8,8[sp]	; save the text pointer
FFFFFFFFFFFFDD80	46011028		 	lw      r2,usrJmp   ; get usr vector
FFFFFFFFFFFFDD84	342F8000		 	jal		r31,[r2]	; jump to the subroutine
FFFFFFFFFFFFDD88	47E40008		 	lw		r8,8[sp]	; restore the text pointer
FFFFFFFFFFFFDD8C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDD90	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; ===== The RND function returns a random number from 1 to
                  	           		 ;	the value of the following expression in D0.
                  	           		 ;
FFFFFFFFFFFFDD94	           		 RND:
FFFFFFFFFFFFDD94	31FFF6DF		 	call	PARN		; get the upper limit
FFFFFFFFFFFFDD98	BE100168		 	beq		r1,r0,rnd2	; it must be positive and non-zero
FFFFFFFFFFFFDD9C	BE100100		 	blt		r1,r0,rnd1
FFFFFFFFFFFFDDA0	04100809		 	lw		r2,r1
FFFFFFFFFFFFDDA4	00000050		 	gran				; generate a random number
FFFFFFFFFFFFDDA8	020088A8		 	mfspr	r1,rand		; get the number
FFFFFFFFFFFFDDAC	31FFF775		 	call	modu4		; RND(n)=MOD(number,n)+1
FFFFFFFFFFFFDDB0	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFDDB4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDDB8	37EF8018		 	ret		#24
FFFFFFFFFFFFDDBC	           		 rnd1:
FFFFFFFFFFFFDDBC	9A00E6C1		 	lea		r1,msgRNDBad
FFFFFFFFFFFFDDC0	BE000B0A		 	bra		ERROR
FFFFFFFFFFFFDDC4	           		 rnd2:
FFFFFFFFFFFFDDC4	00000050		 	gran
FFFFFFFFFFFFDDC8	020088A8		 	mfspr	r1,rand
FFFFFFFFFFFFDDCC	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDDD0	37EF8018		 	ret		#24
                  	           		 
                  	           		 
                  	           		 ; r = a mod b
                  	           		 ; a = r1
                  	           		 ; b = r2 
                  	           		 ; r = r6
FFFFFFFFFFFFDDD4	           		 modu4:
FFFFFFFFFFFFDDD4	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFDDD8	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFDDDC	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFDDE0	67E30010		 	sw		r6,16[sp]
FFFFFFFFFFFFDDE4	67E38018		 	sw		r7,24[sp]
FFFFFFFFFFFFDDE8	1603803F		 	lw      r7,#63		; n = 64
FFFFFFFFFFFFDDEC	0452940A		 	xor		r5,r5,r5	; w = 0
FFFFFFFFFFFFDDF0	0463180A		 	xor		r6,r6,r6	; r = 0
FFFFFFFFFFFFDDF4	           		 mod2:
FFFFFFFFFFFFDDF4	06108202		 	roli	r1,r1,#1	; a <<= 1
FFFFFFFFFFFFDDF8	14118001		 	andi	r3,r1,#1
FFFFFFFFFFFFDDFC	06630200		 	shli	r6,r6,#1	; r <<= 1
FFFFFFFFFFFFDE00	04619809		 	or		r6,r6,r3
FFFFFFFFFFFFDE04	1410FFFE		 	andi	r1,r1,#-2
FFFFFFFFFFFFDE08	BE230047		 	bgtu	r2,r6,mod1	; b < r ?
FFFFFFFFFFFFDE0C	04611805		 	subu	r6,r6,r2	; r -= b
FFFFFFFFFFFFDE10	           		 mod1:
FFFFFFFFFFFFDE10	BE03FF2F		     loop	r7,mod2		; n--
FFFFFFFFFFFFDE14	02608009		 	mov		r1,r6
FFFFFFFFFFFFDE18	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFDE1C	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFDE20	47E30010		 	lw		r6,16[sp]
FFFFFFFFFFFFDE24	47E38018		 	lw		r7,24[sp]
FFFFFFFFFFFFDE28	37EF8020		 	ret		#32
                  	           		 
                  	           		 
                  	           		 ; ===== The ABS function returns an absolute value in r2.
                  	           		 ;
FFFFFFFFFFFFDE2C	           		 ABS:
FFFFFFFFFFFFDE2C	31FFF6DF		 	call	PARN		; get the following expr.'s value
FFFFFFFFFFFFDE30	02108007		 	abs		r1,r1
FFFFFFFFFFFFDE34	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDE38	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The SGN function returns the sign in r1. +1,0, or -1
                  	           		 ;
FFFFFFFFFFFFDE3C	           		 SGN:
FFFFFFFFFFFFDE3C	31FFF6DF		 	call	PARN		; get the following expr.'s value
FFFFFFFFFFFFDE40	02108008		 	sgn		r1,r1
FFFFFFFFFFFFDE44	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDE48	37EF8018		 	ret		#24
                  	           		 
                  	           		 ; ===== The SIZE function returns the size of free memory in r1.
                  	           		 ;
FFFFFFFFFFFFDE4C	           		 SIZEX:
FFFFFFFFFFFFDE4C	460090D8		 	lw		r1,VARBGN	; get the number of free bytes...
FFFFFFFFFFFFDE50	460110D0		 	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFFFFFFFFFFDE54	04110405		 	subu	r1,r1,r2
FFFFFFFFFFFFDE58	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDE5C	37EF8018		 	ret		#24			; return the number in r2
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                  	           		 ;
                  	           		 ; 'SETVAL' expects a variable, followed by an equal sign and then
                  	           		 ; an expression.  It evaluates the expression and sets the variable
                  	           		 ; to that value.
                  	           		 ;
                  	           		 ; 'FIN' checks the end of a command.  If it ended with ":",
                  	           		 ; execution continues.	If it ended with a CR, it finds the
                  	           		 ; the next line and continues from there.
                  	           		 ;
                  	           		 ; 'ENDCHK' checks if a command is ended with a CR. This is
                  	           		 ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                  	           		 ;
                  	           		 ; 'ERROR' prints the string pointed to by r1. It then prints the
                  	           		 ; line pointed to by CURRNT with a "?" inserted at where the
                  	           		 ; old text pointer (should be on top of the stack) points to.
                  	           		 ; Execution of Tiny BASIC is stopped and a warm start is done.
                  	           		 ; If CURRNT is zero (indicating a direct command), the direct
                  	           		 ; command is not printed. If CURRNT is -1 (indicating
                  	           		 ; 'INPUT' command in progress), the input line is not printed
                  	           		 ; and execution is not terminated but continues at 'INPERR'.
                  	           		 ;
                  	           		 ; Related to 'ERROR' are the following:
                  	           		 ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                  	           		 ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                  	           		 ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                  	           		 ; 'QHOW' and 'AHOW' also do this for "How?".
                  	           		 ;
                  	           		 
                  	           		 ; returns
                  	           		 ; r2 = variable's address
                  	           		 ;
FFFFFFFFFFFFDE60	           		 SETVAL:
FFFFFFFFFFFFDE60	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFDE64	67EF8000		     sw      lr,[sp]
FFFFFFFFFFFFDE68	E0400001		     setlo	r1,#1		; allocate var
FFFFFFFFFFFFDE6C	31FFF6EC		     call	TSTV		; variable name?
FFFFFFFFFFFFDE70	BE100069		     bne		r1,r0,sv2
FFFFFFFFFFFFDE74	9A00E6AA		    	lea		r1,msgVar
FFFFFFFFFFFFDE78	BE00054A		    	bra		ERROR 
FFFFFFFFFFFFDE7C	           		 sv2:
FFFFFFFFFFFFDE7C	67E08008		 	sw      r1,8[sp]    ; save the variable's address
FFFFFFFFFFFFDE80	E0C0003D		 	setlo	r3,#'='
FFFFFFFFFFFFDE84	9A025EA4		 	lea		r4,SV1
FFFFFFFFFFFFDE88	31FFF8F1		 	call	TSTC		; get past the "=" sign
FFFFFFFFFFFFDE8C	31FFF63A		 	call	OREXPR		; evaluate the expression
FFFFFFFFFFFFDE90	47E10008		 	lw      r2,8[sp]    ; get back the variable's address
FFFFFFFFFFFFDE94	66208000		 	sw      r1,[r2]     ; and save value in the variable
FFFFFFFFFFFFDE98	04200409		 	lw		r1,r2		; return r1 = variable address
FFFFFFFFFFFFDE9C	47EF8000		 	lw      lr,[sp]
FFFFFFFFFFFFDEA0	37EF8010		 	ret		#16
FFFFFFFFFFFFDEA4	           		 SV1:
FFFFFFFFFFFFDEA4	BE0003CA		     bra	    QWHAT		; if no "=" sign
                  	           		 
                  	           		 
FFFFFFFFFFFFDEA8	           		 FIN:
FFFFFFFFFFFFDEA8	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFDEAC	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDEB0	E0C0003A		 	setlo	r3,#':'
FFFFFFFFFFFFDEB4	9A025EC4		 	lea		r4,FI1
FFFFFFFFFFFFDEB8	31FFF8F1		 	call	TSTC		; *** FIN ***
FFFFFFFFFFFFDEBC	0BEF0008		 	addui	sp,sp,#8	; if ":", discard return address
FFFFFFFFFFFFDEC0	BE0020AA		 	bra		RUNSML		; continue on the same line
FFFFFFFFFFFFDEC4	           		 FI1:
FFFFFFFFFFFFDEC4	E0C0000D		 	setlo	r3,#CR
FFFFFFFFFFFFDEC8	9A025EDC		 	lea		r4,FI2
FFFFFFFFFFFFDECC	31FFF8F1		 	call	TSTC		; not ":", is it a CR?
FFFFFFFFFFFFDED0	47EF8000		 	lw		lr,[sp]	; else return to the caller
FFFFFFFFFFFFDED4	0BEF0008		 	addui	sp,sp,#8	; yes, purge return address
FFFFFFFFFFFFDED8	BE001EAA		 	bra		RUNNXL		; execute the next line
FFFFFFFFFFFFDEDC	           		 FI2:
FFFFFFFFFFFFDEDC	47EF8000		 	lw		lr,[sp]	; else return to the caller
FFFFFFFFFFFFDEE0	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; Check that there is nothing else on the line
                  	           		 ; Registers Affected
                  	           		 ;   r1
                  	           		 ;
FFFFFFFFFFFFDEE4	           		 ENDCHK:
FFFFFFFFFFFFDEE4	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFDEE8	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDEEC	31FFF914		 	call	IGNBLK
FFFFFFFFFFFFDEF0	40808000		 	lb		r1,[r8]
FFFFFFFFFFFFDEF4	B010040D		 	beq		r1,#CR,ec1	; does it end with a CR?
FFFFFFFFFFFFDEF8	E07FE784		 	setlo	r1,#<msgExtraChars
FFFFFFFFFFFFDEFC	F04FFFFF		 	sethi	r1,#>msgExtraChars
FFFFFFFFFFFFDF00	33FFF7C8		 	jmp		ERROR
FFFFFFFFFFFFDF04	           		 ec1:
FFFFFFFFFFFFDF04	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFDF08	37EF8008		 	ret		#8
                  	           		 
                  	           		 
FFFFFFFFFFFFDF0C	           		 TOOBIG:
FFFFFFFFFFFFDF0C	9A00E76F		 	lea		r1,msgTooBig
FFFFFFFFFFFFDF10	BE00008A		 	bra		ERROR
FFFFFFFFFFFFDF14	           		 QSORRY:
FFFFFFFFFFFFDF14	9A00E605		     lea		r1,SRYMSG
FFFFFFFFFFFFDF18	BE00004A		 	bra	    ERROR
FFFFFFFFFFFFDF1C	           		 QWHAT:
FFFFFFFFFFFFDF1C	9A00E5FD		 	lea		r1,msgWhat
FFFFFFFFFFFFDF20	           		 ERROR:
FFFFFFFFFFFFDF20	31FFF940		 	call	PRMESG		; display the error message
FFFFFFFFFFFFDF24	46009090		 	lw		r1,CURRNT	; get the current line number
FFFFFFFFFFFFDF28	BE107E88		 	beq		r1,r0,WSTART	; if zero, do a warm start
FFFFFFFFFFFFDF2C	B01D9AFF		 	beq		r1,#-1,INPERR		; is the line no. pointer = -1? if so, redo input
FFFFFFFFFFFFDF30	40828000		 	lb		r5,[r8]		; save the char. pointed to
FFFFFFFFFFFFDF34	60800000		 	sb		r0,[r8]		; put a zero where the error is
FFFFFFFFFFFFDF38	46009090		 	lw		r1,CURRNT	; point to start of current line
FFFFFFFFFFFFDF3C	31FFF8DF		 	call	PRTLN		; display the line in error up to the 0
FFFFFFFFFFFFDF40	04101809		 	or      r6,r1,r0    ; save off end pointer
FFFFFFFFFFFFDF44	60828000		 	sb		r5,[r8]		; restore the character
FFFFFFFFFFFFDF48	E040003F		 	setlo	r1,#'?'		; display a "?"
FFFFFFFFFFFFDF4C	31FFF393		 	call	GOOUT
FFFFFFFFFFFFDF50	E0800000		 	setlo   r2,#0       ; stop char = 0
FFFFFFFFFFFFDF54	0E608001		 	subui	r1,r6,#1	; point back to the error char.
FFFFFFFFFFFFDF58	31FFF851		 	call	PRTSTG		; display the rest of the line
FFFFFFFFFFFFDF5C	33FFF3BE		 	jmp	    WSTART		; and do a warm start
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** GETLN *** FNDLN (& friends) ***
                  	           		 ;
                  	           		 ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                  	           		 ; the character in r3 (given by the caller), then it fills the
                  	           		 ; buffer and echos. It ignores LF's but still echos
                  	           		 ; them back. Control-H is used to delete the last character
                  	           		 ; entered (if there is one), and control-X is used to delete the
                  	           		 ; whole line and start over again. CR signals the end of a line,
                  	           		 ; and causes 'GETLN' to return.
                  	           		 ;
                  	           		 ;
FFFFFFFFFFFFDF60	           		 GETLN:
FFFFFFFFFFFFDF60	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFDF64	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFDF68	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFDF6C	31FFF393		 	call	GOOUT		; display the prompt
FFFFFFFFFFFFDF70	E0400001		 	setlo	r1,#1		; turn on cursor flash
FFFFFFFFFFFFDF74	60009046		 	sb		r1,cursFlash
FFFFFFFFFFFFDF78	E0400020		 	setlo	r1,#' '		; and a space
FFFFFFFFFFFFDF7C	31FFF393		 	call	GOOUT
FFFFFFFFFFFFDF80	E200111B		 	setlo	r8,#<BUFFER	; r8 is the buffer pointer
FFFFFFFFFFFFDF84	F2000000		 	sethi	r8,#>BUFFER
FFFFFFFFFFFFDF88	           		 GL1:
FFFFFFFFFFFFDF88	31FFF936		 	call	CHKIO		; check keyboard
FFFFFFFFFFFFDF8C	BE107FE8		 	beq		r1,r0,GL1	; wait for a char. to come in
FFFFFFFFFFFFDF90	B0100B08		 	beq		r1,#CTRLH,GL3	; delete last character? if so
FFFFFFFFFFFFDF94	B0101418		 	beq		r1,#CTRLX,GL4	; delete the whole line?
FFFFFFFFFFFFDF98	B010020D		 	beq		r1,#CR,GL2	; accept a CR
FFFFFFFFFFFFDF9C	A81FFB20		 	bltu	r1,#' ',GL1	; if other control char., discard it
FFFFFFFFFFFFDFA0	           		 GL2:
FFFFFFFFFFFFDFA0	60808000		 	sb		r1,[r8]		; save the char.
FFFFFFFFFFFFDFA4	08840001		 	add		r8,r8,#1
FFFFFFFFFFFFDFA8	31FFF393		 	call	GOOUT		; echo the char back out
FFFFFFFFFFFFDFAC	4080FFFF		 	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
FFFFFFFFFFFFDFB0	B010190D		 	beq		r1,#CR,GL7	; if it's a CR, end the line
FFFFFFFFFFFFDFB4	1280916A		 	cmpui	r1,r8,#BUFFER+BUFLEN-1	; any more room?
FFFFFFFFFFFFDFB8	BE107E80		 	blt		r1,r0,GL1	; yes: get some more, else delete last char.
FFFFFFFFFFFFDFBC	           		 GL3:
FFFFFFFFFFFFDFBC	E0400008		 	setlo	r1,#CTRLH	; delete a char. if possible
FFFFFFFFFFFFDFC0	31FFF393		 	call	GOOUT
FFFFFFFFFFFFDFC4	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFDFC8	31FFF393		 	call	GOOUT
FFFFFFFFFFFFDFCC	1280911B		 	cmpui	r1,r8,#BUFFER	; any char.'s left?
FFFFFFFFFFFFDFD0	BE107DC2		 	ble		r1,r0,GL1		; if not
FFFFFFFFFFFFDFD4	E0400008		 	setlo	r1,#CTRLH	; if so, finish the BS-space-BS sequence
FFFFFFFFFFFFDFD8	31FFF393		 	call	GOOUT
FFFFFFFFFFFFDFDC	0C840001		 	sub		r8,r8,#1	; decrement the text pointer
FFFFFFFFFFFFDFE0	BE007D4A		 	bra		GL1			; back for more
FFFFFFFFFFFFDFE4	           		 GL4:
FFFFFFFFFFFFDFE4	04800409		 	or		r1,r8,r0		; delete the whole line
FFFFFFFFFFFFDFE8	0E12911B		 	subui	r5,r1,#BUFFER   ; figure out how many backspaces we need
FFFFFFFFFFFFDFEC	BE500108		 	beq		r5,r0,GL6		; if none needed, brnch
FFFFFFFFFFFFDFF0	           		 GL5:
FFFFFFFFFFFFDFF0	E0400008		 	setlo	r1,#CTRLH	; and display BS-space-BS sequences
FFFFFFFFFFFFDFF4	31FFF393		 	call	GOOUT
FFFFFFFFFFFFDFF8	E0400020		 	setlo	r1,#' '
FFFFFFFFFFFFDFFC	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE000	E0400008		 	setlo	r1,#CTRLH
FFFFFFFFFFFFE004	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE008	BE02FF4F		 	loop	r5,GL5
FFFFFFFFFFFFE00C	           		 GL6:
FFFFFFFFFFFFE00C	9A04111B		 	lea		r8,BUFFER	; reinitialize the text pointer
FFFFFFFFFFFFE010	BE007BCA		 	bra		GL1			; and go back for more
FFFFFFFFFFFFE014	           		 GL7:
FFFFFFFFFFFFE014	E0400000		 	setlo	r1,#0		; turn off cursor flash
FFFFFFFFFFFFE018	60009046		 	sb		r1,cursFlash
FFFFFFFFFFFFE01C	E040000A		 	setlo	r1,#LF		; echo a LF for the CR
FFFFFFFFFFFFE020	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE024	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE028	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFE02C	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; 'FNDLN' finds a line with a given line no. (in r1) in the
                  	           		 ; text save area.  r9 is used as the text pointer. If the line
                  	           		 ; is found, r9 will point to the beginning of that line
                  	           		 ; (i.e. the high byte of the line no.), and flags are Z.
                  	           		 ; If that line is not there and a line with a higher line no.
                  	           		 ; is found, r9 points there and flags are NC & NZ. If we reached
                  	           		 ; the end of the text save area and cannot find the line, flags
                  	           		 ; are C & NZ.
                  	           		 ; Z=1 if line found
                  	           		 ; N=1 if end of text save area
                  	           		 ; Z=0 & N=0 if higher line found
                  	           		 ; r0 = 1	<= line is found
                  	           		 ;	r9 = pointer to line
                  	           		 ; r0 = 0    <= line is not found
                  	           		 ;	r9 = zero, if end of text area
                  	           		 ;	r9 = otherwise higher line number
                  	           		 ;
                  	           		 ; 'FNDLN' will initialize r9 to the beginning of the text save
                  	           		 ; area to start the search. Some other entries of this routine
                  	           		 ; will not initialize r9 and do the search.
                  	           		 ; 'FNDLNP' will start with r9 and search for the line no.
                  	           		 ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                  	           		 ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                  	           		 ; return Z=1 if line is found, r9 = pointer to line
                  	           		 ;
                  	           		 ; Parameters
                  	           		 ;	r1 = line number to find
                  	           		 ;
FFFFFFFFFFFFE030	           		 FNDLN:
FFFFFFFFFFFFE030	AC1003FF		 	bleui	r1,#0xFFFF,fl1	; line no. must be < 65535
FFFFFFFFFFFFE034	9A00E694		 	lea		r1,msgLineRange
FFFFFFFFFFFFE038	BE00774A		 	bra		ERROR
FFFFFFFFFFFFE03C	           		 fl1:
FFFFFFFFFFFFE03C	4604CE60		 	lw		r9,TXTBGN	; init. the text save pointer
                  	           		 
FFFFFFFFFFFFE040	           		 FNDLNP:
FFFFFFFFFFFFE040	460510D0		 	lw		r10,TXTUNF	; check if we passed the end
FFFFFFFFFFFFE044	0EA50001		 	subui	r10,r10,#1
FFFFFFFFFFFFE048	BE950127		 	bgtu	r9,r10,FNDRET1		; if so, return with r9=0,r1=0
FFFFFFFFFFFFE04C	4A918000		 	lbu		r3,[r9]		; get low order byte of line number
FFFFFFFFFFFFE050	4A910001		 	lbu		r2,1[r9]	; get high order byte
FFFFFFFFFFFFE054	06211000		 	shli	r2,r2,#8
FFFFFFFFFFFFE058	04218809		 	or		r2,r2,r3	; build whole line number
FFFFFFFFFFFFE05C	BE110127		 	bgtu	r1,r2,FNDNXT	; is this the line we want? no, not there yet
FFFFFFFFFFFFE060	BE1100C8		 	beq		r1,r2,FNDRET2
FFFFFFFFFFFFE064	           		 FNDRET:
FFFFFFFFFFFFE064	0410840A		 	xor		r1,r1,r1	; line not found, but r9=next line pointer
FFFFFFFFFFFFE068	37EF8000		 	ret			; return the cond. codes
FFFFFFFFFFFFE06C	           		 FNDRET1:
FFFFFFFFFFFFE06C	0494A40A		 	xor		r9,r9,r9	; no higher line
FFFFFFFFFFFFE070	0410840A		 	xor		r1,r1,r1	; line not found
FFFFFFFFFFFFE074	37EF8000		 	ret
FFFFFFFFFFFFE078	           		 FNDRET2:
FFFFFFFFFFFFE078	E0400001		 	setlo	r1,#1		; line found
FFFFFFFFFFFFE07C	37EF8000		 	ret
                  	           		 
FFFFFFFFFFFFE080	           		 FNDNXT:
FFFFFFFFFFFFE080	0A948002		 	addui	r9,r9,#2	; find the next line
                  	           		 
FFFFFFFFFFFFE084	           		 FNDSKP:
FFFFFFFFFFFFE084	4A910000		 	lbu		r2,[r9]
FFFFFFFFFFFFE088	0A948001		 	addui	r9,r9,#1
FFFFFFFFFFFFE08C	B22FFE0D		 	bnei	r2,#CR,FNDSKP		; try to find a CR, keep looking
FFFFFFFFFFFFE090	BE007D8A		 	bra		FNDLNP		; check if end of text
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ; 'MVUP' moves a block up from where r1 points to where r2 points
                  	           		 ; until r1=r3
                  	           		 ;
FFFFFFFFFFFFE094	           		 MVUP1:
FFFFFFFFFFFFE094	40120000		 	lb		r4,[r1]
FFFFFFFFFFFFE098	60220000		 	sb		r4,[r2]
FFFFFFFFFFFFE09C	08108001		 	add		r1,r1,#1
FFFFFFFFFFFFE0A0	08210001		 	add		r2,r2,#1
FFFFFFFFFFFFE0A4	           		 MVUP:
FFFFFFFFFFFFE0A4	BE11FF89		 	bne		r1,r3,MVUP1
FFFFFFFFFFFFE0A8	           		 MVRET:
FFFFFFFFFFFFE0A8	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ; 'MVDOWN' moves a block down from where r1 points to where r2
                  	           		 ; points until r1=r3
                  	           		 ;
FFFFFFFFFFFFE0AC	           		 MVDOWN1:
FFFFFFFFFFFFE0AC	0C108001		 	sub		r1,r1,#1
FFFFFFFFFFFFE0B0	0C210001		 	sub		r2,r2,#1
FFFFFFFFFFFFE0B4	40120000		 	lb		r4,[r1]
FFFFFFFFFFFFE0B8	60220000		 	sb		r4,[r2]
FFFFFFFFFFFFE0BC	           		 MVDOWN:
FFFFFFFFFFFFE0BC	BE11FF89		 	bne		r1,r3,MVDOWN1
FFFFFFFFFFFFE0C0	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ; 'POPA' restores the 'FOR' loop variable save area from the stack
                  	           		 ;
                  	           		 ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                  	           		 ;
                  	           		 ; Note: a single zero word is stored on the stack in the
                  	           		 ; case that no FOR loops need to be saved. This needs to be
                  	           		 ; done because PUSHA / POPA is called all the time.
                  	           		 
FFFFFFFFFFFFE0C4	           		 POPA:
FFFFFFFFFFFFE0C4	47E08000		 	lw		r1,[sp]		; restore LOPVAR, but zero means no more
FFFFFFFFFFFFE0C8	660090A8		 	sw		r1,LOPVAR
FFFFFFFFFFFFE0CC	BE100148		 	beq		r1,r0,PP1
FFFFFFFFFFFFE0D0	47E08020		 	lw		r1,32[sp]	; if not zero, restore the rest
FFFFFFFFFFFFE0D4	660090C8		 	sw		r1,LOPPT
FFFFFFFFFFFFE0D8	47E08018		 	lw		r1,24[sp]
FFFFFFFFFFFFE0DC	660090C0		 	sw		r1,LOPLN
FFFFFFFFFFFFE0E0	47E08010		 	lw		r1,16[sp]
FFFFFFFFFFFFE0E4	660090B8		 	sw		r1,LOPLMT
FFFFFFFFFFFFE0E8	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFE0EC	660090B0		 	sw		r1,LOPINC
FFFFFFFFFFFFE0F0	37EF8028		 	ret		#40
FFFFFFFFFFFFE0F4	           		 PP1:
FFFFFFFFFFFFE0F4	37EF8008		 	ret		#8
                  	           		 
                  	           		 
FFFFFFFFFFFFE0F8	           		 PUSHA:
FFFFFFFFFFFFE0F8	460090F8		 	lw		r1,STKBOT	; Are we running out of stack room?
FFFFFFFFFFFFE0FC	0A108028		 	addui	r1,r1,#40	; we might need this many bytes
FFFFFFFFFFFFE100	BFE0F0A4		 	bltu	sp,r1,QSORRY	; out of stack space
FFFFFFFFFFFFE104	460090A8		 	lw		r1,LOPVAR	; save loop variables
FFFFFFFFFFFFE108	BE100188		 	beq		r1,r0,PU1	; if LOPVAR is zero, that's all
FFFFFFFFFFFFE10C	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFE110	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFE114	460090C8		 	lw		r1,LOPPT
FFFFFFFFFFFFE118	67E08020		 	sw		r1,32[sp]	; else save all the others
FFFFFFFFFFFFE11C	460090C0		 	lw		r1,LOPLN
FFFFFFFFFFFFE120	67E08018		 	sw		r1,24[sp]
FFFFFFFFFFFFE124	460090B8		 	lw		r1,LOPLMT
FFFFFFFFFFFFE128	67E08010		 	sw		r1,16[sp]
FFFFFFFFFFFFE12C	460090B0		 	lw		r1,LOPINC
FFFFFFFFFFFFE130	67E08008		 	sw		r1,8[sp]
FFFFFFFFFFFFE134	37EF8000		 	ret
FFFFFFFFFFFFE138	           		 PU1:
FFFFFFFFFFFFE138	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE13C	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFE140	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ;******************************************************************
                  	           		 ;
                  	           		 ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                  	           		 ;
                  	           		 ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                  	           		 ; and returns to the caller when either a CR is printed or when
                  	           		 ; the next byte is the same as what was passed in r4 by the
                  	           		 ; caller.
                  	           		 ;
                  	           		 ; 'QTSTG' looks for an underline (back-arrow on some systems),
                  	           		 ; single-quote, or double-quote.  If none of these are found, returns
                  	           		 ; to the caller.  If underline, outputs a CR without a LF.  If single
                  	           		 ; or double quote, prints the quoted string and demands a matching
                  	           		 ; end quote.  After the printing, the next i-word of the caller is
                  	           		 ; skipped over (usually a branch instruction).
                  	           		 ;
                  	           		 ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                  	           		 ; needed to pad the number of spaces to the number in r4.
                  	           		 ; However, if the number of digits is larger than the no. in
                  	           		 ; r4, all digits are printed anyway. Negative sign is also
                  	           		 ; printed and counted in, positive sign is not.
                  	           		 ;
                  	           		 ; 'PRTLN' prints the saved text line pointed to by r3
                  	           		 ; with line no. and all.
                  	           		 ;
                  	           		 
                  	           		 ; r1 = pointer to string
                  	           		 ; r2 = stop character
                  	           		 ; return r1 = pointer to end of line + 1
                  	           		 
FFFFFFFFFFFFE144	           		 PRTSTG:
FFFFFFFFFFFFE144	0DEF0020		     sub     sp,sp,#32
FFFFFFFFFFFFE148	67E28000		     sw		r5,[sp]
FFFFFFFFFFFFE14C	67E28008		     sw		r5,8[sp]
FFFFFFFFFFFFE150	67E38010		     sw		r7,16[sp]
FFFFFFFFFFFFE154	67EF8018		     sw		lr,24[sp]
FFFFFFFFFFFFE158	02128009		     mov     r5,r1       ; r5 = pointer
FFFFFFFFFFFFE15C	02230009		     mov     r6,r2       ; r6 = stop char
FFFFFFFFFFFFE160	           		 PS1:
FFFFFFFFFFFFE160	4A538000		     lbu     r7,[r5]     ; get a text character
FFFFFFFFFFFFE164	0A528001		     addui   r5,r5,#1
FFFFFFFFFFFFE168	BE7300C8		 	beq	    r7,r6,PRTRET		; same as stop character? if so, return
FFFFFFFFFFFFE16C	02708009		 	mov     r1,r7
FFFFFFFFFFFFE170	31FFF393		 	call	GOOUT		; display the char.
FFFFFFFFFFFFE174	B27FFB0D		 	bnei    r7,#CR,PS1  ; is it a C.R.? no, go back for more
FFFFFFFFFFFFE178	E040000A		 	setlo   r1,#LF      ; yes, add a L.F.
FFFFFFFFFFFFE17C	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE180	           		 PRTRET:
FFFFFFFFFFFFE180	02710009		     mov     r2,r7       ; return r2 = stop char
FFFFFFFFFFFFE184	02508009		 	mov		r1,r5		; return r1 = line pointer
FFFFFFFFFFFFE188	47EF8018		     lw		lr,24[sp]
FFFFFFFFFFFFE18C	47E38010		     lw		r7,16[sp]
FFFFFFFFFFFFE190	47E28008		     lw		r5,8[sp]
FFFFFFFFFFFFE194	47E28000		     lw		r5,[sp]
FFFFFFFFFFFFE198	37EF8020		     ret		#32	        ; then return
                  	           		 
                  	           		 
FFFFFFFFFFFFE19C	           		 QTSTG:
FFFFFFFFFFFFE19C	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE1A0	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE1A4	E0C00022		 	setlo	r3,#'"'
FFFFFFFFFFFFE1A8	E13FE1D0		 	setlo	r4,#<QT3
FFFFFFFFFFFFE1AC	F10FFFFF		 	sethi	r4,#>QT3
FFFFFFFFFFFFE1B0	31FFF8F1		 	call	TSTC		; *** QTSTG ***
FFFFFFFFFFFFE1B4	E0800022		 	setlo	r2,#'"'		; it is a "
FFFFFFFFFFFFE1B8	           		 QT1:
FFFFFFFFFFFFE1B8	04800409		 	or		r1,r8,r0
FFFFFFFFFFFFE1BC	31FFF851		 	call	PRTSTG		; print until another
FFFFFFFFFFFFE1C0	04102009		 	lw		r8,r1
FFFFFFFFFFFFE1C4	B2200F0A		 	bne		r2,#LF,QT2	; was last one a CR?
FFFFFFFFFFFFE1C8	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFE1CC	BE00070A		 	bra		RUNNXL		; if so, run next line
FFFFFFFFFFFFE1D0	           		 QT3:
FFFFFFFFFFFFE1D0	E0C00027		 	setlo	r3,#''''
FFFFFFFFFFFFE1D4	E13FE1E8		 	setlo	r4,#<QT4
FFFFFFFFFFFFE1D8	F10FFFFF		 	sethi	r4,#>QT4
FFFFFFFFFFFFE1DC	31FFF8F1		 	call	TSTC		; is it a single quote?
FFFFFFFFFFFFE1E0	E0800027		 	setlo	r2,#''''	; if so, do same as above
FFFFFFFFFFFFE1E4	BE007EAA		 	bra		QT1
FFFFFFFFFFFFE1E8	           		 QT4:
FFFFFFFFFFFFE1E8	E0C0005F		 	setlo	r3,#'_'
FFFFFFFFFFFFE1EC	E13FE20C		 	setlo	r4,#<QT5
FFFFFFFFFFFFE1F0	F10FFFFF		 	sethi	r4,#>QT5
FFFFFFFFFFFFE1F4	31FFF8F1		 	call	TSTC		; is it an underline?
FFFFFFFFFFFFE1F8	E040000D		 	setlo	r1,#CR		; if so, output a CR without LF
FFFFFFFFFFFFE1FC	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE200	           		 QT2:
FFFFFFFFFFFFE200	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE204	0BEF0008		 	addui	sp,sp,#8
FFFFFFFFFFFFE208	35F00004		 	jal		r0,4[lr]		; skip over next i-word when returning
FFFFFFFFFFFFE20C	           		 QT5:						; not " ' or _
FFFFFFFFFFFFE20C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE210	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; Output a CR LF sequence
                  	           		 ;
FFFFFFFFFFFFE214	           		 prCRLF:
FFFFFFFFFFFFE214	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE218	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE21C	E040000D		 	setlo	r1,#CR
FFFFFFFFFFFFE220	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE224	E040000A		 	setlo	r1,#LF
FFFFFFFFFFFFE228	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE22C	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE230	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; r1 = number to print
                  	           		 ; r2 = number of digits
                  	           		 ; Register Usage
                  	           		 ;	r5 = number of padding spaces
FFFFFFFFFFFFE234	           		 PRTNUM:
FFFFFFFFFFFFE234	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFE238	67E18000		 	sw		r3,[sp]
FFFFFFFFFFFFE23C	67E28008		 	sw		r5,8[sp]
FFFFFFFFFFFFE240	67E30010		 	sw		r6,16[sp]
FFFFFFFFFFFFE244	67E38018		 	sw		r7,24[sp]
FFFFFFFFFFFFE248	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFE24C	16039100		 	ori		r7,r0,#NUMWKA	; r7 = pointer to numeric work area
FFFFFFFFFFFFE250	02130009		 	mov		r6,r1		; save number for later
FFFFFFFFFFFFE254	02228009		 	mov		r5,r2		; r5 = min number of chars
FFFFFFFFFFFFE258	BE100063		 	bgt		r1,r0,PN1	; is it negative? if not
FFFFFFFFFFFFE25C	02108006		 	neg		r1,r1		; else make it positive
FFFFFFFFFFFFE260	0E528001		 	subui	r5,r5,#1	; one less for width count
FFFFFFFFFFFFE264	           		 PN1:
FFFFFFFFFFFFE264	1601800A		 	lw		r3,#10
FFFFFFFFFFFFE268	0411881C		 	mod		r2,r1,r3	; r2 = r1 mod 10
FFFFFFFFFFFFE26C	1C10800A		 	divui	r1,r1,#10	; r1 /= 10 divide by 10
FFFFFFFFFFFFE270	0A210030		 	addui	r2,r2,#'0'	; convert remainder to ascii
FFFFFFFFFFFFE274	60710000		 	sb		r2,[r7]		; and store in buffer
FFFFFFFFFFFFE278	0A738001		 	addui	r7,r7,#1
FFFFFFFFFFFFE27C	0E528001		 	subui	r5,r5,#1	; decrement width
FFFFFFFFFFFFE280	BE107F29		 	bne		r1,r0,PN1
FFFFFFFFFFFFE284	           		 PN6:
FFFFFFFFFFFFE284	BE500082		 	ble		r5,r0,PN4	; test pad count, skip padding if not needed
FFFFFFFFFFFFE288	           		 PN3:
FFFFFFFFFFFFE288	E0400020		 	setlo	r1,#' '		; display the required leading spaces
FFFFFFFFFFFFE28C	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE290	BE02FFCF		 	loop	r5,PN3
FFFFFFFFFFFFE294	           		 PN4:
FFFFFFFFFFFFE294	BE600063		 	bgt		r6,r0,PN5	; is number negative?
FFFFFFFFFFFFE298	E040002D		 	setlo	r1,#'-'		; if so, display the sign
FFFFFFFFFFFFE29C	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE2A0	           		 PN5:
FFFFFFFFFFFFE2A0	0E738001		 	subui	r7,r7,#1
FFFFFFFFFFFFE2A4	40708000		 	lb		r1,[r7]		; now unstack the digits and display
FFFFFFFFFFFFE2A8	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE2AC	12709100		 	cmpui	r1,r7,#NUMWKA
FFFFFFFFFFFFE2B0	BE107F87		 	bgtu	r1,r0,PN5
FFFFFFFFFFFFE2B4	           		 PNRET:
FFFFFFFFFFFFE2B4	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFE2B8	47E38018		 	lw		r7,24[sp]
FFFFFFFFFFFFE2BC	47E30010		 	lw		r6,16[sp]
FFFFFFFFFFFFE2C0	47E28008		 	lw		r5,8[sp]
FFFFFFFFFFFFE2C4	47E18000		 	lw		r3,[sp]
FFFFFFFFFFFFE2C8	37EF8028		 	ret		#40
                  	           		 
                  	           		 
                  	           		 ; r1 = number to print
                  	           		 ; r2 = number of digits
FFFFFFFFFFFFE2CC	           		 PRTHEXNUM:
FFFFFFFFFFFFE2CC	0FEF0028		 	subui	sp,sp,#40
FFFFFFFFFFFFE2D0	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFE2D4	67E30008		 	sw		r6,8[sp]
FFFFFFFFFFFFE2D8	67E38010		 	sw		r7,16[sp]
FFFFFFFFFFFFE2DC	67E40018		 	sw		r8,24[sp]
FFFFFFFFFFFFE2E0	67EF8020		 	sw		lr,32[sp]
FFFFFFFFFFFFE2E4	E1C01100		 	setlo	r7,#<NUMWKA	; r7 = pointer to numeric work area
FFFFFFFFFFFFE2E8	F1C00000		 	sethi	r7,#>NUMWKA
FFFFFFFFFFFFE2EC	04101809		 	or		r6,r1,r0	; save number for later
FFFFFFFFFFFFE2F0	E1400014		 	setlo	r5,#20		; r5 = min number of chars
FFFFFFFFFFFFE2F4	04101009		 	or		r4,r1,r0
FFFFFFFFFFFFE2F8	BE400083		 	bgt		r4,r0,PHN1		; is it negative? if not
FFFFFFFFFFFFE2FC	02420006		 	neg		r4,r4			; else make it positive
FFFFFFFFFFFFE300	0C528001		 	sub		r5,r5,#1	; one less for width count
FFFFFFFFFFFFE304	E2000014		 	setlo	r8,#20		; maximum of 10 digits
FFFFFFFFFFFFE308	           		 PHN1:
FFFFFFFFFFFFE308	04400409		 	or		r1,r4,r0
FFFFFFFFFFFFE30C	1410800F		 	andi	r1,r1,#15
FFFFFFFFFFFFE310	A010030A		 	blt		r1,#10,PHN7
FFFFFFFFFFFFE314	0A108037		 	addui	r1,r1,#'A'-10
FFFFFFFFFFFFE318	BE00004A		 	bra		PHN8
FFFFFFFFFFFFE31C	           		 PHN7:
FFFFFFFFFFFFE31C	08108030		 	add		r1,r1,#'0'		; convert remainder to ascii
FFFFFFFFFFFFE320	           		 PHN8:
FFFFFFFFFFFFE320	60708000		 	sb		r1,[r7]		; and store in buffer
FFFFFFFFFFFFE324	08738001		 	add		r7,r7,#1
FFFFFFFFFFFFE328	0C528001		 	sub		r5,r5,#1	; decrement width
FFFFFFFFFFFFE32C	           		 	shru	r4,r4,#4
FFFFFFFFFFFFE32C	BE400048		 	beq		r4,r0,PHN6			; is it zero yet ?
FFFFFFFFFFFFE330	BE047ECF		 	loop	r8,PHN1		; safety
FFFFFFFFFFFFE334	           		 PHN6:	; test pad count
FFFFFFFFFFFFE334	BE500082		 	ble		r5,r0,PHN4	; skip padding if not needed
FFFFFFFFFFFFE338	           		 PHN3:
FFFFFFFFFFFFE338	E0400020		 	setlo	r1,#' '		; display the required leading spaces
FFFFFFFFFFFFE33C	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE340	BE02FFCF		 	loop	r5,PHN3
FFFFFFFFFFFFE344	           		 PHN4:
FFFFFFFFFFFFE344	BE600063		 	bgt		r6,r0,PHN5	; is number negative?
FFFFFFFFFFFFE348	E040002D		 	setlo	r1,#'-'		; if so, display the sign
FFFFFFFFFFFFE34C	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE350	           		 PHN5:
FFFFFFFFFFFFE350	0C738001		 	sub		r7,r7,#1
FFFFFFFFFFFFE354	40708000		 	lb		r1,[r7]		; now unstack the digits and display
FFFFFFFFFFFFE358	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE35C	12709100		 	cmpui	r1,r7,#NUMWKA
FFFFFFFFFFFFE360	BE107F83		 	bgt		r1,r0,PHN5
FFFFFFFFFFFFE364	           		 PHNRET:
FFFFFFFFFFFFE364	47EF8020		 	lw		lr,32[sp]
FFFFFFFFFFFFE368	47E40018		 	lw		r8,24[sp]
FFFFFFFFFFFFE36C	47E38010		 	lw		r7,16[sp]
FFFFFFFFFFFFE370	47E30008		 	lw		r6,8[sp]
FFFFFFFFFFFFE374	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFE378	37EF8028		 	ret		#40
                  	           		 
                  	           		 
                  	           		 ; r1 = pointer to line
                  	           		 ; returns r1 = pointer to end of line + 1
FFFFFFFFFFFFE37C	           		 PRTLN:
FFFFFFFFFFFFE37C	0FEF0010		     subui   sp,sp,#16
FFFFFFFFFFFFE380	67E28000		     sw		r5,[sp]
FFFFFFFFFFFFE384	67EF8008		     sw		lr,8[sp]
FFFFFFFFFFFFE388	08128002		     addi    r5,r1,#2
FFFFFFFFFFFFE38C	4A50FFFE		     lbu		r1,-2[r5]	; get the binary line number
FFFFFFFFFFFFE390	4A517FFF		     lbu		r2,-1[r5]
FFFFFFFFFFFFE394	06211000		     shli	r2,r2,#8
FFFFFFFFFFFFE398	04110409		     or		r1,r1,r2
FFFFFFFFFFFFE39C	E0800000		     setlo   r2,#0       ; display a 0 or more digit line no.
FFFFFFFFFFFFE3A0	31FFF88D		 	call	PRTNUM
FFFFFFFFFFFFE3A4	E0400020		 	setlo   r1,#' '     ; followed by a blank
FFFFFFFFFFFFE3A8	31FFF393		 	call	GOOUT
FFFFFFFFFFFFE3AC	E0800000		 	setlo   r2,#0       ; stop char. is a zero
FFFFFFFFFFFFE3B0	04500409		 	or      r1,r5,r0
FFFFFFFFFFFFE3B4	31FFF851		 	call    PRTSTG		; display the rest of the line
FFFFFFFFFFFFE3B8	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFE3BC	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFE3C0	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; ===== Test text byte following the call to this subroutine. If it
                  	           		 ;	equals the byte pointed to by r8, return to the code following
                  	           		 ;	the call. If they are not equal, brnch to the point
                  	           		 ;	indicated in r4.
                  	           		 ;
                  	           		 ; Registers Affected
                  	           		 ;   r3,r8
                  	           		 ; Returns
                  	           		 ;	r8 = updated text pointer
                  	           		 ;
FFFFFFFFFFFFE3C4	           		 TSTC
FFFFFFFFFFFFE3C4	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFE3C8	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE3CC	67E08008		 	sw		r1,8[sp]
FFFFFFFFFFFFE3D0	31FFF914		 	call	IGNBLK		; ignore leading blanks
FFFFFFFFFFFFE3D4	40808000		 	lb		r1,[r8]
FFFFFFFFFFFFE3D8	BE3080A8		 	beq		r3,r1,TC1	; is it = to what r8 points to? if so
FFFFFFFFFFFFE3DC	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFE3E0	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE3E4	0BEF0010		 	addui	sp,sp,#16
FFFFFFFFFFFFE3E8	34400000		 	jal		r0,[r4]		; jump to the routine
FFFFFFFFFFFFE3EC	           		 TC1:
FFFFFFFFFFFFE3EC	08840001		 	add		r8,r8,#1	; if equal, bump text pointer
FFFFFFFFFFFFE3F0	47E08008		 	lw		r1,8[sp]
FFFFFFFFFFFFE3F4	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE3F8	37EF8010		 	ret		#16
                  	           		 
                  	           		 ; ===== See if the text pointed to by r8 is a number. If so,
                  	           		 ;	return the number in r2 and the number of digits in r3,
                  	           		 ;	else return zero in r2 and r3.
                  	           		 ; Registers Affected
                  	           		 ;   r1,r2,r3,r4
                  	           		 ; Returns
                  	           		 ; 	r1 = number
                  	           		 ;	r2 = number of digits in number
                  	           		 ;	r8 = updated text pointer
                  	           		 ;
FFFFFFFFFFFFE3FC	           		 TSTNUM:
FFFFFFFFFFFFE3FC	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE400	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE404	31FFF914		 	call	IGNBLK		; skip over blanks
FFFFFFFFFFFFE408	E0400000		 	setlo	r1,#0		; initialize return parameters
FFFFFFFFFFFFE40C	E0800000		 	setlo	r2,#0
FFFFFFFFFFFFE410	           		 TN1:
FFFFFFFFFFFFE410	40818000		 	lb		r3,[r8]
FFFFFFFFFFFFE414	A8300D30		 	bltui	r3,#'0',TSNMRET	; is it less than zero?
FFFFFFFFFFFFE418	AE300C39		 	bgtui	r3,#'9',TSNMRET	; is it greater than nine?
FFFFFFFFFFFFE41C	E13FFFFF		 	setlo	r4,#0xFFFFFFFF
FFFFFFFFFFFFE420	F10FFFFF		 	sethi	r4,#0x07FFFFFF
FFFFFFFFFFFFE424	BE120066		 	bleu	r1,r4,TN2	; see if there's room for new digit
FFFFFFFFFFFFE428	E07FE629		 	setlo	r1,msgNumTooBig
FFFFFFFFFFFFE42C	BE0057AA		 	bra		ERROR		; if not, we've overflowd
FFFFFFFFFFFFE430	           		 TN2:
FFFFFFFFFFFFE430	1A10800A		 	mului	r1,r1,#10	; quickly multiply result by 10
FFFFFFFFFFFFE434	08840001		 	addi	r8,r8,#1	; adjust text pointer
FFFFFFFFFFFFE438	1431800F		 	andi	r3,r3,#0x0F	; add in the new digit
FFFFFFFFFFFFE43C	04118402		 	add		r1,r1,r3
FFFFFFFFFFFFE440	08210001		 	addi	r2,r2,#1	; increment the no. of digits
FFFFFFFFFFFFE444	BE007E6A		 	bra		TN1
FFFFFFFFFFFFE448	           		 TSNMRET:
FFFFFFFFFFFFE448	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE44C	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ;===== Skip over blanks in the text pointed to by r8.
                  	           		 ;
                  	           		 ; Registers Affected:
                  	           		 ;	r8
                  	           		 ; Returns
                  	           		 ;	r8 = pointer updateded past any spaces or tabs
                  	           		 ;
FFFFFFFFFFFFE450	           		 IGNBLK:
FFFFFFFFFFFFE450	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE454	67E08000		 	sw		r1,[sp]
FFFFFFFFFFFFE458	           		 IGB2:
FFFFFFFFFFFFE458	40808000		 	lb		r1,[r8]			; get char
FFFFFFFFFFFFE45C	B0100220		 	beqi	r1,#' ',IGB1	; see if it's a space
FFFFFFFFFFFFE460	B2100300		 	bnei	r1,#'\t',IGBRET	; or a tab
FFFFFFFFFFFFE464	           		 IGB1:
FFFFFFFFFFFFE464	08840001		 	add		r8,r8,#1		; increment the text pointer
FFFFFFFFFFFFE468	BE007F8A		 	bra		IGB2
FFFFFFFFFFFFE46C	           		 IGBRET:
FFFFFFFFFFFFE46C	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFE470	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; ===== Convert the line of text in the input buffer to upper
                  	           		 ;	case (except for stuff between quotes).
                  	           		 ;
                  	           		 ; Registers Affected
                  	           		 ;   r1,r3
                  	           		 ; Returns
                  	           		 ;	r8 = pointing to end of text in buffer
                  	           		 ;
FFFFFFFFFFFFE474	           		 TOUPBUF:
FFFFFFFFFFFFE474	0FEF0008		 	subui	sp,sp,#8
FFFFFFFFFFFFE478	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE47C	E200111B		 	setlo	r8,BUFFER	; set up text pointer
FFFFFFFFFFFFE480	E0C00000		 	setlo	r3,#0		; clear quote flag
FFFFFFFFFFFFE484	           		 TOUPB1:
FFFFFFFFFFFFE484	40808000		 	lb		r1,[r8]		; get the next text char.
FFFFFFFFFFFFE488	08840001		 	add		r8,r8,#1
FFFFFFFFFFFFE48C	B0100D0D		 	beqi	r1,#CR,TOUPBRT		; is it end of line?
FFFFFFFFFFFFE490	B0100622		 	beqi	r1,#'"',DOQUO	; a double quote?
FFFFFFFFFFFFE494	B0100527		 	beqi	r1,#'''',DOQUO	; or a single quote?
FFFFFFFFFFFFE498	BE307F69		 	bne		r3,r0,TOUPB1	; inside quotes?
FFFFFFFFFFFFE49C	31FFF932		 	call	toUpper 	; convert to upper case
FFFFFFFFFFFFE4A0	6080FFFF		 	sb		r1,-1[r8]	; store it
FFFFFFFFFFFFE4A4	BE007F0A		 	bra		TOUPB1		; and go back for more
FFFFFFFFFFFFE4A8	           		 DOQUO:
FFFFFFFFFFFFE4A8	BE300069		 	bne		r3,r0,DOQUO1; are we inside quotes?
FFFFFFFFFFFFE4AC	04100C09		 	or		r3,r1,r0	; if not, toggle inside-quotes flag
FFFFFFFFFFFFE4B0	BE007EAA		 	bra		TOUPB1
FFFFFFFFFFFFE4B4	           		 DOQUO1:
FFFFFFFFFFFFE4B4	BE30FE89		 	bne		r3,r1,TOUPB1		; make sure we're ending proper quote
FFFFFFFFFFFFE4B8	E0C00000		 	setlo	r3,#0		; else clear quote flag
FFFFFFFFFFFFE4BC	BE007E4A		 	bra		TOUPB1
FFFFFFFFFFFFE4C0	           		 TOUPBRT:
FFFFFFFFFFFFE4C0	47EF8000		 	lw		lr,[sp]
FFFFFFFFFFFFE4C4	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; ===== Convert the character in r1 to upper case
                  	           		 ;
FFFFFFFFFFFFE4C8	           		 toUpper
FFFFFFFFFFFFE4C8	A0100361		 	blt		r1,#'a',TOUPRET	; is it < 'a'?
FFFFFFFFFFFFE4CC	A610027A		 	bgt		r1,#'z',TOUPRET	; or > 'z'?
FFFFFFFFFFFFE4D0	0C108020		 	sub		r1,r1,#32	; if not, make it upper case
FFFFFFFFFFFFE4D4	           		 TOUPRET
FFFFFFFFFFFFE4D4	37EF8000		 	ret
                  	           		 
                  	           		 
                  	           		 ; 'CHKIO' checks the input. If there's no input, it will return
                  	           		 ; to the caller with the r1=0. If there is input, the input byte is in r1.
                  	           		 ; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                  	           		 ; not return to the caller.
                  	           		 ;
FFFFFFFFFFFFE4D8	           		 CHKIO:
FFFFFFFFFFFFE4D8	0FEF0008		 	subui	sp,sp,#8	; save link reg
FFFFFFFFFFFFE4DC	67EF8000		 	sw		lr,[sp]
FFFFFFFFFFFFE4E0	31FFF394		 	call	GOIN		; get input if possible
FFFFFFFFFFFFE4E4	B01003FF		 	beq		r1,#-1,CHKRET2		; if Zero, no input
FFFFFFFFFFFFE4E8	B2100303		 	bnei	r1,#CTRLC,CHKRET	; is it control-C?
FFFFFFFFFFFFE4EC	33FFF3BE		 	jmp		WSTART		; if so, do a warm start
FFFFFFFFFFFFE4F0	           		 CHKRET2:
FFFFFFFFFFFFE4F0	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFE4F4	           		 CHKRET:
FFFFFFFFFFFFE4F4	47EF8000		 	lw		lr,[sp]		;r1=0
FFFFFFFFFFFFE4F8	37EF8008		 	ret		#8
                  	           		 
                  	           		 
                  	           		 ; ===== Display a CR-LF sequence
                  	           		 ;
FFFFFFFFFFFFE4FC	           		 CRLF:
FFFFFFFFFFFFE4FC	E07FE60B		 	setlo	r1,CLMSG
                  	           		 
                  	           		 
                  	           		 ; ===== Display a zero-ended string pointed to by register r1
                  	           		 ; Registers Affected
                  	           		 ;   r1,r2,r4
                  	           		 ;
FFFFFFFFFFFFE500	           		 PRMESG:
FFFFFFFFFFFFE500	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFE504	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFE508	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFE50C	02128009		 	mov     r5,r1       ; r5 = pointer to message
FFFFFFFFFFFFE510	           		 PRMESG1:
FFFFFFFFFFFFE510	08528001		 	add		r5,r5,#1
FFFFFFFFFFFFE514	4050FFFF		 	lb		r1,-1[r5]	; 	get the char.
FFFFFFFFFFFFE518	BE100068		 	beq		r1,r0,PRMRET
FFFFFFFFFFFFE51C	31FFF393		 	call	GOOUT		;else display it trashes r4
FFFFFFFFFFFFE520	BE007F8A		 	bra		PRMESG1
FFFFFFFFFFFFE524	           		 PRMRET:
FFFFFFFFFFFFE524	02508009		 	mov		r1,r5
FFFFFFFFFFFFE528	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFE52C	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFE530	37EF8010		 	ret		#16
                  	           		 
                  	           		 
                  	           		 ; ===== Display a zero-ended string pointed to by register r1
                  	           		 ; Registers Affected
                  	           		 ;   r1,r2,r3
                  	           		 ;
FFFFFFFFFFFFE534	           		 PRMESGAUX:
FFFFFFFFFFFFE534	0FEF0010		 	subui	sp,sp,#16
FFFFFFFFFFFFE538	67E28000		 	sw		r5,[sp]
FFFFFFFFFFFFE53C	67EF8008		 	sw		lr,8[sp]
FFFFFFFFFFFFE540	02128009		 	mov     r5,r1       ; r3 = pointer
FFFFFFFFFFFFE544	           		 PRMESGA1:
FFFFFFFFFFFFE544	0A528001		 	addui	r5,r5,#1
FFFFFFFFFFFFE548	4050FFFF		 	lb		r1,-1[r5]	; 	get the char.
FFFFFFFFFFFFE54C	BE100068		 	beq		r1,r0,PRMRETA
FFFFFFFFFFFFE550	31FFF395		 	call	GOAUXO		;else display it
FFFFFFFFFFFFE554	BE007F8A		 	bra		PRMESGA1
FFFFFFFFFFFFE558	           		 PRMRETA:
FFFFFFFFFFFFE558	02508009		 	mov		r1,r5
FFFFFFFFFFFFE55C	47EF8008		 	lw		lr,8[sp]
FFFFFFFFFFFFE560	47E28000		 	lw		r5,[sp]
FFFFFFFFFFFFE564	37EF8010		 	ret		#16
                  	           		 
                  	           		 ;*****************************************************
                  	           		 ; The following routines are the only ones that need *
                  	           		 ; to be changed for a different I/O environment.     *
                  	           		 ;*****************************************************
                  	           		 
                  	           		 
                  	           		 ; ===== Output character to the console (Port 1) from register r1
                  	           		 ;	(Preserves all registers.)
                  	           		 ;
FFFFFFFFFFFFE568	           		 OUTC:
FFFFFFFFFFFFE568	33FFEF47		 	jmp		DisplayChar
                  	           		 
                  	           		 
                  	           		 ; ===== Input a character from the console into register D0 (or
                  	           		 ;	return Zero status if there's no character available).
                  	           		 ;
FFFFFFFFFFFFE56C	           		 INC:
FFFFFFFFFFFFE56C	33FFEE08		 	jmp		KeybdGetChar
                  	           		 
                  	           		 
                  	           		 ;*
                  	           		 ;* ===== Input a character from the host into register r1 (or
                  	           		 ;*	return Zero status if there's no character available).
                  	           		 ;*
FFFFFFFFFFFFE570	           		 AUXIN:
FFFFFFFFFFFFE570	31FFED54		 	call	SerialGetChar
FFFFFFFFFFFFE574	B01003FF		 	beqi	r1,#-1,AXIRET_ZERO
FFFFFFFFFFFFE578	1410807F		 	andi	r1,r1,#0x7f		;zero out the high bit
FFFFFFFFFFFFE57C	           		 AXIRET:
FFFFFFFFFFFFE57C	37EF8000		 	ret
FFFFFFFFFFFFE580	           		 AXIRET_ZERO:
FFFFFFFFFFFFE580	0410840A		 	xor		r1,r1,r1
FFFFFFFFFFFFE584	37EF8000		 	ret
                  	           		 
                  	           		 ; ===== Output character to the host (Port 2) from register r1
                  	           		 ;	(Preserves all registers.)
                  	           		 ;
FFFFFFFFFFFFE588	           		 AUXOUT
FFFFFFFFFFFFE588	33FFED0C		 	jmp		SerialPutChar	; call boot rom routine
                  	           		 
                  	           		 
FFFFFFFFFFFFE58C	           		 _cls
FFFFFFFFFFFFE58C	31FFEED9		 	call	clearScreen
FFFFFFFFFFFFE590	BE00740A		 	bra		FINISH
                  	           		 
FFFFFFFFFFFFE594	           		 _wait10
FFFFFFFFFFFFE594	37EF8000		 	ret
FFFFFFFFFFFFE598	           		 _getATAStatus
FFFFFFFFFFFFE598	37EF8000		 	ret
FFFFFFFFFFFFE59C	           		 _waitCFNotBusy
FFFFFFFFFFFFE59C	37EF8000		 	ret
FFFFFFFFFFFFE5A0	           		 _rdcf
FFFFFFFFFFFFE5A0	BE00738A		 	br		FINISH
FFFFFFFFFFFFE5A4	           		 rdcf6
FFFFFFFFFFFFE5A4	BE004BEA		 	br		ERROR
                  	           		 
                  	           		 
                  	           		 ; ===== Return to the resident monitor, operating system, etc.
                  	           		 ;
FFFFFFFFFFFFE5A8	           		 BYEBYE:
FFFFFFFFFFFFE5A8	460F1088		 	lw		sp,OSSP
FFFFFFFFFFFFE5AC	47EF8000		     lw      lr,[sp]
FFFFFFFFFFFFE5B0	37EF8008		 	ret		#8
                  	           		 
                  	           		 ;	MOVE.B	#228,D7 	return to Tutor
                  	           		 ;	TRAP	#14
                  	           		 
FFFFFFFFFFFFE5B0 C44E4100BCBD3CBD	 	.align	16
FFFFFFFFFFFFE5B8 0000000000D24F00
FFFFFFFFFFFFE5C0	           		 	.align	16
FFFFFFFFFFFFE5C0 726F747061520A0D	 msgInit db	CR,LF,"Raptor64 Tiny BASIC v1.0",CR,LF,"(C) 2012  Robert Finch",CR,LF,LF,0
FFFFFFFFFFFFE5C8 20796E6954203436
FFFFFFFFFFFFE5D0 3176204349534142
FFFFFFFFFFFFE5D8 202943280A0D302E
FFFFFFFFFFFFE5E0 6F52202032313032
FFFFFFFFFFFFE5E8 6E69462074726562
FFFFFFFFFFFFE5F0 0A0D000A0A0D6863	 OKMSG	db	CR,LF,"OK",CR,LF,0
FFFFFFFFFFFFE5F8 616857000A0D4B4F	 msgWhat	db	"What?",CR,LF,0
FFFFFFFFFFFFE600 726F53000A0D3F74	 SRYMSG	db	"Sorry."
FFFFFFFFFFFFE608 6F43000A0D2E7972	 msgReadError	db	"Compact FLASH read error",CR,LF,0
FFFFFFFFFFFFE610 4C4620746361706D
FFFFFFFFFFFFE618 6461657220485341
FFFFFFFFFFFFE620 0A0D726F72726520
FFFFFFFFFFFFE628 207265626D754E00	 msgNumTooBig	db	"Number is too big",CR,LF,0
FFFFFFFFFFFFE630 62206F6F74207369
FFFFFFFFFFFFE638 766944000A0D6769	 msgDivZero		db	"Division by zero",CR,LF,0
FFFFFFFFFFFFE640 7962206E6F697369
FFFFFFFFFFFFE648 000A0D6F72657A20
FFFFFFFFFFFFE650 7620666F2074754F	 msgVarSpace     db  "Out of variable space",CR,LF,0
FFFFFFFFFFFFE658 20656C6261697261
FFFFFFFFFFFFE660 000A0D6563617073
FFFFFFFFFFFFE668 6620736574796220	 msgBytesFree	db	" bytes free",CR,LF,0
FFFFFFFFFFFFE670 0A0D000A0D656572	 msgReady		db	CR,LF,"Ready",CR,LF,0
FFFFFFFFFFFFE678 000A0D7964616552
FFFFFFFFFFFFE680 6E69746365707845	 msgComma		db	"Expecting a comma",CR,LF,0
FFFFFFFFFFFFE688 6D6D6F6320612067
FFFFFFFFFFFFE690 656E694C000A0D61	 msgLineRange	db	"Line number too big",CR,LF,0
FFFFFFFFFFFFE698 207265626D756E20
FFFFFFFFFFFFE6A0 0D676962206F6F74
FFFFFFFFFFFFE6A8 746365707845000A	 msgVar			db	"Expecting a variable",CR,LF,0
FFFFFFFFFFFFE6B0 6176206120676E69
FFFFFFFFFFFFE6B8 0A0D656C62616972
FFFFFFFFFFFFE6C0 64616220444E5200	 msgRNDBad		db	"RND bad parameter",CR,LF,0
FFFFFFFFFFFFE6C8 74656D6172617020
FFFFFFFFFFFFE6D0 535953000A0D7265	 msgSYSBad		db	"SYS bad address",CR,LF,0
FFFFFFFFFFFFE6D8 6464612064616220
FFFFFFFFFFFFE6E0 49000A0D73736572	 msgInputVar		db	"INPUT expecting a variable",CR,LF,0
FFFFFFFFFFFFE6E8 707865205455504E
FFFFFFFFFFFFE6F0 6120676E69746365
FFFFFFFFFFFFE6F8 6C62616972617620
FFFFFFFFFFFFE700 5458454E000A0D65	 msgNextFor		db	"NEXT without FOR",CR,LF,0
FFFFFFFFFFFFE708 74756F6874697720
FFFFFFFFFFFFE710 4E000A0D524F4620	 msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
FFFFFFFFFFFFE718 6570786520545845
FFFFFFFFFFFFE720 206120676E697463
FFFFFFFFFFFFE728 2064656E69666564
FFFFFFFFFFFFE730 656C626169726176
FFFFFFFFFFFFE738 2F4F544F47000A0D	 msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
FFFFFFFFFFFFE740 6162204255534F47
FFFFFFFFFFFFE748 6E20656E696C2064
FFFFFFFFFFFFE750 000A0D7265626D75
FFFFFFFFFFFFE758 77204E5255544552	 msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
FFFFFFFFFFFFE760 472074756F687469
FFFFFFFFFFFFE768 50000A0D4255534F	 msgTooBig		db	"Program is too big",CR,LF,0
FFFFFFFFFFFFE770 69206D6172676F72
FFFFFFFFFFFFE778 6962206F6F742073
FFFFFFFFFFFFE780 72747845000A0D67	 msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
FFFFFFFFFFFFE788 6361726168632061
FFFFFFFFFFFFE790 206E6F2073726574
FFFFFFFFFFFFE798 6E676920656E696C
                  	           		 
FFFFFFFFFFFFE7A0 00000A0D6465726F	 	align	8
FFFFFFFFFFFFE7A8	           		 	align	8
                  	           		 LSTROM	equ	*		; end of possible ROM area
                  	           		 ;	END
                  	           		 
                  	           		 ;*
                  	           		 ;* ===== Return to the resident monitor, operating system, etc.
                  	           		 ;*
FFFFFFFFFFFFE7A8	           		 BYEBYE:
FFFFFFFFFFFFE7A8	33FFF096		 	jmp		Monitor
                  	           		 ;    MOVE.B	#228,D7 	;return to Tutor
                  	           		 ;	TRAP	#14
                  	           		 
                  	           		 ;==============================================================================
                  	           		 ; Checkerboard RAM tester
                  	           		 ;==============================================================================
                  	           		 ;
FFFFFFFFFFFFE7AC	           		 	code
FFFFFFFFFFFFE7A8 0000000033FFF096	 	align	16
FFFFFFFFFFFFE7B0	           		 	align	16
FFFFFFFFFFFFE7B0	           		 ramtest:
FFFFFFFFFFFFE7B0	04002009		 	or		r8,r0,r0		; r8 = 0
FFFFFFFFFFFFE7B4	E6AA5555		; SETLO
FFFFFFFFFFFFE7B8	EE9556AA		; SETMID
FFFFFFFFFFFFE7BC	F68AAAA5		; SETHI
FFFFFFFFFFFFE7C0	040D0409		 	ori		r1,r0,#0xAAAA5555AAAA5555	; checkerboard pattern
FFFFFFFFFFFFE7C4	           		 ramtest2:
FFFFFFFFFFFFE7C4	66808000		 	sw		r1,[r8]			; save the checkerboard to memory
FFFFFFFFFFFFE7C8	46810000		 	lw		r2,[r8]			; read it back
FFFFFFFFFFFFE7CC	04110C06		 	cmp		r3,r1,r2		; is it the same ?
FFFFFFFFFFFFE7D0	BE3000C9		 	bne 	r3,r0,ramtest1
FFFFFFFFFFFFE7D4	0A840008		 	addui	r8,r8,#8		; increment RAM pointer
FFFFFFFFFFFFE7D8	E6800000		; SETLO
FFFFFFFFFFFFE7DC	EE800010		; SETMID
FFFFFFFFFFFFE7E0	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0400_0000
FFFFFFFFFFFFE7E4	BE307F00		 	blt		r3,r0,ramtest2
FFFFFFFFFFFFE7E8	           		 ramtest1:
FFFFFFFFFFFFE7E8	04802809		 	or		r10,r8,r0		; r10 = max ram address
                  	           		 	; readback the checkerboard pattern
FFFFFFFFFFFFE7EC	04002009		 	or		r8,r0,r0		; r8 = 0
FFFFFFFFFFFFE7F0	           		 ramtest4:
FFFFFFFFFFFFE7F0	46810000		 	lw		r2,[r8]
FFFFFFFFFFFFE7F4	E6AA5555		; SETLO
FFFFFFFFFFFFE7F8	EE9556AA		; SETMID
FFFFFFFFFFFFE7FC	F68AAAA5		; SETHI
FFFFFFFFFFFFE800	042D0C06		 	cmpi	r3,r2,#0xAAAA5555AAAA5555
FFFFFFFFFFFFE804	BE3000C9		 	bne		r3,r0,ramtest3
FFFFFFFFFFFFE808	08840008		 	addi	r8,r8,#8
FFFFFFFFFFFFE80C	E6800000		; SETLO
FFFFFFFFFFFFE810	EE800004		; SETMID
FFFFFFFFFFFFE814	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0100_0000
FFFFFFFFFFFFE818	BE307EC0		 	blt 	r3,r0,ramtest4
FFFFFFFFFFFFE81C	           		 ramtest3:
FFFFFFFFFFFFE81C	BE850389		 	bne		r8,r10,ramtest8	; check for equal maximum address
                  	           		 
                  	           		 	; perform ramtest again with inverted checkerboard
FFFFFFFFFFFFE820	04002009		 	or		r8,r0,r0		; r8 = 0
FFFFFFFFFFFFE824	E695AAAA		; SETLO
FFFFFFFFFFFFE828	EEAAA955		; SETMID
FFFFFFFFFFFFE82C	F685555A		; SETHI
FFFFFFFFFFFFE830	040D0409		 	ori		r1,r0,#0x5555AAAA5555AAAA
FFFFFFFFFFFFE834	           		 ramtest5:
FFFFFFFFFFFFE834	66808000		 	sw		r1,[r8]
FFFFFFFFFFFFE838	46810000		 	lw		r2,[r8]
FFFFFFFFFFFFE83C	04110C06		 	cmp		r3,r1,r2
FFFFFFFFFFFFE840	BE3000C9		 	bne		r3,r0,ramtest6
FFFFFFFFFFFFE844	08840008		 	addi	r8,r8,#8
FFFFFFFFFFFFE848	E6800000		; SETLO
FFFFFFFFFFFFE84C	EE800004		; SETMID
FFFFFFFFFFFFE850	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0100_0000
FFFFFFFFFFFFE854	BE307F00		 	blt		r3,r0,ramtest5
FFFFFFFFFFFFE858	           		 ramtest6:
FFFFFFFFFFFFE858	04802C09		 	or		r11,r8,r0		; r11 = max ram address
                  	           		 	; readback checkerboard
FFFFFFFFFFFFE85C	04002009		 	or		r8,r0,r0
FFFFFFFFFFFFE860	           		 ramtest7:
FFFFFFFFFFFFE860	46810000		 	lw		r2,[r8]
FFFFFFFFFFFFE864	E695AAAA		; SETLO
FFFFFFFFFFFFE868	EEAAA955		; SETMID
FFFFFFFFFFFFE86C	F685555A		; SETHI
FFFFFFFFFFFFE870	042D0C06		 	cmpi	r3,r2,#0x5555AAAA5555AAAA
FFFFFFFFFFFFE874	BE3000C9		 	bne		r3,r0,ramtest8
FFFFFFFFFFFFE878	08840008		 	addi	r8,r8,#8
FFFFFFFFFFFFE87C	E6800000		; SETLO
FFFFFFFFFFFFE880	EE800004		; SETMID
FFFFFFFFFFFFE884	048D0C06		 	cmpi	r3,r8,#0x0000_0000_0100_0000
FFFFFFFFFFFFE888	BE307EC0		 	blt		r3,r0,ramtest7
FFFFFFFFFFFFE88C	           		 ramtest8:
FFFFFFFFFFFFE88C	BE858048		 	beq		r8,r11,ramtest9
FFFFFFFFFFFFE890	0485A014		 	min		r8,r8,r11
FFFFFFFFFFFFE894	           		 ramtest9:
FFFFFFFFFFFFE894	BE850048		 	beq		r8,r10,ramtest10
FFFFFFFFFFFFE898	04852014		 	min		r8,r8,r10
FFFFFFFFFFFFE89C	           		 ramtest10:
FFFFFFFFFFFFE89C	66040400		 	sw		r8,0x00000400	;memend
FFFFFFFFFFFFE8A0	37EF8000		 	ret
                  	           		 
                  	           		 ;-------------------------------------------
                  	           		 ;-------------------------------------------
                  	           		 ;
FFFFFFFFFFFFE8A4	           		 iberr_rout:
FFFFFFFFFFFFE8A4	9A00E92B		 	lea		r1,msgiberr
FFFFFFFFFFFFE8A8	31FFEFE7		 	call	DisplayString
FFFFFFFFFFFFE8AC	020085E8		 	mfspr	r1,EPC
FFFFFFFFFFFFE8B0	31FFF019		 	call	DisplayWord
FFFFFFFFFFFFE8B4	00000028		 	wait
FFFFFFFFFFFFE8B8	33FFEC07		 	jmp		start
FFFFFFFFFFFFE8BC	           		 dberr_rout:
FFFFFFFFFFFFE8BC	9A00E910		 	lea		r1,msgdberr
FFFFFFFFFFFFE8C0	31FFEFE7		 	call	DisplayString
FFFFFFFFFFFFE8C4	02008628		 	mfspr	r1,ERRADR
FFFFFFFFFFFFE8C8	31FFF019		 	call	DisplayWord
FFFFFFFFFFFFE8CC	9A00E924		 	lea		r1,msgEPC
FFFFFFFFFFFFE8D0	31FFEFE7		 	call	DisplayString
FFFFFFFFFFFFE8D4	020085E8		 	mfspr	r1,EPC
FFFFFFFFFFFFE8D8	31FFF019		 	call	DisplayWord
FFFFFFFFFFFFE8DC	31FFF93F		 	call	CRLF
FFFFFFFFFFFFE8E0	1601001F		 	lw		r2,#31
FFFFFFFFFFFFE8E4	           		 dberr1:
FFFFFFFFFFFFE8E4	02200FA9		 	mtspr	PCHI,r2
FFFFFFFFFFFFE8E8	DE000000		 	nop
FFFFFFFFFFFFE8EC	DE000000		 	nop
FFFFFFFFFFFFE8F0	DE000000		 	nop
FFFFFFFFFFFFE8F4	02008FE8		 	mfspr	r1,PCHISTORIC
FFFFFFFFFFFFE8F8	31FFF019		 	call	DisplayWord
FFFFFFFFFFFFE8FC	31FFF93F		 	call	CRLF
FFFFFFFFFFFFE900	BE017F2F		 	loop	r2,dberr1
FFFFFFFFFFFFE904	00000028		 	wait
FFFFFFFFFFFFE908	33FFEC07		 	jmp		start
FFFFFFFFFFFFE908 0000000033FFEC07	 	.align	16
FFFFFFFFFFFFE910	           		 	.align	16
FFFFFFFFFFFFE910	           		 msgdberr:
FFFFFFFFFFFFE910 7375622061746144	 	db	"Data bus error at: ",0
FFFFFFFFFFFFE918 6120726F72726520
FFFFFFFFFFFFE924	           		 msgEPC:
FFFFFFFFFFFFE920 4350452000203A74	 	db	" EPC: ",0
FFFFFFFFFFFFE92B	           		 msgiberr:
FFFFFFFFFFFFE928 662072724500203A	 	db	"Err fetching instruction at: ",0
FFFFFFFFFFFFE930 20676E6968637465
FFFFFFFFFFFFE938 7463757274736E69
FFFFFFFFFFFFE940 203A7461206E6F69
FFFFFFFFFFFFE948 0000000000000000	 	.align	16
FFFFFFFFFFFFE950	           		 	.align	16
                  	           		 
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ; IRQ routine
                  	           		 ;------------------------------------------------------------------------------
                  	           		 ;
FFFFFFFFFFFFE950	           		 irqrout:
FFFFFFFFFFFFE950	0FEF0020		 	subui	sp,sp,#32
FFFFFFFFFFFFE954	67E08000		 	sw		r1,[sp]					; save off a working register
FFFFFFFFFFFFE958	67E10008		 	sw		r2,8[sp]				; and a second work register
FFFFFFFFFFFFE95C	67ED0010		 	sw		r26,16[sp]				; save off implicit constant builder reg
FFFFFFFFFFFFE960	67EF8018		 	sw		lr,24[sp]				
FFFFFFFFFFFFE964	E69C0FF0		; SETLO
FFFFFFFFFFFFE968	EE800003		; SETMID
FFFFFFFFFFFFE96C	6A0D0421		 	inch	r1,PIC					; r1= which IRQ line is active
                  	           		 	
                  	           		 ; 1000 Hz interrupt
                  	           		 ; This IRQ must be fast, so it's placed inline
                  	           		 ; Increments the millisecond counter, and switches to the next context
                  	           		 ;
FFFFFFFFFFFFE970	           		 irq1000Hz:
FFFFFFFFFFFFE970	B2101602		 	bnei	r1,#2,irq100Hz
FFFFFFFFFFFFE974	E6BF0000		; SETLO
FFFFFFFFFFFFE978	6A0D0028		 	outb	r0,0xFFFFFFFF_FFFF0000	; acknowledge interrupt
FFFFFFFFFFFFE97C	46009400		 	lw		r1,Milliseconds			; increment milliseconds count
FFFFFFFFFFFFE980	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFE984	66009400		 	sw		r1,Milliseconds
FFFFFFFFFFFFE988	E6900000		; SETLO
FFFFFFFFFFFFE98C	EE800003		; SETMID
FFFFFFFFFFFFE990	6A0D082D		 	lea		r2,TEXTSCR
FFFFFFFFFFFFE994	8220814C		 	inch	r1,332[r2]
FFFFFFFFFFFFE998	0A108001		 	addui	r1,r1,#1
FFFFFFFFFFFFE99C	9220814C		 	outc	r1,332[r2]
FFFFFFFFFFFFE9A0	47EF8018		 	lw		lr,24[sp]				
FFFFFFFFFFFFE9A4	47ED0010		 	lw		r26,16[sp]				; restore registers from stack
FFFFFFFFFFFFE9A8	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFE9AC	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFE9B0	0BEF0020		 	addui	sp,sp,#32				; restore stack pointer
FFFFFFFFFFFFE9B4	0000000F		 	iepp							; move to the next context
FFFFFFFFFFFFE9B8	DE000000		 	nop
FFFFFFFFFFFFE9BC	DE000000		 	nop
FFFFFFFFFFFFE9C0	DE000000		 	nop
FFFFFFFFFFFFE9C4	01900020		 	iret							; return to the next context
                  	           		 
                  	           		 ; 100 Hz interrupt
                  	           		 ; This IRQ could have some work to do, including flashing a cursor. So
                  	           		 ; we call a subroutine.
                  	           		 ;
FFFFFFFFFFFFE9C8	           		 irq100Hz:
FFFFFFFFFFFFE9C8	B2100403		 	bnei	r1,#3,irqSerial
FFFFFFFFFFFFE9CC	4600B000		 	lw		r1,p100IRQvec
                  	           		 ;	jal		lr,[r1]
FFFFFFFFFFFFE9D0	31FFEE3B		 	call	Pulse100
FFFFFFFFFFFFE9D4	BE0001AA		 	bra		irqret
                  	           		 
FFFFFFFFFFFFE9D8	           		 irqSerial:
FFFFFFFFFFFFE9D8	B2100408		 	bnei	r1,#8,irqRaster
FFFFFFFFFFFFE9DC	4600B010		 	lw		r1,serialIRQvec
FFFFFFFFFFFFE9E0	341F8000		 	jal		lr,[r1]
FFFFFFFFFFFFE9E4	BE00012A		 	bra		irqret
                  	           		 
FFFFFFFFFFFFE9E8	           		 irqRaster:
FFFFFFFFFFFFE9E8	B210040D		 	bnei	r1,#13,irqKeybd
FFFFFFFFFFFFE9EC	4600B018		 	lw		r1,rasterIRQvec
                  	           		 ;	jal		lr,[r1]
FFFFFFFFFFFFE9F0	31FFF2B1		 	call	RasterIRQfn
FFFFFFFFFFFFE9F4	BE0000AA		 	bra		irqret
                  	           		 
FFFFFFFFFFFFE9F8	           		 irqKeybd:
FFFFFFFFFFFFE9F8	B0118901		 	beqi	r1,#1,ColdStart			; CTRL-ALT-DEL interrupt
FFFFFFFFFFFFE9FC	B210030F		 	bnei	r1,#15,irqret
FFFFFFFFFFFFEA00	4600B008		 	lw		r1,keybdIRQvec
FFFFFFFFFFFFEA04	31FFEDF1		 	call	KeybdIRQ
                  	           		 ;	jal		lr,[r1]
                  	           		 
FFFFFFFFFFFFEA08	           		 irqret:
FFFFFFFFFFFFEA08	47EF8018		 	lw		lr,24[sp]				
FFFFFFFFFFFFEA0C	47ED0010		 	lw		r26,16[sp]				; restore registers from stack
FFFFFFFFFFFFEA10	47E10008		 	lw		r2,8[sp]
FFFFFFFFFFFFEA14	47E08000		 	lw		r1,[sp]
FFFFFFFFFFFFEA18	0BEF0020		 	addui	sp,sp,#32				; restore stack pointer
FFFFFFFFFFFFEA1C	01900020		 	iret
                  	           		 
                  	           		 ;-------------------------------------------
                  	           		 ; NMI routine
                  	           		 ;-------------------------------------------
FFFFFFFFFFFFEA20	           		 nmirout:
FFFFFFFFFFFFEA20	01900020		 	iret
                  	           		 
                  	           		 ;-------------------------------------------
                  	           		 ; Handle miss on Data TLB
                  	           		 ;-------------------------------------------
FFFFFFFFFFFFEA24	           		 DTLBHandler:
FFFFFFFFFFFFEA24	E6BF0000		; SETLO
FFFFFFFFFFFFEA28	6A0D0413		 	sw		r1,0xFFFF_FFFF_FFFF_0000
FFFFFFFFFFFFEA2C	E6BF0008		; SETLO
FFFFFFFFFFFFEA30	6A0D0813		 	sw		r2,0xFFFF_FFFF_FFFF_0008
FFFFFFFFFFFFEA34	           		 dh1:
FFFFFFFFFFFFEA34	02008034		 	omgi	r1,#0		; try open mutex gate #0 (TLB protector)
FFFFFFFFFFFFEA38	BE107FE9		 	bne		r1,r0,dh1	; spinlock if gate is closed
FFFFFFFFFFFFEA3C	02008128		 	mfspr	r1,PTA		; get the page table address
FFFFFFFFFFFFEA40	02010228		 	mfspr	r2,BadVAddr	; get the bad virtual address
FFFFFFFFFFFFEA44	022002E9		 	mtspr	TLBVirtPage,r2	; which virtual address to update
FFFFFFFFFFFFEA48	06211A01		 	shrui	r2,r2,#13	; turn va into index
FFFFFFFFFFFFEA4C	04110403		 	addu	r1,r1,r2
FFFFFFFFFFFFEA50	46110000		 	lw		r2,[r1]		; get the physical address from the table
FFFFFFFFFFFFEA54	14210000		 	and		r2,r2,#FFFF_FFFF_FFFF_E000	; mask off lower bits
FFFFFFFFFFFFEA58	022002A9		 	mtspr	TLBPhysPage0,r2	;
FFFFFFFFFFFFEA5C	46110008		 	lw		r2,8[r1]	; get the physical address from the table
FFFFFFFFFFFFEA60	14210000		 	and		r2,r2,#FFFF_FFFF_FFFF_E000	; mask off lower bits
FFFFFFFFFFFFEA64	022002E9		 	mtspr	TLBPhysPage1,r2	;
FFFFFFFFFFFFEA68	02000034		 	tlbwr				; update a random entry in the TLB
FFFFFFFFFFFFEA6C	02000035		 	cmgi	#0			; close the mutex gate
FFFFFFFFFFFFEA70	E6BF0000		; SETLO
FFFFFFFFFFFFEA74	6A0D0403		 	lw		r1,0xFFFF_FFFF_FFFF_0000
FFFFFFFFFFFFEA78	E6BF0008		; SETLO
FFFFFFFFFFFFEA7C	6A0D0803		 	lw		r2,0xFFFF_FFFF_FFFF_0008
FFFFFFFFFFFFEA80	01900020		 	iret
FFFFFFFFFFFFEA80 0000000001900020	 	.align	32
FFFFFFFFFFFFEA88 6A0D0803E6BF0008
FFFFFFFFFFFFEA90 0000000000000000
FFFFFFFFFFFFEA98 0000000000000000
FFFFFFFFFFFFEAA0	           		 	.align	32
                  	           		 
FFFFFFFFFFFFFFB0	           		 	org		0xFFFF_FFFF_FFFF_FFB0
FFFFFFFFFFFFFFB0	33FFFA89		 	jmp		DTLBHandler
FFFFFFFFFFFFFFB4	DE000000		 	nop
FFFFFFFFFFFFFFB8	DE000000		 	nop
FFFFFFFFFFFFFFC0	           		 	org		0xFFFF_FFFF_FFFF_FFC0
FFFFFFFFFFFFFFC0	33FFFA89		 	jmp		DTLBHandler
FFFFFFFFFFFFFFC4	DE000000		 	nop
FFFFFFFFFFFFFFC8	DE000000		 	nop
                  	           		 
                  	           		 	; NMI vector
FFFFFFFFFFFFFFE0	           		 	org     0xFFFF_FFFF_FFFF_FFE0
FFFFFFFFFFFFFFE0	33FFFA88		 	jmp		nmirout
FFFFFFFFFFFFFFE4	DE000000		 	nop
FFFFFFFFFFFFFFE8	DE000000		 	nop
                  	           		 	
                  	           		 	; RST vector
FFFFFFFFFFFFFFF0	           		 	org		0xFFFF_FFFF_FFFF_FFF0
FFFFFFFFFFFFFFF0	33FFEC07		 	jmp		start
FFFFFFFFFFFFFFF4	DE000000		 	nop
FFFFFFFFFFFFFFF8	DE000000		 	nop
                  	           		 
                  	           		 
                  	           		 
FFFFFFFFFFFFFFFC	00000000		 
0000000000000000	00000000		 
 
 
Symbol Table:
==========================================================
Name                   Typ  Segment     Address/Value
----------------------------------------------------------
CR                  	C	constant	000000000000000D
LF                  	C	constant	000000000000000A
TAB                 	C	constant	0000000000000009
CTRLC               	C	constant	0000000000000003
CTRLH               	C	constant	0000000000000008
CTRLS               	C	constant	0000000000000013
CTRLX               	C	constant	0000000000000018
XON                 	C	constant	0000000000000011
XOFF                	C	constant	0000000000000013
DATA_PRESENT        	C	constant	0000000000000001
XMIT_NOT_FULL       	C	constant	0000000000000020
BUFLEN              	C	constant	0000000000000050
STACKTOP0           	C	constant	FFFFFFFFFFFEFFF8
STACKTOP1           	C	constant	FFFFFFFFFFFEFBF8
STACKTOP2           	C	constant	FFFFFFFFFFFEF7F8
STACKTOP3           	C	constant	FFFFFFFFFFFEF3F8
STACKTOP4           	C	constant	FFFFFFFFFFFEEFF8
STACKTOP5           	C	constant	FFFFFFFFFFFEEBF8
STACKTOP6           	C	constant	FFFFFFFFFFFEE7F8
STACKTOP7           	C	constant	FFFFFFFFFFFEE3F8
STACKTOP8           	C	constant	FFFFFFFFFFFEDFF8
STACKTOP9           	C	constant	FFFFFFFFFFFEDBF8
STACKTOP10          	C	constant	FFFFFFFFFFFED7F8
STACKTOP11          	C	constant	FFFFFFFFFFFED3F8
STACKTOP12          	C	constant	FFFFFFFFFFFECFF8
STACKTOP13          	C	constant	FFFFFFFFFFFECBF8
STACKTOP14          	C	constant	FFFFFFFFFFFEC7F8
STACKTOP15          	C	constant	FFFFFFFFFFFEC3F8
TCBSize             	C	constant	0000000000000200
TCBBase             	C	constant	0000000100000000
TCBr1               	C	constant	0000000000000000
TCBr2               	C	constant	0000000000000008
TCBr3               	C	constant	0000000000000010
TCBr4               	C	constant	0000000000000018
TCBr5               	C	constant	0000000000000020
TCBr6               	C	constant	0000000000000028
TCBr7               	C	constant	0000000000000030
TCBr8               	C	constant	0000000000000038
TCBr9               	C	constant	0000000000000040
TCBr10              	C	constant	0000000000000048
TCBr11              	C	constant	0000000000000050
TCBr12              	C	constant	0000000000000058
TCBr13              	C	constant	0000000000000060
TCBr14              	C	constant	0000000000000068
TCBr15              	C	constant	0000000000000070
TCBr16              	C	constant	0000000000000078
TCBr17              	C	constant	0000000000000080
TCBr18              	C	constant	0000000000000088
TCBr19              	C	constant	0000000000000090
TCBr20              	C	constant	0000000000000098
TCBr21              	C	constant	00000000000000A0
TCBr22              	C	constant	00000000000000A8
TCBr23              	C	constant	00000000000000B0
TCBr24              	C	constant	00000000000000B8
TCBr25              	C	constant	00000000000000C0
TCBr26              	C	constant	00000000000000C8
TCBr27              	C	constant	00000000000000D0
TCBr28              	C	constant	00000000000000D8
TCBr29              	C	constant	00000000000000E0
TCBr30              	C	constant	00000000000000E8
TCBr31              	C	constant	00000000000000F0
warmStart           	C	constant	0000000000001020
usrJmp              	C	constant	0000000000001028
TickIRQAddr         	C	constant	0000000000001030
TaskBlock           	C	constant	0000000000001038
tencount            	C	constant	00000000000013F8
Milliseconds        	C	constant	0000000000001400
Lastloc             	C	constant	0000000000001408
ScreenColor         	C	constant	0000000000001414
CursorRow           	C	constant	0000000000001416
CursorCol           	C	constant	0000000000001418
CursorFlash         	C	constant	000000000000141A
KeybdEcho           	C	constant	000000000000141C
KeybdBuffer         	C	constant	0000000000001440
KeybdHead           	C	constant	0000000000001450
KeybdTail           	C	constant	0000000000001451
Score               	C	constant	0000000000001500
Manpos              	C	constant	0000000000001508
MissileActive       	C	constant	0000000000001510
MissileX            	C	constant	0000000000001512
MissileY            	C	constant	0000000000001514
InvadersRow1        	C	constant	0000000000001520
InvadersRow2        	C	constant	0000000000001530
InvadersRow3        	C	constant	0000000000001540
InvadersRow4        	C	constant	0000000000001550
InvadersRow5        	C	constant	0000000000001560
InvadersColpos      	C	constant	0000000000001570
InvadersRowpos      	C	constant	0000000000001571
Uart_rxfifo         	C	constant	0000000000001600
Uart_rxhead         	C	constant	0000000000001800
Uart_rxtail         	C	constant	0000000000001802
Uart_ms             	C	constant	0000000000001808
Uart_rxrts          	C	constant	0000000000001809
Uart_rxdtr          	C	constant	000000000000180A
Uart_rxxon          	C	constant	000000000000180B
Uart_rxflow         	C	constant	000000000000180C
Uart_fon            	C	constant	000000000000180E
Uart_foff           	C	constant	0000000000001810
Uart_txrts          	C	constant	0000000000001812
Uart_txdtr          	C	constant	0000000000001813
Uart_txxon          	C	constant	0000000000001814
Uart_txxonoff       	C	constant	0000000000001815
TaskList            	C	constant	0000000000002000
ReadyList1          	C	constant	0000000000002000
ReadyList2          	C	constant	0000000000002020
ReadyList3          	C	constant	0000000000002040
ReadyList4          	C	constant	0000000000002060
ReadyList5          	C	constant	0000000000002080
ReadyNdx1           	C	constant	00000000000020A0
ReadyNdx2           	C	constant	00000000000020A1
ReadyNdx3           	C	constant	00000000000020A2
ReadyNdx4           	C	constant	00000000000020A3
ReadyNdx5           	C	constant	00000000000020A4
RunningTCB          	C	constant	00000000000020A6
NextToRunTCB        	C	constant	00000000000020A8
r1save              	C	constant	00000000000020B0
r2save              	C	constant	00000000000020B8
AXCstart            	C	constant	00000000000020C0
p100IRQvec          	C	constant	0000000000003000
keybdIRQvec         	C	constant	0000000000003008
serialIRQvec        	C	constant	0000000000003010
rasterIRQvec        	C	constant	0000000000003018
TEXTSCR             	C	constant	0000000000D00000
COLORSCR            	C	constant	0000000000D10000
TEXTREG             	C	constant	0000000000DA0000
TEXT_COLS           	C	constant	0000000000000000
TEXT_ROWS           	C	constant	0000000000000002
TEXT_CURPOS         	C	constant	0000000000000016
KEYBD               	C	constant	0000000000DC0000
KEYBDCLR            	C	constant	0000000000DC0002
UART                	C	constant	0000000000DC0A00
UART_LS             	C	constant	0000000000DC0A01
UART_IS             	C	constant	0000000000DC0A03
UART_IE             	C	constant	0000000000DC0A04
UART_MC             	C	constant	0000000000DC0A06
DATETIME            	C	constant	0000000000DC0400
PIC                 	C	constant	0000000000DC0FF0
PIC_IE              	C	constant	0000000000DC0FF2
PSG                 	C	constant	0000000000D50000
PSGFREQ0            	C	constant	0000000000D50000
PSGPW0              	C	constant	0000000000D50002
PSGCTRL0            	C	constant	0000000000D50004
PSGADSR0            	C	constant	0000000000D50006
SPRRAM              	C	constant	0000000000D80000
AC97                	C	constant	0000000000DC1000
LED                 	C	constant	0000000000DC0600
GACCEL              	C	constant	0000000000DAE000
RASTERIRQ           	C	constant	0000000000DA0100
BOOT_STACK          	C	constant	FFFFFFFFFFFEFFF8
SPRITEREGS          	C	constant	0000000000DAD000
BITMAPSCR           	C	constant	0000000100200000
txempty             	C	constant	0000000000000040
rxfull              	C	constant	0000000000000001
txtWidth            	L	bss     	0000000000001038
txtHeight           	L	bss     	0000000000001039
cursx               	L	bss     	000000000000103A
cursy               	L	bss     	000000000000103B
pos                 	L	bss     	000000000000103C
dh                  	L	bss     	000000000000103C
0                   	L	bss     	000000000000103C
charToPrint         	L	bss     	0000000000001040
fgColor             	L	bss     	0000000000001042
bkColor             	L	bss     	0000000000001045
cursFlash           	L	bss     	0000000000001046
lineLinkTbl         	L	bss     	0000000000001047
typef               	L	bss     	0000000000001080
OSSP                	L	bss     	0000000000001088
CURRNT              	L	bss     	0000000000001090
STKGOS              	L	bss     	0000000000001098
STKINP              	L	bss     	00000000000010A0
LOPVAR              	L	bss     	00000000000010A8
LOPINC              	L	bss     	00000000000010B0
LOPLMT              	L	bss     	00000000000010B8
LOPLN               	L	bss     	00000000000010C0
LOPPT               	L	bss     	00000000000010C8
TXTUNF              	L	bss     	00000000000010D0
VARBGN              	L	bss     	00000000000010D8
IVARBGN             	L	bss     	00000000000010E0
SVARBGN             	L	bss     	00000000000010E8
FVARBGN             	L	bss     	00000000000010F0
STKBOT              	L	bss     	00000000000010F8
NUMWKA              	L	bss     	0000000000001100
BUFFER              	L	bss     	000000000000111B
TXT                 	C	constant	0000000100600000
SerialGetChar       	L	code    	FFFFFFFFFFFFB550
SerialPutChar       	L	code    	FFFFFFFFFFFFB430
SetKeyboardEcho     	L	code    	FFFFFFFFFFFFB818
KeybdCheckForKey    	L	code    	FFFFFFFFFFFFB874
KeybdGetChar        	L	code    	FFFFFFFFFFFFB820
DisplayChar         	L	code    	FFFFFFFFFFFFBD1C
DisplayString       	L	code    	FFFFFFFFFFFFBF9C
start               	L	code    	FFFFFFFFFFFFB01C
ColdStart           	L	code    	FFFFFFFFFFFFB01C
ict1                	L	code    	FFFFFFFFFFFFB028
ctxstart3           	L	code    	FFFFFFFFFFFFB1F8
ctxstart2           	L	code    	FFFFFFFFFFFFB210
ctxstart            	L	code    	FFFFFFFFFFFFB214
ctxstart1           	L	code    	FFFFFFFFFFFFB318
csj5                	L	code    	FFFFFFFFFFFFB22C
SerialInit          	L	code    	FFFFFFFFFFFFB3B0
KeybdInit           	L	code    	FFFFFFFFFFFFB7B0
PICInit             	L	code    	FFFFFFFFFFFFB390
SetupRasterIRQ      	L	code    	FFFFFFFFFFFFCA64
dcokay              	L	code    	FFFFFFFFFFFFB2C4
ClearScreen         	L	code    	FFFFFFFFFFFFBB64
ClearBmpScreen      	L	code    	FFFFFFFFFFFFBB10
RandomizeSprram     	L	code    	FFFFFFFFFFFFC7B4
DisplayStringCRLF   	L	code    	FFFFFFFFFFFFBFD4
Monitor             	L	code    	FFFFFFFFFFFFC258
SetupAC97           	L	code    	FFFFFFFFFFFFC7DC
Beep                	L	code    	FFFFFFFFFFFFC884
j4                  	L	code    	FFFFFFFFFFFFB310
HelloWorld          	L	code    	FFFFFFFFFFFFB31C
j3                  	L	code    	FFFFFFFFFFFFB334
j2                  	L	code    	FFFFFFFFFFFFB348
MSG                 	L	code    	FFFFFFFFFFFFB360
MSGSTART            	L	code    	FFFFFFFFFFFFB36D
PICret              	L	code    	FFFFFFFFFFFFB3AC
SerialGetCharDirect 	L	code    	FFFFFFFFFFFFB3F4
sgc1                	L	code    	FFFFFFFFFFFFC6E0
SerialCheckForCharDirect	L	code    	FFFFFFFFFFFFB418
spcb1               	L	code    	FFFFFFFFFFFFB490
spcb3               	L	code    	FFFFFFFFFFFFB470
spcabort            	L	code    	FFFFFFFFFFFFB518
spcb2               	L	code    	FFFFFFFFFFFFB4C0
spcb4               	L	code    	FFFFFFFFFFFFB4A0
spcb5               	L	code    	FFFFFFFFFFFFB4DC
spcb6               	L	code    	FFFFFFFFFFFFB4C8
spcb8               	L	code    	FFFFFFFFFFFFB4E4
spcb7               	L	code    	FFFFFFFFFFFFB50C
CharsInRxBuf        	L	code    	FFFFFFFFFFFFB52C
cirxb1              	L	code    	FFFFFFFFFFFFB54C
sgcfifo1            	L	code    	FFFFFFFFFFFFB610
sgcfifo2            	L	code    	FFFFFFFFFFFFB5FC
sgcfifo3            	L	code    	FFFFFFFFFFFFB5C0
sgcfifo4            	L	code    	FFFFFFFFFFFFB5E4
sgcfifo5            	L	code    	FFFFFFFFFFFFB5FC
SerialIRQ           	L	code    	FFFFFFFFFFFFB628
sirq1               	L	code    	FFFFFFFFFFFFB660
srxirq              	L	code    	FFFFFFFFFFFFB688
stxirq              	L	code    	FFFFFFFFFFFFB684
smsirq              	L	code    	FFFFFFFFFFFFB678
srxirq1             	L	code    	FFFFFFFFFFFFB688
srxirq3             	L	code    	FFFFFFFFFFFFB6B8
srxirq2             	L	code    	FFFFFFFFFFFFB6AC
srxirq5             	L	code    	FFFFFFFFFFFFB6D4
srxirq8             	L	code    	FFFFFFFFFFFFB764
srxirq6             	L	code    	FFFFFFFFFFFFB728
srxirq7             	L	code    	FFFFFFFFFFFFB74C
KeybdSC             	L	code    	FFFFFFFFFFFFB768
kbdsc1              	L	code    	FFFFFFFFFFFFB77C
kbdscRet            	L	code    	FFFFFFFFFFFFB7A4
kbdsc2              	L	code    	FFFFFFFFFFFFB78C
kbdsc3              	L	code    	FFFFFFFFFFFFB798
kbdsc4              	L	code    	FFFFFFFFFFFFB7A4
KeybdIRQ            	L	code    	FFFFFFFFFFFFB7C4
KeybdIRQa           	L	code    	FFFFFFFFFFFFB7D4
KeybdIRQb           	L	code    	FFFFFFFFFFFFB7FC
KeybdIRQc           	L	code    	FFFFFFFFFFFFB810
nochar              	L	code    	FFFFFFFFFFFFB864
kgc3                	L	code    	FFFFFFFFFFFFB868
kgc2                	L	code    	FFFFFFFFFFFFB85C
CRLF                	L	code    	FFFFFFFFFFFFE4FC
KeybdCheckForKeyDirect	L	code    	FFFFFFFFFFFFB884
KeybdGetCharDirect  	L	code    	FFFFFFFFFFFFB898
kgc1                	L	code    	FFFFFFFFFFFFB8A8
gk1                 	L	code    	FFFFFFFFFFFFB8E0
gk2                 	L	code    	FFFFFFFFFFFFB8DC
Pulse100            	L	code    	FFFFFFFFFFFFB8EC
DisplayDatetime     	L	code    	FFFFFFFFFFFFCB60
SelectNextToRunTCB  	L	code    	FFFFFFFFFFFFB928
SwitchTask          	L	code    	FFFFFFFFFFFFB930
p1001               	L	code    	FFFFFFFFFFFFB920
swtsk1              	L	code    	FFFFFFFFFFFFB950
FlashCursor         	L	code    	FFFFFFFFFFFFBA80
CalcScreenLoc       	L	code    	FFFFFFFFFFFFBCDC
flshcrsr2           	L	code    	FFFFFFFFFFFFBADC
flshcrsr3           	L	code    	FFFFFFFFFFFFBAB4
flshcrsr1           	L	code    	FFFFFFFFFFFFBAC8
CursorOff           	L	code    	FFFFFFFFFFFFBAE8
CursorOn            	L	code    	FFFFFFFFFFFFBAFC
csj4                	L	code    	FFFFFFFFFFFFBBAC
AsciiToScreen       	L	code    	FFFFFFFFFFFFBCAC
ScrollUp            	L	code    	FFFFFFFFFFFFBBD8
scrup1              	L	code    	FFFFFFFFFFFFBC18
BlankLine           	L	code    	FFFFFFFFFFFFBC58
blnkln1             	L	code    	FFFFFFFFFFFFBC90
atoscr1             	L	code    	FFFFFFFFFFFFBCC4
ScreenToAscii       	L	code    	FFFFFFFFFFFFBCCC
stasc1              	L	code    	FFFFFFFFFFFFBCD8
dccr                	L	code    	FFFFFFFFFFFFBD3C
dcx7                	L	code    	FFFFFFFFFFFFBD68
dcx6                	L	code    	FFFFFFFFFFFFBD80
dcx8                	L	code    	FFFFFFFFFFFFBDB0
dcx9                	L	code    	FFFFFFFFFFFFBDE0
dcx10               	L	code    	FFFFFFFFFFFFBE10
dcx11               	L	code    	FFFFFFFFFFFFBE44
dcx12               	L	code    	FFFFFFFFFFFFBE3C
dcx13               	L	code    	FFFFFFFFFFFFBE78
dcx5                	L	code    	FFFFFFFFFFFFBE98
dcx3                	L	code    	FFFFFFFFFFFFBECC
dcx4                	L	code    	FFFFFFFFFFFFBEF4
dclf                	L	code    	FFFFFFFFFFFFBEF0
IncCursorPos        	L	code    	FFFFFFFFFFFFBF10
IncCursorRow        	L	code    	FFFFFFFFFFFFBF48
icc1                	L	code    	FFFFFFFFFFFFBF84
icr1                	L	code    	FFFFFFFFFFFFBF5C
dspj1               	L	code    	FFFFFFFFFFFFBFB0
dsret               	L	code    	FFFFFFFFFFFFBFC4
DisplayNybble       	L	code    	FFFFFFFFFFFFC010
dispnyb1            	L	code    	FFFFFFFFFFFFC02C
DisplayByte         	L	code    	FFFFFFFFFFFFC03C
DisplayWord         	L	code    	FFFFFFFFFFFFC064
dspwd1              	L	code    	FFFFFFFFFFFFC078
DisplayMem          	L	code    	FFFFFFFFFFFFC094
dspmem1             	L	code    	FFFFFFFFFFFFC0B8
BinToBCD            	L	code    	FFFFFFFFFFFFC0E4
bta1                	L	code    	FFFFFFFFFFFFC108
BCDToAscii          	L	code    	FFFFFFFFFFFFC160
bta2                	L	code    	FFFFFFFFFFFFC178
BinToStr            	L	code    	FFFFFFFFFFFFC1BC
btos3               	L	code    	FFFFFFFFFFFFC1F0
btos1               	L	code    	FFFFFFFFFFFFC1F4
btos2               	L	code    	FFFFFFFFFFFFC224
PromptLn            	L	code    	FFFFFFFFFFFFC264
Prompt3             	L	code    	FFFFFFFFFFFFC270
Prompt1             	L	code    	FFFFFFFFFFFFC284
Prompt2             	L	code    	FFFFFFFFFFFFC2AC
Editmem             	L	code    	FFFFFFFFFFFFC404
Dumpmem             	L	code    	FFFFFFFFFFFFC43C
CSTART              	L	code    	FFFFFFFFFFFFCE70
ExecuteCode         	L	code    	FFFFFFFFFFFFC42C
LoadS19             	L	code    	FFFFFFFFFFFFC500
DisplayHelp         	L	code    	FFFFFFFFFFFFC314
TestCLS             	L	code    	FFFFFFFFFFFFC2E0
RandomLinesCall     	L	code    	FFFFFFFFFFFFC2D8
Invaders            	L	code    	FFFFFFFFFFFFCDAC
Piano               	L	code    	FFFFFFFFFFFFC95C
RandomLines         	L	code    	FFFFFFFFFFFFC6F0
HelpMsg             	L	code    	FFFFFFFFFFFFC320
ignBlanks           	L	code    	FFFFFFFFFFFFC3E0
ignBlanks1          	L	code    	FFFFFFFFFFFFC3E8
GetHexNumber        	L	code    	FFFFFFFFFFFFC470
edtmem1             	L	code    	FFFFFFFFFFFFC414
gthxn2              	L	code    	FFFFFFFFFFFFC488
AsciiToHexNybble    	L	code    	FFFFFFFFFFFFC4C0
gthxn1              	L	code    	FFFFFFFFFFFFC4AC
gthx3               	L	code    	FFFFFFFFFFFFC4F8
gthx5               	L	code    	FFFFFFFFFFFFC4D0
gthx6               	L	code    	FFFFFFFFFFFFC4E4
ProcessRec          	L	code    	FFFFFFFFFFFFC50C
NextRec             	L	code    	FFFFFFFFFFFFC504
sGetChar            	L	code    	FFFFFFFFFFFFC6C8
ProcessS1           	L	code    	FFFFFFFFFFFFC5C4
ProcessS2           	L	code    	FFFFFFFFFFFFC5CC
ProcessS3           	L	code    	FFFFFFFFFFFFC5D4
ProcessS7           	L	code    	FFFFFFFFFFFFC5DC
ProcessS8           	L	code    	FFFFFFFFFFFFC5E8
ProcessS9           	L	code    	FFFFFFFFFFFFC5F4
pcssxa              	L	code    	FFFFFFFFFFFFC56C
pcss1a              	L	code    	FFFFFFFFFFFFC574
S19Get16BitAddress  	L	code    	FFFFFFFFFFFFC600
S19Get24BitAddress  	L	code    	FFFFFFFFFFFFC618
S19Get32BitAddress  	L	code    	FFFFFFFFFFFFC630
S1932b              	L	code    	FFFFFFFFFFFFC684
S1932a              	L	code    	FFFFFFFFFFFFC664
sgc2                	L	code    	FFFFFFFFFFFFC6D0
AUXIN               	L	code    	FFFFFFFFFFFFE570
rl5                 	L	code    	FFFFFFFFFFFFC700
rl1                 	L	code    	FFFFFFFFFFFFC714
rl2                 	L	code    	FFFFFFFFFFFFC730
rl3                 	L	code    	FFFFFFFFFFFFC74C
rl4                 	L	code    	FFFFFFFFFFFFC768
rl8                 	L	code    	FFFFFFFFFFFFC794
rl7                 	L	code    	FFFFFFFFFFFFC7A4
rsr1                	L	code    	FFFFFFFFFFFFC7C4
sac974              	L	code    	FFFFFFFFFFFFC7E8
sac971              	L	code    	FFFFFFFFFFFFC7F4
sac973              	L	code    	FFFFFFFFFFFFC820
sac972              	L	code    	FFFFFFFFFFFFC860
sac975              	L	code    	FFFFFFFFFFFFC878
beep1               	L	code    	FFFFFFFFFFFFC8FC
beep2               	L	code    	FFFFFFFFFFFFC92C
playnt              	L	code    	FFFFFFFFFFFFC96C
playnt1a            	L	code    	FFFFFFFFFFFFC994
playnt1b            	L	code    	FFFFFFFFFFFFC9A0
playnt1c            	L	code    	FFFFFFFFFFFFC9AC
playnt1d            	L	code    	FFFFFFFFFFFFC9B8
playnt1e            	L	code    	FFFFFFFFFFFFC9C4
playnt1f            	L	code    	FFFFFFFFFFFFC9D0
playnt1g            	L	code    	FFFFFFFFFFFFC9DC
Tone                	L	code    	FFFFFFFFFFFFC9E8
tone1               	L	code    	FFFFFFFFFFFFCA28
tone2               	L	code    	FFFFFFFFFFFFCA44
RasterIRQfn         	L	code    	FFFFFFFFFFFFCAC4
rirq1               	L	code    	FFFFFFFFFFFFCAF4
rirq2               	L	code    	FFFFFFFFFFFFCAF4
rirq3               	L	code    	FFFFFFFFFFFFCAF4
rirq4               	L	code    	FFFFFFFFFFFFCAF4
rirq5               	L	code    	FFFFFFFFFFFFCAF4
rirq6               	L	code    	FFFFFFFFFFFFCAF4
rirq7               	L	code    	FFFFFFFFFFFFCAF4
rirq8               	L	code    	FFFFFFFFFFFFCAF4
InitializeGame      	L	code    	FFFFFFFFFFFFCBD0
DrawScore           	L	code    	FFFFFFFFFFFFCBF8
DrawMissile         	L	code    	FFFFFFFFFFFFCC28
MissileOff          	L	code    	FFFFFFFFFFFFCC84
DrawMan             	L	code    	FFFFFFFFFFFFCCAC
DrawInvader         	L	code    	FFFFFFFFFFFFCCF8
DrawInvaders        	L	code    	FFFFFFFFFFFFCD18
dinv1               	L	code    	FFFFFFFFFFFFCDA0
DrawBombs           	L	code    	FFFFFFFFFFFFCDA8
InvadersLoop        	L	code    	FFFFFFFFFFFFCDB8
TestMoveMan         	L	code    	FFFFFFFFFFFFCDCC
MoveManRight        	L	code    	FFFFFFFFFFFFCDE0
MoveManLeft         	L	code    	FFFFFFFFFFFFCDF8
FireMissile         	L	code    	FFFFFFFFFFFFCE0C
Invaders1           	L	code    	FFFFFFFFFFFFCE30
InvadersEnd         	L	code    	FFFFFFFFFFFFCE38
GOSTART             	L	code    	FFFFFFFFFFFFCE44
GOWARM              	L	code    	FFFFFFFFFFFFCE48
WSTART              	L	code    	FFFFFFFFFFFFCEF8
GOOUT               	L	code    	FFFFFFFFFFFFCE4C
OUTC                	L	code    	FFFFFFFFFFFFE568
GOIN                	L	code    	FFFFFFFFFFFFCE50
INC                 	L	code    	FFFFFFFFFFFFE56C
GOAUXO              	L	code    	FFFFFFFFFFFFCE54
AUXOUT              	L	code    	FFFFFFFFFFFFE588
GOAUXI              	L	code    	FFFFFFFFFFFFCE58
GOBYE               	L	code    	FFFFFFFFFFFFCE5C
BYEBYE              	L	code    	FFFFFFFFFFFFE7A8
TXTBGN              	L	code    	FFFFFFFFFFFFCE60
ENDMEM              	L	code    	FFFFFFFFFFFFCE68
PRMESGAUX           	L	code    	FFFFFFFFFFFFE534
PRMESG              	L	code    	FFFFFFFFFFFFE500
clearVars           	L	code    	FFFFFFFFFFFFD30C
PRTNUM              	L	code    	FFFFFFFFFFFFE234
ST3                 	L	code    	FFFFFFFFFFFFCF10
GETLN               	L	code    	FFFFFFFFFFFFDF60
TOUPBUF             	L	code    	FFFFFFFFFFFFE474
TSTNUM              	L	code    	FFFFFFFFFFFFE3FC
IGNBLK              	L	code    	FFFFFFFFFFFFE450
DIRECT              	L	code    	FFFFFFFFFFFFD210
ST2                 	L	code    	FFFFFFFFFFFFCF3C
ERROR               	L	code    	FFFFFFFFFFFFDF20
FNDLN               	L	code    	FFFFFFFFFFFFE030
ST4                 	L	code    	FFFFFFFFFFFFCF90
FNDNXT              	L	code    	FFFFFFFFFFFFE080
ST7                 	L	code    	FFFFFFFFFFFFCF6C
ST6                 	L	code    	FFFFFFFFFFFFCF88
MVUP                	L	code    	FFFFFFFFFFFFE0A4
ST5                 	L	code    	FFFFFFFFFFFFCFB8
MVDOWN              	L	code    	FFFFFFFFFFFFE0BC
TAB1                	L	code    	FFFFFFFFFFFFCFE0
TAB2                	L	code    	FFFFFFFFFFFFCFF2
TAB4                	L	code    	FFFFFFFFFFFFD042
TAB5                	L	code    	FFFFFFFFFFFFD063
TAB6                	L	code    	FFFFFFFFFFFFD066
TAB8                	L	code    	FFFFFFFFFFFFD06B
TAB9                	L	code    	FFFFFFFFFFFFD075
TAB10               	L	code    	FFFFFFFFFFFFD079
TAB1_1              	L	code    	FFFFFFFFFFFFD080
TAB2_1              	L	code    	FFFFFFFFFFFFD0A8
TAB4_1              	L	code    	FFFFFFFFFFFFD150
TAB5_1              	L	code    	FFFFFFFFFFFFD198
TAB6_1              	L	code    	FFFFFFFFFFFFD1A8
TAB8_1              	L	code    	FFFFFFFFFFFFD1B8
TAB9_1              	L	code    	FFFFFFFFFFFFD1F0
TAB10_1             	L	code    	FFFFFFFFFFFFD200
EXEC                	L	code    	FFFFFFFFFFFFD218
EXLP                	L	code    	FFFFFFFFFFFFD22C
EXNGO               	L	code    	FFFFFFFFFFFFD244
EXGO                	L	code    	FFFFFFFFFFFFD27C
EXMAT               	L	code    	FFFFFFFFFFFFD26C
EX1                 	L	code    	FFFFFFFFFFFFD25C
NEW                 	L	code    	FFFFFFFFFFFFD284
ENDCHK              	L	code    	FFFFFFFFFFFFDEE4
STOP                	L	code    	FFFFFFFFFFFFD294
RUN                 	L	code    	FFFFFFFFFFFFD29C
RUNNXL              	L	code    	FFFFFFFFFFFFD2AC
FNDLNP              	L	code    	FFFFFFFFFFFFE040
RUNTSL              	L	code    	FFFFFFFFFFFFD2CC
RUNSML              	L	code    	FFFFFFFFFFFFD2D4
CHKIO               	L	code    	FFFFFFFFFFFFE4D8
GOTO                	L	code    	FFFFFFFFFFFFD2E4
OREXPR              	L	code    	FFFFFFFFFFFFD8E8
_clr                	L	code    	FFFFFFFFFFFFD304
FINISH              	L	code    	FFFFFFFFFFFFD410
cv1                 	L	code    	FFFFFFFFFFFFD320
LISTX               	L	code    	FFFFFFFFFFFFD338
LS1                 	L	code    	FFFFFFFFFFFFD34C
LS4                 	L	code    	FFFFFFFFFFFFD354
PRTLN               	L	code    	FFFFFFFFFFFFE37C
LS3                 	L	code    	FFFFFFFFFFFFD374
LS2                 	L	code    	FFFFFFFFFFFFD36C
PRINT               	L	code    	FFFFFFFFFFFFD380
TSTC                	L	code    	FFFFFFFFFFFFE3C4
PR2                 	L	code    	FFFFFFFFFFFFD398
PR0                 	L	code    	FFFFFFFFFFFFD3AC
PR3                 	L	code    	FFFFFFFFFFFFD3E4
PR1                 	L	code    	FFFFFFFFFFFFD3C4
PR4                 	L	code    	FFFFFFFFFFFFD3DC
QTSTG               	L	code    	FFFFFFFFFFFFE19C
PR8                 	L	code    	FFFFFFFFFFFFD400
FIN                 	L	code    	FFFFFFFFFFFFDEA8
PR6                 	L	code    	FFFFFFFFFFFFD3F8
QWHAT               	L	code    	FFFFFFFFFFFFDF1C
GOSUB               	L	code    	FFFFFFFFFFFFD418
PUSHA               	L	code    	FFFFFFFFFFFFE0F8
gosub1              	L	code    	FFFFFFFFFFFFD430
RETURN              	L	code    	FFFFFFFFFFFFD454
return1             	L	code    	FFFFFFFFFFFFD468
POPA                	L	code    	FFFFFFFFFFFFE0C4
FOR                 	L	code    	FFFFFFFFFFFFD48C
SETVAL              	L	code    	FFFFFFFFFFFFDE60
FR1                 	L	code    	FFFFFFFFFFFFD4A4
FR2                 	L	code    	FFFFFFFFFFFFD4B8
FR4                 	L	code    	FFFFFFFFFFFFD4C4
FR3                 	L	code    	FFFFFFFFFFFFD4C0
FR5                 	L	code    	FFFFFFFFFFFFD4C8
FR7                 	L	code    	FFFFFFFFFFFFD4E4
FR6                 	L	code    	FFFFFFFFFFFFD4E0
FR8                 	L	code    	FFFFFFFFFFFFD504
NEXT                	L	code    	FFFFFFFFFFFFD508
TSTV                	L	code    	FFFFFFFFFFFFDBB0
NX4                 	L	code    	FFFFFFFFFFFFD51C
NX0                 	L	code    	FFFFFFFFFFFFD520
NX5                 	L	code    	FFFFFFFFFFFFD530
NX2                 	L	code    	FFFFFFFFFFFFD53C
NX1                 	L	code    	FFFFFFFFFFFFD55C
NXPurge             	L	code    	FFFFFFFFFFFFD570
NX3                 	L	code    	FFFFFFFFFFFFD560
IF                  	L	code    	FFFFFFFFFFFFD578
IF1                 	L	code    	FFFFFFFFFFFFD57C
IF2                 	L	code    	FFFFFFFFFFFFD580
FNDSKP              	L	code    	FFFFFFFFFFFFE084
IF3                 	L	code    	FFFFFFFFFFFFD590
INPERR              	L	code    	FFFFFFFFFFFFD594
INPUT               	L	code    	FFFFFFFFFFFFD5A8
IP6                 	L	code    	FFFFFFFFFFFFD5B0
IP2                 	L	code    	FFFFFFFFFFFFD5D0
IP4                 	L	code    	FFFFFFFFFFFFD640
IP3                 	L	code    	FFFFFFFFFFFFD600
IP7                 	L	code    	FFFFFFFFFFFFD5E8
PRTSTG              	L	code    	FFFFFFFFFFFFE144
IP5                 	L	code    	FFFFFFFFFFFFD650
DEFLT               	L	code    	FFFFFFFFFFFFD65C
LET                 	L	code    	FFFFFFFFFFFFD664
LT1                 	L	code    	FFFFFFFFFFFFD678
LOAD                	L	code    	FFFFFFFFFFFFD67C
LOD1                	L	code    	FFFFFFFFFFFFD688
LODEND              	L	code    	FFFFFFFFFFFFD6C8
GCHAR               	L	code    	FFFFFFFFFFFFD6D0
LOD2                	L	code    	FFFFFFFFFFFFD6B0
GCHAR1              	L	code    	FFFFFFFFFFFFD6E8
asciiToHex          	L	code    	FFFFFFFFFFFFD714
a2h1                	L	code    	FFFFFFFFFFFFD71C
SAVE                	L	code    	FFFFFFFFFFFFD728
SAVE1               	L	code    	FFFFFFFFFFFFD730
AUXOCRLF            	L	code    	FFFFFFFFFFFFD784
SAVEND              	L	code    	FFFFFFFFFFFFD76C
PWORD               	L	code    	FFFFFFFFFFFFD7A4
SAVE2               	L	code    	FFFFFFFFFFFFD758
pword1              	L	code    	FFFFFFFFFFFFD7B8
toAsciiHex          	L	code    	FFFFFFFFFFFFD7F4
pword2              	L	code    	FFFFFFFFFFFFD7D4
tah1                	L	code    	FFFFFFFFFFFFD800
POKE                	L	code    	FFFFFFFFFFFFD808
PKER                	L	code    	FFFFFFFFFFFFD834
POKEC               	L	code    	FFFFFFFFFFFFD83C
POKEH               	L	code    	FFFFFFFFFFFFD868
POKEW               	L	code    	FFFFFFFFFFFFD894
SYSX                	L	code    	FFFFFFFFFFFFD8C0
sysx1               	L	code    	FFFFFFFFFFFFD8D4
ANDEXPR             	L	code    	FFFFFFFFFFFFD920
XP_OR1              	L	code    	FFFFFFFFFFFFD8F4
XP_OR               	L	code    	FFFFFFFFFFFFD904
XP_ORX              	L	code    	FFFFFFFFFFFFD914
EXPR                	L	code    	FFFFFFFFFFFFD9B4
XP_AND1             	L	code    	FFFFFFFFFFFFD92C
XP_AND              	L	code    	FFFFFFFFFFFFD93C
XP_ANDX             	L	code    	FFFFFFFFFFFFD94C
isDigit             	L	code    	FFFFFFFFFFFFD958
isDigitFalse        	L	code    	FFFFFFFFFFFFD968
isAlpha             	L	code    	FFFFFFFFFFFFD970
isAlphaFalse        	L	code    	FFFFFFFFFFFFD988
isAlphaTrue         	L	code    	FFFFFFFFFFFFD980
isAlnum             	L	code    	FFFFFFFFFFFFD990
isDigitx            	L	code    	FFFFFFFFFFFFD9AC
EXPR2               	L	code    	FFFFFFFFFFFFDA70
XP11                	L	code    	FFFFFFFFFFFFD9D0
XP18                	L	code    	FFFFFFFFFFFFDA54
XPRT1               	L	code    	FFFFFFFFFFFFDA3C
XPRT0               	L	code    	FFFFFFFFFFFFDA30
XP12                	L	code    	FFFFFFFFFFFFD9E0
XP13                	L	code    	FFFFFFFFFFFFD9F0
XP14                	L	code    	FFFFFFFFFFFFDA00
XP15                	L	code    	FFFFFFFFFFFFDA10
XP16                	L	code    	FFFFFFFFFFFFDA20
XP17                	L	code    	FFFFFFFFFFFFDA48
XP26                	L	code    	FFFFFFFFFFFFDACC
XP21                	L	code    	FFFFFFFFFFFFDA90
XP22                	L	code    	FFFFFFFFFFFFDA9C
EXPR3               	L	code    	FFFFFFFFFFFFDAE4
XP23                	L	code    	FFFFFFFFFFFFDAA0
XP24                	L	code    	FFFFFFFFFFFFDAB4
XP25                	L	code    	FFFFFFFFFFFFDAC0
XP45                	L	code    	FFFFFFFFFFFFDAD8
EXPR4               	L	code    	FFFFFFFFFFFFDB3C
XP31                	L	code    	FFFFFFFFFFFFDAF0
XP34                	L	code    	FFFFFFFFFFFFDB10
XP47                	L	code    	FFFFFFFFFFFFDB30
XP40                	L	code    	FFFFFFFFFFFFDB50
XP41                	L	code    	FFFFFFFFFFFFDB68
XP46                	L	code    	FFFFFFFFFFFFDB74
PARN                	L	code    	FFFFFFFFFFFFDB7C
XP42                	L	code    	FFFFFFFFFFFFDBA0
XP43                	L	code    	FFFFFFFFFFFFDBA8
tstv_notfound       	L	code    	FFFFFFFFFFFFDC24
TV1                 	L	code    	FFFFFFFFFFFFDC08
SIZEX               	L	code    	FFFFFFFFFFFFDE4C
TV2                 	L	code    	FFFFFFFFFFFFDBFC
QSORRY              	L	code    	FFFFFFFFFFFFDF14
TSTVRT              	L	code    	FFFFFFFFFFFFDC18
getVarName          	L	code    	FFFFFFFFFFFFDC34
findVar             	L	code    	FFFFFFFFFFFFDCCC
gvn1                	L	code    	FFFFFFFFFFFFDCBC
gvn4                	L	code    	FFFFFFFFFFFFDC54
gvn2                	L	code    	FFFFFFFFFFFFDC8C
gvn6                	L	code    	FFFFFFFFFFFFDC7C
gvn3                	L	code    	FFFFFFFFFFFFDCA0
fv4                 	L	code    	FFFFFFFFFFFFDCDC
fv3                 	L	code    	FFFFFFFFFFFFDD00
fv1                 	L	code    	FFFFFFFFFFFFDD08
fv2                 	L	code    	FFFFFFFFFFFFDD18
PEEK                	L	code    	FFFFFFFFFFFFDD2C
PEEKC               	L	code    	FFFFFFFFFFFFDD3C
PEEKH               	L	code    	FFFFFFFFFFFFDD50
PEEKW               	L	code    	FFFFFFFFFFFFDD64
USRX                	L	code    	FFFFFFFFFFFFDD78
RND                 	L	code    	FFFFFFFFFFFFDD94
rnd2                	L	code    	FFFFFFFFFFFFDDC4
rnd1                	L	code    	FFFFFFFFFFFFDDBC
modu4               	L	code    	FFFFFFFFFFFFDDD4
mod2                	L	code    	FFFFFFFFFFFFDDF4
mod1                	L	code    	FFFFFFFFFFFFDE10
ABS                 	L	code    	FFFFFFFFFFFFDE2C
SGN                 	L	code    	FFFFFFFFFFFFDE3C
sv2                 	L	code    	FFFFFFFFFFFFDE7C
SV1                 	L	code    	FFFFFFFFFFFFDEA4
FI1                 	L	code    	FFFFFFFFFFFFDEC4
FI2                 	L	code    	FFFFFFFFFFFFDEDC
ec1                 	L	code    	FFFFFFFFFFFFDF04
TOOBIG              	L	code    	FFFFFFFFFFFFDF0C
GL1                 	L	code    	FFFFFFFFFFFFDF88
GL3                 	L	code    	FFFFFFFFFFFFDFBC
GL4                 	L	code    	FFFFFFFFFFFFDFE4
GL2                 	L	code    	FFFFFFFFFFFFDFA0
GL7                 	L	code    	FFFFFFFFFFFFE014
GL6                 	L	code    	FFFFFFFFFFFFE00C
GL5                 	L	code    	FFFFFFFFFFFFDFF0
fl1                 	L	code    	FFFFFFFFFFFFE03C
FNDRET1             	L	code    	FFFFFFFFFFFFE06C
FNDRET2             	L	code    	FFFFFFFFFFFFE078
FNDRET              	L	code    	FFFFFFFFFFFFE064
MVUP1               	L	code    	FFFFFFFFFFFFE094
MVRET               	L	code    	FFFFFFFFFFFFE0A8
MVDOWN1             	L	code    	FFFFFFFFFFFFE0AC
PP1                 	L	code    	FFFFFFFFFFFFE0F4
PU1                 	L	code    	FFFFFFFFFFFFE138
PS1                 	L	code    	FFFFFFFFFFFFE160
PRTRET              	L	code    	FFFFFFFFFFFFE180
QT1                 	L	code    	FFFFFFFFFFFFE1B8
QT2                 	L	code    	FFFFFFFFFFFFE200
QT3                 	L	code    	FFFFFFFFFFFFE1D0
QT4                 	L	code    	FFFFFFFFFFFFE1E8
QT5                 	L	code    	FFFFFFFFFFFFE20C
prCRLF              	L	code    	FFFFFFFFFFFFE214
PN1                 	L	code    	FFFFFFFFFFFFE264
PN6                 	L	code    	FFFFFFFFFFFFE284
PN4                 	L	code    	FFFFFFFFFFFFE294
PN3                 	L	code    	FFFFFFFFFFFFE288
PN5                 	L	code    	FFFFFFFFFFFFE2A0
PNRET               	L	code    	FFFFFFFFFFFFE2B4
PRTHEXNUM           	L	code    	FFFFFFFFFFFFE2CC
PHN1                	L	code    	FFFFFFFFFFFFE308
PHN7                	L	code    	FFFFFFFFFFFFE31C
PHN8                	L	code    	FFFFFFFFFFFFE320
shru                	L	code    	FFFFFFFFFFFFE32C
r4                  	L	code    	FFFFFFFFFFFFE32C
#4                  	L	code    	FFFFFFFFFFFFE32C
PHN6                	L	code    	FFFFFFFFFFFFE334
PHN4                	L	code    	FFFFFFFFFFFFE344
PHN3                	L	code    	FFFFFFFFFFFFE338
PHN5                	L	code    	FFFFFFFFFFFFE350
PHNRET              	L	code    	FFFFFFFFFFFFE364
TC1                 	L	code    	FFFFFFFFFFFFE3EC
TN1                 	L	code    	FFFFFFFFFFFFE410
TSNMRET             	L	code    	FFFFFFFFFFFFE448
TN2                 	L	code    	FFFFFFFFFFFFE430
IGB2                	L	code    	FFFFFFFFFFFFE458
IGB1                	L	code    	FFFFFFFFFFFFE464
IGBRET              	L	code    	FFFFFFFFFFFFE46C
TOUPB1              	L	code    	FFFFFFFFFFFFE484
TOUPBRT             	L	code    	FFFFFFFFFFFFE4C0
DOQUO               	L	code    	FFFFFFFFFFFFE4A8
toUpper             	L	code    	FFFFFFFFFFFFE4C8
DOQUO1              	L	code    	FFFFFFFFFFFFE4B4
TOUPRET             	L	code    	FFFFFFFFFFFFE4D4
CHKRET2             	L	code    	FFFFFFFFFFFFE4F0
CHKRET              	L	code    	FFFFFFFFFFFFE4F4
PRMESG1             	L	code    	FFFFFFFFFFFFE510
PRMRET              	L	code    	FFFFFFFFFFFFE524
PRMESGA1            	L	code    	FFFFFFFFFFFFE544
PRMRETA             	L	code    	FFFFFFFFFFFFE558
AXIRET_ZERO         	L	code    	FFFFFFFFFFFFE580
AXIRET              	L	code    	FFFFFFFFFFFFE57C
_cls                	L	code    	FFFFFFFFFFFFE58C
_wait10             	L	code    	FFFFFFFFFFFFE594
_getATAStatus       	L	code    	FFFFFFFFFFFFE598
_waitCFNotBusy      	L	code    	FFFFFFFFFFFFE59C
_rdcf               	L	code    	FFFFFFFFFFFFE5A0
rdcf6               	L	code    	FFFFFFFFFFFFE5A4
msgInit             	L	code    	FFFFFFFFFFFFE5C0
OKMSG               	L	code    	FFFFFFFFFFFFE5F6
msgWhat             	L	code    	FFFFFFFFFFFFE5FD
SRYMSG              	L	code    	FFFFFFFFFFFFE605
CLMSG               	L	code    	FFFFFFFFFFFFE60B
msgReadError        	L	code    	FFFFFFFFFFFFE60E
msgNumTooBig        	L	code    	FFFFFFFFFFFFE629
msgDivZero          	L	code    	FFFFFFFFFFFFE63D
msgVarSpace         	L	code    	FFFFFFFFFFFFE650
msgBytesFree        	L	code    	FFFFFFFFFFFFE668
msgReady            	L	code    	FFFFFFFFFFFFE676
msgComma            	L	code    	FFFFFFFFFFFFE680
msgLineRange        	L	code    	FFFFFFFFFFFFE694
msgVar              	L	code    	FFFFFFFFFFFFE6AA
msgRNDBad           	L	code    	FFFFFFFFFFFFE6C1
msgSYSBad           	L	code    	FFFFFFFFFFFFE6D5
msgInputVar         	L	code    	FFFFFFFFFFFFE6E7
msgNextFor          	L	code    	FFFFFFFFFFFFE704
msgNextVar          	L	code    	FFFFFFFFFFFFE717
msgBadGotoGosub     	L	code    	FFFFFFFFFFFFE73B
msgRetWoGosub       	L	code    	FFFFFFFFFFFFE758
msgTooBig           	L	code    	FFFFFFFFFFFFE76F
msgExtraChars       	L	code    	FFFFFFFFFFFFE784
LSTROM              	C	constant	0000000000000000
ramtest             	L	code    	FFFFFFFFFFFFE7B0
ramtest2            	L	code    	FFFFFFFFFFFFE7C4
ramtest1            	L	code    	FFFFFFFFFFFFE7E8
ramtest4            	L	code    	FFFFFFFFFFFFE7F0
ramtest3            	L	code    	FFFFFFFFFFFFE81C
ramtest8            	L	code    	FFFFFFFFFFFFE88C
ramtest5            	L	code    	FFFFFFFFFFFFE834
ramtest6            	L	code    	FFFFFFFFFFFFE858
ramtest7            	L	code    	FFFFFFFFFFFFE860
ramtest9            	L	code    	FFFFFFFFFFFFE894
ramtest10           	L	code    	FFFFFFFFFFFFE89C
iberr_rout          	L	code    	FFFFFFFFFFFFE8A4
dberr_rout          	L	code    	FFFFFFFFFFFFE8BC
dberr1              	L	code    	FFFFFFFFFFFFE8E4
msgdberr            	L	code    	FFFFFFFFFFFFE910
msgEPC              	L	code    	FFFFFFFFFFFFE924
msgiberr            	L	code    	FFFFFFFFFFFFE92B
irqrout             	L	code    	FFFFFFFFFFFFE950
irq1000Hz           	L	code    	FFFFFFFFFFFFE970
irq100Hz            	L	code    	FFFFFFFFFFFFE9C8
irqSerial           	L	code    	FFFFFFFFFFFFE9D8
irqret              	L	code    	FFFFFFFFFFFFEA08
irqRaster           	L	code    	FFFFFFFFFFFFE9E8
irqKeybd            	L	code    	FFFFFFFFFFFFE9F8
nmirout             	L	code    	FFFFFFFFFFFFEA20
DTLBHandler         	L	code    	FFFFFFFFFFFFEA24
dh1                 	L	code    	FFFFFFFFFFFFEA34
